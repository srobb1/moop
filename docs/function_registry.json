{
    "metadata": {
        "generated": "2026-01-31 22:43:17",
        "totalFunctions": 157,
        "totalFiles": 19,
        "duplicates": 0
    },
    "files": [
        {
            "name": "admin/manage_filesystem_permissions.php",
            "count": 1,
            "functions": [
                {
                    "name": "performPermissionCheck",
                    "line": 233,
                    "comment": "",
                    "code": "function performPermissionCheck($path, $item) {\n    $result = [\n        'name' => $item['name'],\n        'path' => $path,\n        'exists' => file_exists($path),\n        'type' => $item['type'],\n        'required_perms' => $item['required_perms'],\n        'required_group' => $item['required_group'] ?? 'www-data',\n        'reason' => $item['reason'] ?? '',\n        'why_write' => $item['why_write'] ?? '',\n        'sticky_bit' => $item['sticky_bit'] ?? false,\n        'issues' => [],\n    ];\n    \n    if (!$result['exists']) {\n        $result['issues'][] = 'Path does not exist';\n        return $result;\n    }\n    \n    $perms_full = substr(sprintf('%o', fileperms($path)), -4);\n    // Remove leading zero for comparison (0664 -> 664, 02775 -> 2775)\n    $perms = ltrim($perms_full, '0') ?: '0';\n    $owner = posix_getpwuid(fileowner($path))['name'] ?? 'unknown';\n    $group = posix_getgrgid(filegroup($path))['name'] ?? 'unknown';\n    \n    $result['current_perms'] = $perms;\n    $result['current_owner'] = $owner;\n    $result['current_group'] = $group;\n    $result['is_readable'] = is_readable($path);\n    $result['is_writable'] = is_writable($path);\n    \n    // Check permissions\n    if ($perms !== $item['required_perms']) {\n        $result['issues'][] = \"Permissions are $perms, should be \" . $item['required_perms'];\n    }\n    \n    // Check group\n    if (isset($item['required_group']) && $group !== $item['required_group']) {\n        $result['issues'][] = \"Group is $group, should be \" . $item['required_group'];\n    }\n    \n    return $result;\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "performPermissionCheck"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "file-io",
                        "security-related",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_filesystem_permissions.php",
                            "line": 233,
                            "context": "$checks[] = performPermissionCheck($path, $item);"
                        },
                        {
                            "file": "/data/moop/admin/manage_filesystem_permissions.php",
                            "line": 244,
                            "context": "$check = performPermissionCheck($subdir_path, ["
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/blast_functions.php",
            "count": 6,
            "functions": [
                {
                    "name": "getBlastDatabases",
                    "line": 23,
                    "comment": "/**\n* Get list of available BLAST databases for an assembly\n* Looks for FASTA files matching configured sequence type patterns\n* (protein.aa.fa, cds.nt.fa, transcript.nt.fa)\n*\n* @param string $assembly_path Path to assembly directory\n* @return array Array of BLAST databases with type and path\n*   Format: [\n*     ['name' => 'protein', 'path' => '/path/to/protein.aa.fa', 'type' => 'protein'],\n*     ['name' => 'cds', 'path' => '/path/to/cds.nt.fa', 'type' => 'nucleotide']\n*   ]\n*/",
                    "code": "function getBlastDatabases($assembly_path) {\n    global $sequence_types;\n    $databases = [];\n    \n    if (!is_dir($assembly_path)) {\n        return $databases;\n    }\n    \n    // Map sequence types to database info\n    $type_mapping = [\n        'protein' => ['name' => 'Protein', 'blast_type' => 'protein'],\n        'cds' => ['name' => 'CDS', 'blast_type' => 'nucleotide'],\n        'transcript' => ['name' => 'Transcript', 'blast_type' => 'nucleotide'],\n    ];\n    \n    // Check for each configured sequence type\n    if (!empty($sequence_types)) {\n        foreach ($sequence_types as $seq_type => $config) {\n            $pattern = $config['pattern'] ?? '';\n            if (empty($pattern)) {\n                continue;\n            }\n            \n            $file_path = \"$assembly_path/$pattern\";\n            \n            // Check if file exists\n            if (file_exists($file_path)) {\n                $type_info = $type_mapping[$seq_type] ?? ['name' => ucfirst($seq_type), 'blast_type' => 'nucleotide'];\n                \n                $databases[] = [\n                    'name' => $type_info['name'],\n                    'path' => $file_path,\n                    'type' => $type_info['blast_type']\n                ];\n            }\n        }\n    }\n    \n    return $databases;\n}",
                    "parameters": [
                        {
                            "name": "assembly_path",
                            "type": "string",
                            "description": "Path to assembly directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of BLAST databases with type and path",
                    "internalCalls": [
                        "getBlastDatabases"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/blast.php",
                            "line": 147,
                            "context": "$all_dbs = getBlastDatabases($selected_source_obj['path']);"
                        },
                        {
                            "file": "/data/moop/tools/blast.php",
                            "line": 210,
                            "context": "$databasesByAssembly[$key] = getBlastDatabases($source['path']);"
                        }
                    ]
                },
                {
                    "name": "filterDatabasesByProgram",
                    "line": 72,
                    "comment": "/**\n* Filter BLAST databases by program type\n* Returns only databases compatible with the selected BLAST program\n*\n* @param array $databases Array of databases from getBlastDatabases()\n* @param string $blast_program BLAST program: blastn, blastp, blastx, tblastn, tblastx\n* @return array Filtered array of compatible databases\n*/",
                    "code": "function filterDatabasesByProgram($databases, $blast_program) {\n    $filtered = [];\n    \n    // Determine which database types are compatible with the program\n    $compatible_types = [];\n    switch ($blast_program) {\n        case 'blastn':\n        case 'tblastn':\n        case 'tblastx':\n            $compatible_types = ['nucleotide'];\n            break;\n        case 'blastp':\n        case 'blastx':\n            $compatible_types = ['protein'];\n            break;\n        default:\n            return $databases; // Unknown program, return all\n    }\n    \n    foreach ($databases as $db) {\n        if (in_array($db['type'], $compatible_types)) {\n            $filtered[] = $db;\n        }\n    }\n    \n    return $filtered;\n}",
                    "parameters": [
                        {
                            "name": "databases",
                            "type": "array",
                            "description": "Array of databases from getBlastDatabases()"
                        },
                        {
                            "name": "blast_program",
                            "type": "string",
                            "description": "BLAST program: blastn, blastp, blastx, tblastn, tblastx"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Filtered array of compatible databases",
                    "internalCalls": [
                        "filterDatabasesByProgram"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "executeBlastSearch",
                    "line": 110,
                    "comment": "/**\n* Execute BLAST search\n* Runs BLAST command with outfmt 11 (ASN.1), then converts using blast_formatter\n*\n* @param string $query_seq FASTA sequence to search\n* @param string $blast_db Path to BLAST database (without extension)\n* @param string $program BLAST program (blastn, blastp, blastx, etc.)\n* @param array $options Additional BLAST options (evalue, max_hits, matrix, etc.)\n* @return array Result array with 'success', 'output', 'error', and 'stderr' keys\n*/",
                    "code": "function executeBlastSearch($query_seq, $blast_db, $program, $options = []) {\n    $result = [\n        'success' => false,\n        'output' => '',\n        'error' => '',\n        'stderr' => ''\n    ];\n    \n    // Validate inputs\n    if (empty($query_seq) || empty($blast_db) || empty($program)) {\n        $result['error'] = 'Missing required parameters for BLAST search';\n        return $result;\n    }\n    \n    // Verify database exists - check for any of the BLAST index files\n    $has_index = false;\n    if (file_exists(\"$blast_db.nhr\") || file_exists(\"$blast_db.phr\") || \n        file_exists(\"$blast_db.ndb\") || file_exists(\"$blast_db.pdb\")) {\n        $has_index = true;\n    }\n    \n    if (!$has_index) {\n        $result['error'] = 'BLAST database not found: ' . basename($blast_db);\n        return $result;\n    }\n    \n    // Set default options\n    $evalue = $options['evalue'] ?? '1e-3';\n    $max_hits = (int)($options['max_hits'] ?? 10);\n    $matrix = $options['matrix'] ?? 'BLOSUM62';\n    $filter = $options['filter'] ? 'yes' : 'no';\n    $task = $options['task'] ?? '';\n    \n    // Create temporary directory for ASN.1 archive output\n    $temp_dir = sys_get_temp_dir();\n    $archive_file = tempnam($temp_dir, 'blast_');\n    \n    if ($archive_file === false) {\n        $result['error'] = 'Failed to create temporary file for BLAST output';\n        return $result;\n    }\n    \n    // Build BLAST command with outfmt 11 (ASN.1)\n    $cmd = [];\n    $cmd[] = $program;\n    // Use absolute path for database\n    // For BLAST databases, we pass the base name and BLAST appends the extensions\n    $db_dir = dirname($blast_db);\n    $db_base = basename($blast_db);\n    $db_path = realpath($db_dir);\n    if (!$db_path) {\n        unlink($archive_file);\n        $result['error'] = 'Cannot resolve database path: ' . $blast_db;\n        return $result;\n    }\n    $full_db_path = $db_path . '/' . $db_base;\n    $cmd[] = '-db ' . escapeshellarg($full_db_path);\n    $cmd[] = '-evalue ' . escapeshellarg($evalue);\n    $cmd[] = '-num_descriptions ' . escapeshellarg($max_hits);\n    $cmd[] = '-num_alignments ' . escapeshellarg($max_hits);\n    $cmd[] = '-outfmt 11';\n    $cmd[] = '-out ' . escapeshellarg($archive_file);\n    \n    // Add program-specific options\n    if ($program === 'blastn') {\n        $cmd[] = '-dust ' . escapeshellarg($filter);\n    } elseif ($program === 'tblastn') {\n        $cmd[] = '-seg ' . escapeshellarg($filter);\n    } elseif (in_array($program, ['blastp', 'blastx', 'tblastx'])) {\n        $cmd[] = '-seg ' . escapeshellarg($filter);\n        $cmd[] = '-matrix ' . escapeshellarg($matrix);\n    }\n    \n    // Add task if specified\n    if (!empty($task)) {\n        $cmd[] = '-task ' . escapeshellarg($task);\n    }\n    \n    $command = 'printf ' . escapeshellarg($query_seq) . ' | ' . implode(' ', $cmd);\n    \n    // Execute BLAST with proc_open for better control\n    $descriptors = [\n        0 => [\"pipe\", \"r\"],\n        1 => [\"pipe\", \"w\"],\n        2 => [\"pipe\", \"w\"],\n    ];\n    \n    $process = proc_open($command, $descriptors, $pipes);\n    if (!is_resource($process)) {\n        unlink($archive_file);\n        $result['error'] = 'Failed to execute BLAST command';\n        return $result;\n    }\n    \n    fclose($pipes[0]);\n    $blast_stdout = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n    $blast_stderr = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n    $return_code = proc_close($process);\n    \n    if ($return_code !== 0) {\n        unlink($archive_file);\n        $result['error'] = 'BLAST execution failed with code ' . $return_code;\n        $result['stderr'] = $blast_stderr;\n        return $result;\n    }\n    \n    // Convert ASN.1 archive to outfmt 5 (XML) using blast_formatter\n    $xml_file = tempnam($temp_dir, 'blast_xml_');\n    $formatter_cmd = 'blast_formatter -archive ' . escapeshellarg($archive_file) . \n                     ' -outfmt 5 -out ' . escapeshellarg($xml_file);\n    \n    $process = proc_open($formatter_cmd, $descriptors, $pipes);\n    if (!is_resource($process)) {\n        unlink($archive_file);\n        $result['error'] = 'Failed to execute blast_formatter for XML';\n        return $result;\n    }\n    \n    fclose($pipes[0]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n    $return_code = proc_close($process);\n    \n    if ($return_code !== 0) {\n        unlink($archive_file);\n        unlink($xml_file);\n        $result['error'] = 'blast_formatter XML conversion failed with code ' . $return_code;\n        return $result;\n    }\n    \n    // Read the XML output\n    $output = file_get_contents($xml_file);\n    \n    // Now convert ASN.1 archive to outfmt 0 (Pairwise text) for download\n    $pairwise_file = tempnam($temp_dir, 'blast_pairwise_');\n    $formatter_cmd = 'blast_formatter -archive ' . escapeshellarg($archive_file) . \n                     ' -outfmt 0 -out ' . escapeshellarg($pairwise_file);\n    \n    $process = proc_open($formatter_cmd, $descriptors, $pipes);\n    if (!is_resource($process)) {\n        unlink($archive_file);\n        unlink($xml_file);\n        unlink($pairwise_file);\n        $result['error'] = 'Failed to execute blast_formatter for pairwise';\n        return $result;\n    }\n    \n    fclose($pipes[0]);\n    fclose($pipes[1]);\n    fclose($pipes[2]);\n    $return_code = proc_close($process);\n    \n    if ($return_code !== 0) {\n        unlink($archive_file);\n        unlink($xml_file);\n        unlink($pairwise_file);\n        $result['error'] = 'blast_formatter pairwise conversion failed with code ' . $return_code;\n        return $result;\n    }\n    \n    // Read the pairwise output\n    $pairwise_output = file_get_contents($pairwise_file);\n    \n    // Clean up temporary files\n    unlink($archive_file);\n    unlink($xml_file);\n    unlink($pairwise_file);\n    \n    $result['success'] = true;\n    $result['output'] = $output;\n    $result['pairwise'] = $pairwise_output;\n    $result['stderr'] = $blast_stderr;\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "query_seq",
                            "type": "string",
                            "description": "FASTA sequence to search"
                        },
                        {
                            "name": "blast_db",
                            "type": "string",
                            "description": "Path to BLAST database (without extension)"
                        },
                        {
                            "name": "program",
                            "type": "string",
                            "description": "BLAST program (blastn, blastp, blastx, etc.)"
                        },
                        {
                            "name": "options",
                            "type": "array",
                            "description": "Additional BLAST options (evalue, max_hits, matrix, etc.)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Result array with 'success', 'output', 'error', and 'stderr' keys",
                    "internalCalls": [
                        "executeBlastSearch"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/blast.php",
                            "line": 191,
                            "context": "$blast_result = executeBlastSearch($query_with_header, $blast_db, $blast_program, $blast_options);"
                        }
                    ]
                },
                {
                    "name": "extractSequencesFromBlastDb",
                    "line": 299,
                    "comment": "/**\n* Extract sequences from BLAST database using blastdbcmd\n* Used by fasta extract and download tools\n* Supports parent->child lookup from database\n*\n* @param string $blast_db Path to BLAST database (without extension)\n* @param array $sequence_ids Array of sequence IDs to extract\n* @param string $organism Optional organism name for parent/child lookup\n* @param string $assembly Optional assembly name for parent/child lookup\n* @return array Result array with 'success', 'content', and 'error' keys\n*/",
                    "code": "function extractSequencesFromBlastDb($blast_db, $sequence_ids, $organism = '', $assembly = '', $ranges = [], $original_input_ids = [], $parent_to_children = []) {\n    $result = [\n        'success' => false,\n        'content' => '',\n        'error' => ''\n    ];\n    \n    if (empty($sequence_ids) || !is_array($sequence_ids)) {\n        $result['error'] = 'No sequence IDs provided';\n        return $result;\n    }\n    \n    if (!file_exists($blast_db . '.nhr') && !file_exists($blast_db . '.phr')) {\n        $result['error'] = 'BLAST database not found';\n        return $result;\n    }\n    \n    // Check if $ranges is provided and not empty\n    if (!empty($ranges)) {\n        // Use batch mode with range file\n        // Convert ranges from \"ID:start-end\" format to \"ID start-end\" format for blastdbcmd\n        $batch_ranges = array_map(function($range) {\n            // Convert \"ID:start-end\" or \"ID:start-end\" to \"ID start-end\"\n            return preg_replace('/^([^:]+):(\\d+-\\d+)$/', '$1 $2', $range);\n        }, $ranges);\n        \n        // Build batch entries: converted ranges + regular IDs as full sequences\n        // Ranges apply to parent AND all children\n        $ids_with_ranges = array_map(function($range) {\n            return explode(':', $range)[0];\n        }, $ranges);\n        \n        // For each ranged ID, find and add all its children with the same range\n        $expanded_ranges = [];\n        foreach ($batch_ranges as $range_entry) {\n            $expanded_ranges[] = $range_entry; // Add the original range\n            \n            // Extract the ID and range portion from \"ID start-end\"\n            if (preg_match('/^(.+?)\\s+(\\d+-\\d+)$/', $range_entry, $matches)) {\n                $parent_id = $matches[1];\n                $range_portion = $matches[2];\n                \n                // Find all children of this parent in sequence_ids and add with same range\n                foreach ($sequence_ids as $id) {\n                    // Check if this ID is a child of parent_id (e.g., \"ID.1\", \"ID.2\")\n                    if (preg_match('/^' . preg_quote($parent_id) . '\\.\\d+$/', $id)) {\n                        $expanded_ranges[] = \"$id $range_portion\";\n                    }\n                }\n            }\n        }\n        \n        // Build batch file following the 4-step plan:\n        // 1. Add all no-range input IDs (as full sequences)\n        // 2. Add all children of input IDs with no ranges (as full sequences)\n        // 3. Add all input IDs with ranges (with range formatting)\n        // 4. Add all children of input IDs with ranges (with same ranges as parent)\n        \n        $batch_entries = [];\n        \n        // Separate original input IDs into those with and without ranges\n        $input_ids_with_ranges = [];\n        $input_ids_no_ranges = [];\n        \n        foreach ($original_input_ids as $id) {\n            $has_range = false;\n            foreach ($ranges as $range_entry) {\n                $range_id = explode(':', $range_entry)[0];\n                $range_id = explode(' ', $range_id)[0];\n                if ($range_id === $id) {\n                    $has_range = true;\n                    break;\n                }\n            }\n            if ($has_range) {\n                $input_ids_with_ranges[] = $id;\n            } else {\n                $input_ids_no_ranges[] = $id;\n            }\n        }\n        \n        // Step 1: Add all no-range input IDs (full sequences)\n        foreach ($input_ids_no_ranges as $id) {\n            if (in_array($id, $sequence_ids)) {\n                $batch_entries[] = $id;\n            }\n        }\n        \n        // Step 2: Add all children of input IDs with no ranges (full sequences)\n        foreach ($input_ids_no_ranges as $parent_id) {\n            if (isset($parent_to_children[$parent_id])) {\n                foreach ($parent_to_children[$parent_id] as $child_id) {\n                    if (in_array($child_id, $sequence_ids)) {\n                        $batch_entries[] = $child_id;\n                    }\n                }\n            }\n        }\n        \n        // Step 3: Add all input IDs with ranges (formatted as \"ID range\")\n        foreach ($input_ids_with_ranges as $id) {\n            // Find the corresponding converted range in $batch_ranges\n            foreach (array_keys($ranges) as $idx) {\n                $range_id = explode(':', $ranges[$idx])[0];\n                $range_id = explode(' ', $range_id)[0];\n                if ($range_id === $id) {\n                    // Use the converted batch_ranges entry (with space, not colon)\n                    $batch_entries[] = $batch_ranges[$idx];\n                    break;\n                }\n            }\n        }\n        \n        // Step 4: Add all children of input IDs with ranges (with same ranges as parent)\n        foreach ($input_ids_with_ranges as $parent_id) {\n            if (isset($parent_to_children[$parent_id])) {\n                // Find the range for this parent\n                $parent_range = '';\n                foreach ($ranges as $range_entry) {\n                    $range_id = explode(':', $range_entry)[0];\n                    $range_id = explode(' ', $range_id)[0];\n                    if ($range_id === $parent_id) {\n                        // Extract range portion\n                        $parent_range = strpos($range_entry, ':') !== false ? \n                            explode(':', $range_entry)[1] : \n                            explode(' ', $range_entry)[1];\n                        break;\n                    }\n                }\n                \n                // Add each child with same range\n                if (!empty($parent_range)) {\n                    foreach ($parent_to_children[$parent_id] as $child_id) {\n                        if (in_array($child_id, $sequence_ids)) {\n                            $batch_entries[] = \"$child_id $parent_range\";\n                        }\n                    }\n                }\n            }\n        }\n        \n        $temp_file = tempnam(sys_get_temp_dir(), 'blastdb_');\n        if ($temp_file === false) {\n            $result['error'] = 'Failed to create temporary file for batch processing';\n            return $result;\n        }\n        \n        // Write batch entries to temporary file\n        if (file_put_contents($temp_file, implode(\"\\n\", $batch_entries)) === false) {\n            @unlink($temp_file);\n            $result['error'] = 'Failed to write batch file for range extraction';\n            return $result;\n        }\n        \n        // Execute: blastdbcmd -db ... -entry_batch temp_file\n        $cmd = \"blastdbcmd -db \" . escapeshellarg($blast_db) . \" -entry_batch \" . escapeshellarg($temp_file) . \" 2>&1\";\n        \n        $output = [];\n        $return_var = 0;\n        @exec($cmd, $output, $return_var);\n        \n        // Delete temp file after execution\n        @unlink($temp_file);\n        \n        // Filter out blastdbcmd error messages (lines starting with \"Error:\")\n        $output = array_filter($output, function($line) {\n            return strpos(trim($line), 'Error:') !== 0;\n        });\n        \n        // Check if blastdbcmd executed\n        if ($return_var > 1) {\n            $result['error'] = \"Error extracting sequences (exit code: $return_var). Ensure blastdbcmd is installed and FASTA files are formatted correctly.\";\n            return $result;\n        }\n        \n        // Check if we got any output\n        if (empty($output)) {\n            $result['error'] = 'No sequences found for the requested IDs and ranges';\n            return $result;\n        }\n    } else {\n        // No ranges - use current logic: Execute: blastdbcmd -db ... -entry IDs\n        $ids_string = implode(',', $sequence_ids);\n        $cmd = \"blastdbcmd -db \" . escapeshellarg($blast_db) . \" -entry \" . escapeshellarg($ids_string) . \" 2>/dev/null\";\n        $output = [];\n        $return_var = 0;\n        @exec($cmd, $output, $return_var);\n        \n        // Filter out blastdbcmd error messages (lines starting with \"Error:\")\n        $output = array_filter($output, function($line) {\n            return strpos(trim($line), 'Error:') !== 0;\n        });\n        \n        // Check if blastdbcmd executed\n        if ($return_var > 1) {\n            // Return code 1 is expected when some IDs don't exist, but >1 is an error\n            $result['error'] = \"Error extracting sequences (exit code: $return_var). Ensure blastdbcmd is installed and FASTA files are formatted correctly.\";\n            return $result;\n        }\n        \n        // Check if we got any output\n        if (empty($output)) {\n            $result['error'] = 'No sequences found for the requested IDs';\n            return $result;\n        }\n    }\n    \n    $result['success'] = true;\n    $result['content'] = implode(\"\\n\", $output);\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "blast_db",
                            "type": "string",
                            "description": "Path to BLAST database (without extension)"
                        },
                        {
                            "name": "sequence_ids",
                            "type": "array",
                            "description": "Array of sequence IDs to extract"
                        },
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Optional organism name for parent/child lookup"
                        },
                        {
                            "name": "assembly",
                            "type": "string",
                            "description": "Optional assembly name for parent/child lookup"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Result array with 'success', 'content', and 'error' keys",
                    "internalCalls": [
                        "extractSequencesFromBlastDb"
                    ],
                    "category": "database",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/extract_search_helpers.php",
                            "line": 163,
                            "context": "$extract_result = extractSequencesFromBlastDb($fasta_file, $uniquenames, $organism, $assembly, $ranges, $original_input_ids, $parent_to_children);"
                        },
                        {
                            "file": "/data/moop/lib/extract_search_helpers.php",
                            "line": 184,
                            "context": "$extract_result = extractSequencesFromBlastDb($fasta_file, $uniquenames, $organism, $assembly, $ranges, $original_input_ids, $parent_to_children);"
                        }
                    ]
                },
                {
                    "name": "validateBlastSequence",
                    "line": 519,
                    "comment": "/**\n* Validate BLAST sequence input\n* Checks if input is valid FASTA format\n*\n* @param string $sequence Raw sequence input (may or may not have FASTA header)\n* @return array Array with 'valid' bool and 'error' string\n*/",
                    "code": "function validateBlastSequence($sequence) {\n    $sequence = trim($sequence);\n    \n    if (empty($sequence)) {\n        return ['valid' => false, 'error' => 'Sequence is empty'];\n    }\n    \n    // If sequence doesn't start with >, add a header\n    if ($sequence[0] !== '>') {\n        $sequence = \">query_sequence\\n\" . $sequence;\n    }\n    \n    // Basic FASTA format validation\n    $lines = explode(\"\\n\", $sequence);\n    $in_header = true;\n    $seq_count = 0;\n    \n    foreach ($lines as $line) {\n        $line = trim($line);\n        if (empty($line)) {\n            continue;\n        }\n        \n        if ($line[0] === '>') {\n            if (!$in_header && $seq_count === 0) {\n                return ['valid' => false, 'error' => 'Invalid FASTA format: sequence expected before header'];\n            }\n            $in_header = true;\n            $seq_count = 0;\n        } else {\n            if ($in_header) {\n                $in_header = false;\n            }\n            $seq_count += strlen($line);\n        }\n    }\n    \n    if ($seq_count === 0) {\n        return ['valid' => false, 'error' => 'No sequence data found'];\n    }\n    \n    return ['valid' => true, 'error' => ''];\n}",
                    "parameters": [
                        {
                            "name": "sequence",
                            "type": "string",
                            "description": "Raw sequence input (may or may not have FASTA header)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with 'valid' bool and 'error' string",
                    "internalCalls": [
                        "validateBlastSequence"
                    ],
                    "category": "validation",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/blast.php",
                            "line": 162,
                            "context": "$validation = validateBlastSequence($search_query);"
                        }
                    ]
                },
                {
                    "name": "validateBlastIndexFiles",
                    "line": 570,
                    "comment": "/**\n* Validate BLAST index files for FASTA sequences\n* Checks if BLAST databases have their index files (.nhr, .nin, .nsq for nucleotide, .phr, .pin, .psq for protein)\n* @param string $assembly_path Path to assembly directory\n* @param array $sequence_types Configured sequence types\n* @return array Array with 'databases' containing status of each FASTA file\n*/",
                    "code": "function validateBlastIndexFiles($assembly_path, $sequence_types = []) {\n    $result = [\n        'databases' => [],\n        'missing_count' => 0,\n        'total_count' => 0\n    ];\n    \n    if (!is_dir($assembly_path)) {\n        return $result;\n    }\n    \n    // Map sequence types to BLAST index extensions\n    $type_mapping = [\n        'protein' => ['name' => 'Protein', 'extensions' => ['phr', 'pin', 'psq']],\n        'cds' => ['name' => 'CDS', 'extensions' => ['nhr', 'nin', 'nsq']],\n        'transcript' => ['name' => 'Transcript', 'extensions' => ['nhr', 'nin', 'nsq']],\n    ];\n    \n    // Check for each configured sequence type\n    if (!empty($sequence_types)) {\n        foreach ($sequence_types as $seq_type => $config) {\n            $pattern = $config['pattern'] ?? '';\n            if (empty($pattern)) {\n                continue;\n            }\n            \n            $file_path = \"$assembly_path/$pattern\";\n            \n            // Only check if FASTA file exists\n            if (!file_exists($file_path)) {\n                continue;\n            }\n            \n            $result['total_count']++;\n            $type_info = $type_mapping[$seq_type] ?? ['name' => ucfirst($seq_type), 'extensions' => ['nhr', 'nin', 'nsq']];\n            \n            $db_entry = [\n                'type' => $seq_type,\n                'name' => $type_info['name'],\n                'fasta' => basename($file_path),\n                'fasta_path' => $file_path,\n                'has_indexes' => true,\n                'missing_indexes' => []\n            ];\n            \n            // Check for all required index files\n            foreach ($type_info['extensions'] as $ext) {\n                $index_file = \"$file_path.$ext\";\n                if (!file_exists($index_file)) {\n                    $db_entry['has_indexes'] = false;\n                    $db_entry['missing_indexes'][] = $ext;\n                }\n            }\n            \n            if (!$db_entry['has_indexes']) {\n                $result['missing_count']++;\n            }\n            \n            $result['databases'][] = $db_entry;\n        }\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "assembly_path",
                            "type": "string",
                            "description": "Path to assembly directory"
                        },
                        {
                            "name": "sequence_types",
                            "type": "array",
                            "description": "Configured sequence types"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with 'databases' containing status of each FASTA file",
                    "internalCalls": [
                        "validateBlastIndexFiles"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 834,
                            "context": "$blast_validation = validateBlastIndexFiles($assembly_path, $sequence_types);"
                        },
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 293,
                            "context": "$blast_validation = validateBlastIndexFiles($assembly_path, $sequence_types);"
                        },
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 952,
                            "context": "$blast_validation = validateBlastIndexFiles($assembly_path, $sequence_types);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/blast_results_visualizer.php",
            "count": 15,
            "functions": [
                {
                    "name": "parseBlastResults",
                    "line": 21,
                    "comment": "/**\n* Parse BLAST results from XML output\n* Supports multiple queries, each with Hit/HSP hierarchy\n* Original MOOP implementation - independently developed\n*\n* @param string $blast_xml Raw BLAST XML output\n* @return array Array of parsed query results, each with hits array\n*/",
                    "code": "function parseBlastResults($blast_xml) {\n    $all_queries = [];\n    \n    // Parse XML\n    try {\n        $xml = simplexml_load_string($blast_xml);\n        \n        if ($xml === false) {\n            return ['error' => 'Failed to parse BLAST XML output', 'queries' => []];\n        }\n        \n        // Parse each iteration (each query gets one iteration)\n        $iterations = $xml->xpath('//Iteration');\n        \n        foreach ($iterations as $iteration) {\n            $query_result = [\n                'hits' => [],\n                'query_length' => 0,\n                'query_name' => '',\n                'query_desc' => '',\n                'total_hits' => 0,\n                'error' => ''\n            ];\n            \n            // Get query info using XPath to handle hyphens in element names\n            $query_len = $iteration->xpath('./Iteration_query-len');\n            if (!empty($query_len)) {\n                $query_result['query_length'] = (int)$query_len[0];\n            }\n            \n            $query_id = $iteration->xpath('./Iteration_query-ID');\n            if (!empty($query_id)) {\n                $query_result['query_name'] = (string)$query_id[0];\n            }\n            \n            $query_def = $iteration->xpath('./Iteration_query-def');\n            if (!empty($query_def)) {\n                $query_result['query_desc'] = (string)$query_def[0];\n            }\n            \n            // Parse each hit using XPath - maintain Hit/HSP hierarchy\n            $hits = $iteration->xpath('.//Hit');\n            foreach ($hits as $hit_node) {\n                // Get hit info\n                $hit_id = $hit_node->xpath('./Hit_id');\n                $hit_def = $hit_node->xpath('./Hit_def');\n                $hit_len = $hit_node->xpath('./Hit_len');\n                \n                $hit_id_str = !empty($hit_id) ? (string)$hit_id[0] : '';\n                $hit_def_str = !empty($hit_def) ? (string)$hit_def[0] : '';\n                $hit_len_int = !empty($hit_len) ? (int)$hit_len[0] : 0;\n                \n                // Get all HSPs (High-scoring Segment Pairs) for this hit\n                $hsps = $hit_node->xpath('.//Hsp');\n                if (!empty($hsps)) {\n                    $hsps_array = [];\n                    $best_evalue = PHP_FLOAT_MAX;\n                    $cumulative_coverage = [];\n                    \n                    // Process each HSP for this hit\n                    foreach ($hsps as $hsp) {\n                        // Use XPath for HSP elements with hyphens\n                        $identities = $hsp->xpath('./Hsp_identity');\n                        $align_len = $hsp->xpath('./Hsp_align-len');\n                        $evalue = $hsp->xpath('./Hsp_evalue');\n                        $bit_score = $hsp->xpath('./Hsp_bit-score');\n                        $score = $hsp->xpath('./Hsp_score');\n                        $query_from = $hsp->xpath('./Hsp_query-from');\n                        $query_to = $hsp->xpath('./Hsp_query-to');\n                        $hit_from = $hsp->xpath('./Hsp_hit-from');\n                        $hit_to = $hsp->xpath('./Hsp_hit-to');\n                        $qseq = $hsp->xpath('./Hsp_qseq');\n                        $hseq = $hsp->xpath('./Hsp_hseq');\n                        $midline = $hsp->xpath('./Hsp_midline');\n                        \n                        $identities_int = !empty($identities) ? (int)$identities[0] : 0;\n                        $align_len_int = !empty($align_len) ? (int)$align_len[0] : 0;\n                        $evalue_float = !empty($evalue) ? (float)$evalue[0] : 0;\n                        $hit_from_int = !empty($hit_from) ? (int)$hit_from[0] : 0;\n                        $hit_to_int = !empty($hit_to) ? (int)$hit_to[0] : 0;\n                        \n                        // Track best (smallest) evalue\n                        if ($evalue_float < $best_evalue) {\n                            $best_evalue = $evalue_float;\n                        }\n                        \n                        // Track coverage regions for cumulative calculation\n                        $cumulative_coverage[] = [\n                            'from' => min($hit_from_int, $hit_to_int),\n                            'to' => max($hit_from_int, $hit_to_int)\n                        ];\n                        \n                        // Count gaps and similarities with gap lengths\n                        $query_seq = !empty($qseq) ? (string)$qseq[0] : '';\n                        $hit_seq = !empty($hseq) ? (string)$hseq[0] : '';\n                        $midline_str = !empty($midline) ? (string)$midline[0] : '';\n                        \n                        // Count gaps and track individual gap lengths\n                        $gap_count = 0;\n                        $gap_lengths = [];\n                        \n                        // Find gaps in query sequence\n                        $in_gap = false;\n                        $gap_len = 0;\n                        for ($i = 0; $i < strlen($query_seq); $i++) {\n                            if ($query_seq[$i] === '-') {\n                                if (!$in_gap) {\n                                    $in_gap = true;\n                                    $gap_len = 1;\n                                } else {\n                                    $gap_len++;\n                                }\n                            } else {\n                                if ($in_gap) {\n                                    $gap_lengths[] = $gap_len;\n                                    $gap_count += $gap_len;\n                                    $in_gap = false;\n                                }\n                            }\n                        }\n                        if ($in_gap) {\n                            $gap_lengths[] = $gap_len;\n                            $gap_count += $gap_len;\n                        }\n                        \n                        // Find gaps in hit sequence\n                        $in_gap = false;\n                        $gap_len = 0;\n                        for ($i = 0; $i < strlen($hit_seq); $i++) {\n                            if ($hit_seq[$i] === '-') {\n                                if (!$in_gap) {\n                                    $in_gap = true;\n                                    $gap_len = 1;\n                                } else {\n                                    $gap_len++;\n                                }\n                            } else {\n                                if ($in_gap) {\n                                    $gap_lengths[] = $gap_len;\n                                    $gap_count += $gap_len;\n                                    $in_gap = false;\n                                }\n                            }\n                        }\n                        if ($in_gap) {\n                            $gap_lengths[] = $gap_len;\n                            $gap_count += $gap_len;\n                        }\n                        \n                        $total_gap_length = $gap_count;\n                        $gaps = count($gap_lengths);\n                        $gap_lengths_str = implode(', ', $gap_lengths);\n                        \n                        $similarities = strlen($midline_str) - $identities_int - substr_count($midline_str, ' ');\n                        \n                        // Calculate HSP subject coverage percentage\n                        $subject_coverage_percent = $hit_len_int > 0 ? round((abs($hit_to_int - $hit_from_int) + 1) / $hit_len_int * 100, 2) : 0;\n                        \n                        $hsp_data = [\n                            'identities' => $identities_int,\n                            'alignment_length' => $align_len_int,\n                            'evalue' => $evalue_float,\n                            'bit_score' => !empty($bit_score) ? (float)$bit_score[0] : 0,\n                            'score' => !empty($score) ? (int)$score[0] : 0,\n                            'percent_identity' => $align_len_int > 0 ? round(($identities_int / $align_len_int) * 100, 2) : 0,\n                            'query_from' => !empty($query_from) ? (int)$query_from[0] : 0,\n                            'query_to' => !empty($query_to) ? (int)$query_to[0] : 0,\n                            'hit_from' => $hit_from_int,\n                            'hit_to' => $hit_to_int,\n                            'query_seq' => $query_seq,\n                            'hit_seq' => $hit_seq,\n                            'midline' => $midline_str,\n                            'gaps' => $gaps,\n                            'gap_lengths' => $gap_lengths,\n                            'gap_lengths_str' => $gap_lengths_str,\n                            'total_gap_length' => $total_gap_length,\n                            'similarities' => $similarities,\n                            'subject_coverage_percent' => $subject_coverage_percent\n                        ];\n                        \n                        $hsps_array[] = $hsp_data;\n                    }\n                    \n                    // Calculate cumulative coverage for this hit across all HSPs\n                    // Track query coverage (not subject coverage)\n                    $query_coverage = [];\n                    foreach ($hsps_array as $hsp_data) {\n                        $query_coverage[] = [\n                            'from' => $hsp_data['query_from'],\n                            'to' => $hsp_data['query_to']\n                        ];\n                    }\n                    \n                    usort($query_coverage, function($a, $b) { return $a['from'] - $b['from']; });\n                    $merged = [];\n                    foreach ($query_coverage as $region) {\n                        if (empty($merged) || $merged[count($merged)-1]['to'] < $region['from']) {\n                            $merged[] = $region;\n                        } else {\n                            $merged[count($merged)-1]['to'] = max($merged[count($merged)-1]['to'], $region['to']);\n                        }\n                    }\n                    $total_covered = 0;\n                    foreach ($merged as $region) {\n                        $total_covered += $region['to'] - $region['from'] + 1;\n                    }\n                    $query_coverage_percent = $query_result['query_length'] > 0 ? round(($total_covered / $query_result['query_length']) * 100, 2) : 0;\n                    \n                    // Also calculate subject cumulative coverage for display\n                    $subject_cumulative_coverage = [];\n                    foreach ($query_result['hits'] as $hit_test) {\n                        if ($hit_test['subject'] === $hit_def_str) {\n                            foreach ($hit_test['hsps'] as $hsp_test) {\n                                $subject_cumulative_coverage[] = [\n                                    'from' => min($hsp_test['hit_from'], $hsp_test['hit_to']),\n                                    'to' => max($hsp_test['hit_from'], $hsp_test['hit_to'])\n                                ];\n                            }\n                        }\n                    }\n                    usort($subject_cumulative_coverage, function($a, $b) { return $a['from'] - $b['from']; });\n                    $merged_subject = [];\n                    foreach ($subject_cumulative_coverage as $region) {\n                        if (empty($merged_subject) || $merged_subject[count($merged_subject)-1]['to'] < $region['from']) {\n                            $merged_subject[] = $region;\n                        } else {\n                            $merged_subject[count($merged_subject)-1]['to'] = max($merged_subject[count($merged_subject)-1]['to'], $region['to']);\n                        }\n                    }\n                    $total_subject_covered = 0;\n                    foreach ($merged_subject as $region) {\n                        $total_subject_covered += $region['to'] - $region['from'] + 1;\n                    }\n                    $subject_cumulative_coverage_percent = $hit_len_int > 0 ? round(($total_subject_covered / $hit_len_int) * 100, 2) : 0;\n                    \n                    // Create hit entry with all its HSPs\n                    $hit = [\n                        'id' => $hit_id_str,\n                        'subject' => $hit_def_str,\n                        'length' => $hit_len_int,\n                        'hsps' => $hsps_array,\n                        'best_evalue' => $best_evalue,\n                        'num_hsps' => count($hsps_array),\n                        'query_coverage_percent' => $query_coverage_percent,\n                        'subject_cumulative_coverage_percent' => $subject_cumulative_coverage_percent\n                    ];\n                    \n                    $query_result['hits'][] = $hit;\n                }\n            }\n            \n            $query_result['total_hits'] = count($query_result['hits']);\n            $all_queries[] = $query_result;\n        }\n        \n    } catch (Exception $e) {\n        return ['error' => 'XML parsing error: ' . $e->getMessage(), 'queries' => []];\n    }\n    \n    return ['queries' => $all_queries, 'error' => ''];\n}",
                    "parameters": [
                        {
                            "name": "blast_xml",
                            "type": "string",
                            "description": "Raw BLAST XML output"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of parsed query results, each with hits array",
                    "internalCalls": [
                        "parseBlastResults"
                    ],
                    "category": "data-processing",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 737,
                            "context": "$parse_result = parseBlastResults($blast_result['output']);"
                        }
                    ]
                },
                {
                    "name": "generateHitsSummaryTable",
                    "line": 290,
                    "comment": "/**\n* Generate HTML for hits summary table\n*\n* @param array $results Parsed BLAST results\n* @param int $query_num Query number for linking to hit sections\n* @return string HTML table\n*/",
                    "code": "function generateHitsSummaryTable($results, $query_num = 1) {\n    $html = '<div class=\"blast-hits-summary mb-4\">';\n    $html .= '<h6><i class=\"fa fa-table\"></i> Hits Summary (' . $results['total_hits'] . ' hits found)</h6>';\n    $html .= '<div style=\"overflow-x: auto;\">';\n    $html .= '<table class=\"table table-sm table-striped blast-hits-table\">';\n    $html .= '<thead class=\"table-light\">';\n    $html .= '<tr>';\n    $html .= '<th style=\"width: 5%\">#</th>';\n    $html .= '<th style=\"width: 45%\">Subject</th>';\n    $html .= '<th style=\"width: 20%\">Query Coverage %</th>';\n    $html .= '<th style=\"width: 12%\">E-value</th>';\n    $html .= '<th style=\"width: 18%\">HSPs</th>';\n    $html .= '</tr>';\n    $html .= '</thead>';\n    $html .= '<tbody>';\n    \n    foreach ($results['hits'] as $idx => $hit) {\n        $hit_num = $idx + 1;\n        $evalue_display = sprintf('%.2e', $hit['best_evalue']);\n        $query_coverage = $hit['query_coverage_percent'];\n        $coverage_bar_width = min(100, $query_coverage);\n        \n        // Color based on coverage percentage\n        if ($query_coverage >= 80) {\n            $coverage_color = '#28a745'; // Green - excellent coverage\n        } elseif ($query_coverage >= 50) {\n            $coverage_color = '#ffc107'; // Yellow - good coverage\n        } elseif ($query_coverage >= 30) {\n            $coverage_color = '#fd7e14'; // Orange - moderate coverage\n        } else {\n            $coverage_color = '#dc3545'; // Red - low coverage\n        }\n        \n        $html .= '<tr style=\"cursor: pointer;\" onclick=\"const elem = document.getElementById(\\'query-' . $query_num . '-hit-' . $hit_num . '\\'); elem.scrollIntoView({behavior: \\'smooth\\', block: \\'start\\'}); highlightHitElement(elem);\">';\n        $html .= '<td><strong>' . $hit_num . '</strong></td>';\n        $html .= '<td><small>' . htmlspecialchars(substr($hit['subject'], 0, 60)) . '</small></td>';\n        $html .= '<td>';\n        $html .= '<div class=\"blast-coverage-bar\" style=\"width: 100%; background: #e9ecef; border-radius: 4px; overflow: hidden;\">';\n        $html .= '<div style=\"width: ' . $coverage_bar_width . '%; background: ' . $coverage_color . '; height: 20px; display: flex; align-items: center; justify-content: center;\">';\n        $html .= '<small style=\"font-weight: bold; color: white;\">' . $query_coverage . '%</small>';\n        $html .= '</div>';\n        $html .= '</div>';\n        $html .= '</td>';\n        $html .= '<td><small>' . $evalue_display . '</small></td>';\n        $html .= '<td>' . $hit['num_hsps'] . '</td>';\n        $html .= '</tr>';\n    }\n    \n    $html .= '</tbody>';\n    $html .= '</table>';\n    $html .= '</div>';\n    $html .= '</div>';\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "results",
                            "type": "array",
                            "description": "Parsed BLAST results"
                        },
                        {
                            "name": "query_num",
                            "type": "int",
                            "description": "Query number for linking to hit sections"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML table",
                    "internalCalls": [
                        "generateHitsSummaryTable"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 990,
                            "context": "$html .= generateHitsSummaryTable($query, $query_num);"
                        }
                    ]
                },
                {
                    "name": "generateBlastGraphicalView",
                    "line": 354,
                    "comment": "/**\n* Generate BLAST graphical results using SVG\n* Displays hits/HSPs as colored rectangles with score-based coloring\n* Similar to canvas graph but with better styling and E-value display\n*\n* @param array $results Parsed BLAST results\n* @return string SVG HTML\n*/",
                    "code": "function generateBlastGraphicalView($results) {\n    if ($results['query_length'] <= 0 || empty($results['hits'])) {\n        return '';\n    }\n    \n    $query_len = $results['query_length'];\n    $canvas_width = 1000;\n    $canvas_height_per_row = 25;\n    $total_rows = 0;\n    \n    // Count total rows (one row per HSP) - limit to top 2 HSPs per hit\n    foreach ($results['hits'] as $hit) {\n        $total_rows += min(2, count($hit['hsps']));\n    }\n    \n    $canvas_height = 120 + ($total_rows * $canvas_height_per_row) + 40;\n    $img_width = 850;\n    $xscale = $img_width / $query_len;\n    $top_margin = 100;\n    $left_margin = 200;\n    $right_margin = 100;\n    \n    // Determine tick distance based on query length\n    $tick_dist = 100;\n    if ($query_len > 2450) $tick_dist = 150;\n    if ($query_len > 3900) $tick_dist = 200;\n    if ($query_len > 5000) $tick_dist = 300;\n    if ($query_len > 7500) $tick_dist = round($query_len / 5);\n    \n    $html = '<div style=\"margin: 20px 0; overflow-x: auto; border: 1px solid #ddd; border-radius: 8px; background: white;\">';\n    $html .= '<svg width=\"' . ($canvas_width + $left_margin + $right_margin) . '\" height=\"' . $canvas_height . '\" style=\"font-family: Arial, sans-serif;\">';\n    \n    // Background\n    $html .= '<rect width=\"' . ($canvas_width + $left_margin + $right_margin) . '\" height=\"' . $canvas_height . '\" fill=\"#f9f9f9\"/>';\n    \n    // Title\n    $html .= '<text x=\"' . ($left_margin + ($img_width / 2)) . '\" y=\"30\" font-size=\"18\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#333\">Query Length (' . $query_len . ' bp)</text>';\n    \n    // Score legend\n    $legend_y = 50;\n    $legend_items = [\n        ['label' => '<40', 'color' => '#000000', 'range' => '<40'],\n        ['label' => '40-50', 'color' => '#0047c8', 'range' => '40-50'],\n        ['label' => '50-80', 'color' => '#77de75', 'range' => '50-80'],\n        ['label' => '80-200', 'color' => '#e967f5', 'range' => '80-200'],\n        ['label' => '\u2265200', 'color' => '#e83a2d', 'range' => '200+']\n    ];\n    \n    $legend_x = $left_margin;\n    $legend_width = $img_width / count($legend_items);\n    foreach ($legend_items as $item) {\n        $html .= '<rect x=\"' . $legend_x . '\" y=\"' . $legend_y . '\" width=\"' . $legend_width . '\" height=\"20\" fill=\"' . $item['color'] . '\"/>';\n        $html .= '<text x=\"' . ($legend_x + ($legend_width / 2)) . '\" y=\"' . ($legend_y + 15) . '\" font-size=\"11\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"white\">' . $item['label'] . '</text>';\n        $legend_x += $legend_width;\n    }\n    \n    // Horizontal line under legend\n    $html .= '<line x1=\"' . $left_margin . '\" y1=\"' . ($legend_y + 25) . '\" x2=\"' . ($left_margin + $img_width) . '\" y2=\"' . ($legend_y + 25) . '\" stroke=\"#333\" stroke-width=\"2\"/>';\n    \n    // Tick marks and labels\n    $vline_tag = $tick_dist;\n    for ($l = $tick_dist; $l + ($tick_dist / 2) < $query_len; $l += $tick_dist) {\n        $x = $left_margin + ($l * $xscale);\n        // Vertical line\n        $html .= '<line x1=\"' . $x . '\" y1=\"' . ($legend_y + 25) . '\" x2=\"' . $x . '\" y2=\"' . $canvas_height . '\" stroke=\"#ccc\" stroke-width=\"1\"/>';\n        // Tick label\n        $html .= '<text x=\"' . $x . '\" y=\"' . ($legend_y + 45) . '\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">' . $vline_tag . '</text>';\n        $vline_tag += $tick_dist;\n    }\n    \n    // E-value column header\n    $html .= '<text x=\"' . ($left_margin + $img_width + 15) . '\" y=\"' . ($legend_y + 45) . '\" font-size=\"12\" font-weight=\"bold\" fill=\"#333\">E-value</text>';\n    \n    // Draw hits/HSPs\n    $current_y = $top_margin;\n    $prev_subject = '';\n    \n    foreach ($results['hits'] as $hit_idx => $hit) {\n        $subject_name = substr($hit['subject'], 0, 40);\n        $is_new_subject = ($prev_subject !== $hit['subject']);\n        \n        if ($is_new_subject && $prev_subject !== '') {\n            $current_y += 5; // Add spacing between different subjects\n        }\n        \n        // Subject name (only once per hit)\n        if ($is_new_subject) {\n            $html .= '<text x=\"5\" y=\"' . ($current_y + 15) . '\" font-size=\"11\" font-weight=\"bold\" fill=\"#333\">' . htmlspecialchars($subject_name) . '</text>';\n        }\n        \n        // HSPs for this hit - limit to top 2\n        foreach ($hit['hsps'] as $hsp_idx => $hsp) {\n            if ($hsp_idx >= 2) break; // Only show top 2 HSPs\n            \n            $start_pos = $hsp['query_from'];\n            $end_pos = $hsp['query_to'];\n            $score = $hsp['bit_score'];\n            \n            // Determine color based on bit score\n            if ($score >= 200) {\n                $fill_color = 'rgba(255, 50, 40, 0.8)';\n            } elseif ($score >= 80) {\n                $fill_color = 'rgba(235,96,247, 0.8)';\n            } elseif ($score >= 50) {\n                $fill_color = 'rgba(119,222,117, 0.8)';\n            } elseif ($score >= 40) {\n                $fill_color = 'rgba(0,62,203, 0.8)';\n            } else {\n                $fill_color = 'rgba(10,10,10, 0.8)';\n            }\n            \n            $rect_x = $left_margin + ($start_pos * $xscale);\n            $rect_width = (($end_pos - $start_pos + 1) * $xscale);\n            \n            // Convert rgba to hex for SVG\n            if ($score >= 200) {\n                $fill_hex = '#ff3228';\n            } elseif ($score >= 80) {\n                $fill_hex = '#eb60f7';\n            } elseif ($score >= 50) {\n                $fill_hex = '#77de75';\n            } elseif ($score >= 40) {\n                $fill_hex = '#003ecb';\n            } else {\n                $fill_hex = '#0a0a0a';\n            }\n            \n            // HSP rectangle - clickable\n            $html .= '<g onclick=\"document.getElementById(\\'hit-' . ($hit_idx + 1) . '\\').scrollIntoView({behavior: \\'smooth\\', block: \\'start\\'})\" style=\"cursor: pointer;\">';\n            $html .= '<title>Hit ' . ($hit_idx + 1) . ' HSP ' . ($hsp_idx + 1) . ': ' . round($hsp['percent_identity'], 1) . '% identity | E-value: ' . sprintf('%.2e', $hsp['evalue']) . '</title>';\n            $html .= '<rect x=\"' . $rect_x . '\" y=\"' . ($current_y) . '\" width=\"' . $rect_width . '\" height=\"16\" fill=\"' . $fill_hex . '\" stroke=\"#333\" stroke-width=\"0.5\" rx=\"2\"/>';\n            $html .= '</g>';\n            \n            // E-value on the right\n            $evalue_display = sprintf('%.2e', $hsp['evalue']);\n            $html .= '<text x=\"' . ($left_margin + $img_width + 15) . '\" y=\"' . ($current_y + 12) . '\" font-size=\"10\" fill=\"#333\">' . $evalue_display . '</text>';\n            \n            $current_y += $canvas_height_per_row;\n        }\n        \n        $prev_subject = $hit['subject'];\n    }\n    \n    $html .= '</svg>';\n    $html .= '</div>';\n    \n    // Add legend explaining the colors\n    $html .= '<div style=\"margin: 15px 0; background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px; padding: 15px;\">';\n    $html .= '<strong style=\"display: block; margin-bottom: 10px;\"><i class=\"fa fa-info-circle\"></i> Legend - Bit Score Color Coding:</strong>';\n    $html .= '<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;\">';\n    \n    $legend_items = [\n        ['color' => '#0a0a0a', 'label' => '< 40', 'desc' => 'Weak alignment'],\n        ['color' => '#003ecb', 'label' => '40 - 50', 'desc' => 'Moderate alignment'],\n        ['color' => '#77de75', 'label' => '50 - 80', 'desc' => 'Good alignment'],\n        ['color' => '#eb60f7', 'label' => '80 - 200', 'desc' => 'Very good alignment'],\n        ['color' => '#ff3228', 'label' => '\u2265 200', 'desc' => 'Excellent alignment']\n    ];\n    \n    foreach ($legend_items as $item) {\n        $html .= '<div style=\"display: flex; align-items: center;\">';\n        $html .= '<div style=\"width: 24px; height: 24px; background: ' . $item['color'] . '; border-radius: 3px; margin-right: 10px;\"></div>';\n        $html .= '<div>';\n        $html .= '<strong>' . $item['label'] . '</strong><br>';\n        $html .= '<small style=\"color: #666;\">' . $item['desc'] . '</small>';\n        $html .= '</div>';\n        $html .= '</div>';\n    }\n    \n    $html .= '</div>';\n    $html .= '</div>';\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "results",
                            "type": "array",
                            "description": "Parsed BLAST results"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "SVG HTML",
                    "internalCalls": [
                        "generateBlastGraphicalView"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "generateAlignmentViewer",
                    "line": 535,
                    "comment": "/**\n* Generate alignment viewer section\n* Displays alignments organized by Hit, with multiple HSPs per Hit\n*\n* @param array $results Parsed BLAST results from parseBlastResults()\n* @return string HTML with alignment viewer\n*/",
                    "code": "function generateAlignmentViewer($results, $blast_program = 'blastn', $query_num = 1) {\n    $html = '<div class=\"blast-alignment-viewer mt-4\">';\n    $html .= '<h6><i class=\"fa fa-align-justify\"></i> Detailed Alignments (HSPs)</h6>';\n    $html .= '<small class=\"text-muted d-block mb-3\">Each Hit section contains one or more High-Scoring Segment Pairs (HSPs)</small>';\n    \n    if (empty($results['hits'])) {\n        $html .= '<div class=\"alert alert-info\"><small>No alignments to display</small></div>';\n        return $html . '</div>';\n    }\n    \n    // Determine correct unit based on program\n    $unit = 'bp';\n    if (strpos($blast_program, 'blastp') !== false || strpos($blast_program, 'tblastn') !== false) {\n        $unit = 'aa';\n    }\n    \n    $html .= '<div style=\"background: #f8f9fa; border-radius: 4px; overflow-x: auto;\">';\n    \n    foreach ($results['hits'] as $hit_idx => $hit) {\n        $hit_num = $hit_idx + 1;\n        $evalue_display = sprintf('%.2e', $hit['best_evalue']);\n        \n        // Hit header card\n        $html .= '<div id=\"query-' . $query_num . '-hit-' . $hit_num . '\" style=\"padding: 15px;  scroll-margin-top: 20px; background: #f0f7ff; margin-bottom: 15px;\">';\n        $html .= '<h5 style=\"margin-bottom: 10px; color: #007bff;\">';\n        $html .= '<strong>Hit ' . $hit_num . ': ' . htmlspecialchars($hit['subject']) . '</strong>';\n        $html .= '</h5>';\n        $html .= '<small class=\"d-block\" style=\"margin-bottom: 10px;\">';\n        $html .= '<strong>Hit ID:</strong> ' . htmlspecialchars($hit['id']) . ' | ';\n        $html .= '<strong>Length:</strong> ' . $hit['length'] . ' ' . $unit . ' | ';\n        $html .= '<strong>Best E-value:</strong> ' . $evalue_display . ' | ';\n        $html .= '<strong>Number of HSPs:</strong> ' . $hit['num_hsps'] . ' | ';\n        $html .= '<strong>Query Coverage:</strong> ' . $hit['query_coverage_percent'] . '% | ';\n        $html .= '<strong>Subject Coverage:</strong> ' . $hit['subject_cumulative_coverage_percent'] . '%';\n        $html .= '</small>';\n        $html .= '</div>';\n        \n        // HSPs for this hit\n        foreach ($hit['hsps'] as $hsp_idx => $hsp) {\n            $hsp_num = $hsp_idx + 1;\n            \n            $html .= '<div style=\"padding: 15px; border-bottom: 1px solid #dee2e6; margin-left: 15px; background: #ffffff; margin-bottom: 10px; border-left: 4px solid #28a745;\">';\n            $html .= '<h6 style=\"margin-bottom: 10px;\"><strong>HSP ' . $hsp_num . '</strong></h6>';\n            $html .= '<small class=\"text-muted d-block\" style=\"margin-bottom: 10px;\">';\n            $html .= 'E-value: ' . sprintf('%.2e', $hsp['evalue']) . ' | ';\n            $html .= 'Alignment length: ' . $hsp['alignment_length'] . ' | ';\n            $html .= 'Identity: ' . $hsp['identities'] . '/' . $hsp['alignment_length'] . ' (' . $hsp['percent_identity'] . '%) | ';\n            $html .= 'Similarities: ' . $hsp['similarities'] . ' | ';\n            $html .= 'Gaps: ' . $hsp['gaps'];\n            if ($hsp['gaps'] > 0) {\n                $html .= ' (lengths: ' . $hsp['gap_lengths_str'] . ', total: ' . $hsp['total_gap_length'] . ')';\n            }\n            $html .= '</small>';\n            \n            // Query coverage information for this HSP\n            $query_hsp_coverage = $results['query_length'] > 0 ? round((($hsp['query_to'] - $hsp['query_from'] + 1) / $results['query_length']) * 100, 2) : 0;\n            $html .= '<small class=\"d-block\" style=\"margin-bottom: 10px; background: #e7f3ff; padding: 8px; border-radius: 3px; border-left: 3px solid #007bff;\">';\n            $html .= '<strong>Query Coverage (This HSP):</strong> ';\n            $html .= $query_hsp_coverage . '% (' . ($hsp['query_to'] - $hsp['query_from'] + 1) . '/' . $results['query_length'] . ') | ';\n            $html .= '<strong>Subject Coverage (This HSP):</strong> ';\n            $html .= $hsp['subject_coverage_percent'] . '% (' . abs($hsp['hit_to'] - $hsp['hit_from']) + 1 . '/' . $results['hits'][$hit_idx]['length'] . ')';\n            $html .= '</small>';\n            \n            // Display alignment in monospace with frame-aware formatting\n            $html .= '<pre style=\"background: white; border: 1px solid #dee2e6; padding: 10px; border-radius: 3px; overflow-x: auto; font-size: 11px; margin: 0; font-family: \\'Courier New\\', monospace;\">';\n            \n            // Use frame-aware alignment formatter if frames are available\n            if (isset($hsp['query_frame']) || isset($hsp['hit_frame'])) {\n                $query_frame = isset($hsp['query_frame']) ? (int)$hsp['query_frame'] : 0;\n                $hit_frame = isset($hsp['hit_frame']) ? (int)$hsp['hit_frame'] : 0;\n                $alignment_text = formatBlastAlignment(\n                    $hsp['alignment_length'],\n                    $hsp['query_seq'],\n                    $hsp['query_from'],\n                    $hsp['query_to'],\n                    $hsp['midline'],\n                    $hsp['hit_seq'],\n                    $hsp['hit_from'],\n                    $hsp['hit_to'],\n                    'Plus',\n                    $query_frame,\n                    $hit_frame\n                );\n                $html .= htmlspecialchars($alignment_text);\n            } else {\n                // Fallback to simple formatting\n                $label_width = 15;\n                $query_label = str_pad('Query  ' . $hsp['query_from'], $label_width);\n                $midline_label = str_pad('', $label_width);\n                $sbjct_label = str_pad('Sbjct  ' . $hsp['hit_from'], $label_width);\n                \n                $html .= $query_label . htmlspecialchars($hsp['query_seq']) . ' ' . $hsp['query_to'] . \"\\n\";\n                $html .= $midline_label . htmlspecialchars($hsp['midline']) . \"\\n\";\n                $html .= $sbjct_label . htmlspecialchars($hsp['hit_seq']) . ' ' . $hsp['hit_to'] . \"\\n\";\n            }\n            \n            $html .= '</pre>';\n            \n            $html .= '</div>';\n        }\n    }\n    \n    $html .= '</div>';\n    $html .= '</div>';\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "results",
                            "type": "array",
                            "description": "Parsed BLAST results from parseBlastResults()"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML with alignment viewer",
                    "internalCalls": [
                        "generateAlignmentViewer",
                        "formatBlastAlignment"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 993,
                            "context": "$html .= generateAlignmentViewer($query, $blast_program, $query_num);"
                        }
                    ]
                },
                {
                    "name": "generateBlastStatisticsSummary",
                    "line": 652,
                    "comment": "/**\n* Generate BLAST results statistics summary\n* Pretty card showing overall results statistics\n*\n* @param array $results Parsed BLAST results\n* @param string $query_seq Query sequence\n* @param string $blast_program BLAST program name\n* @return string HTML statistics card\n*/",
                    "code": "function generateBlastStatisticsSummary($results, $query_seq, $blast_program) {\n    if ($results['total_hits'] === 0) {\n        return '';\n    }\n    \n    $html = '<div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; padding: 25px; margin-bottom: 25px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);\">';\n    \n    // Title\n    $html .= '<h4 style=\"margin: 0 0 20px 0; font-weight: bold;\"><i class=\"fa fa-chart-bar\"></i> BLAST Search Statistics</h4>';\n    \n    // Statistics grid\n    $html .= '<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;\">';\n    \n    // Query info\n    $html .= '<div style=\"background: rgba(255,255,255,0.15); padding: 15px; border-radius: 6px; border-left: 4px solid #4fc3f7;\">';\n    $html .= '<div style=\"font-size: 12px; opacity: 0.9; margin-bottom: 5px;\">Query</div>';\n    $html .= '<div style=\"font-size: 24px; font-weight: bold;\">' . strlen($query_seq) . ' bp</div>';\n    if (!empty($results['query_name'])) {\n        $html .= '<div style=\"font-size: 11px; opacity: 0.8; margin-top: 5px;\">' . htmlspecialchars(substr($results['query_name'], 0, 30)) . '</div>';\n    }\n    $html .= '</div>';\n    \n    // Hits found\n    $html .= '<div style=\"background: rgba(255,255,255,0.15); padding: 15px; border-radius: 6px; border-left: 4px solid #81c784;\">';\n    $html .= '<div style=\"font-size: 12px; opacity: 0.9; margin-bottom: 5px;\">Hits Found</div>';\n    $html .= '<div style=\"font-size: 24px; font-weight: bold;\">' . $results['total_hits'] . '</div>';\n    $html .= '<div style=\"font-size: 11px; opacity: 0.8; margin-top: 5px;\">Subject sequences</div>';\n    $html .= '</div>';\n    \n    // Best hit info\n    $best_hit = $results['hits'][0];\n    $best_hsp = $best_hit['hsps'][0];\n    $html .= '<div style=\"background: rgba(255,255,255,0.15); padding: 15px; border-radius: 6px; border-left: 4px solid #ffa726;\">';\n    $html .= '<div style=\"font-size: 12px; opacity: 0.9; margin-bottom: 5px;\">Best E-value</div>';\n    $evalue_display = sprintf('%.2e', $best_hit['best_evalue']);\n    $html .= '<div style=\"font-size: 24px; font-weight: bold;\">' . $evalue_display . '</div>';\n    $html .= '<div style=\"font-size: 11px; opacity: 0.8; margin-top: 5px;\">Top hit</div>';\n    $html .= '</div>';\n    \n    // Best identity\n    $html .= '<div style=\"background: rgba(255,255,255,0.15); padding: 15px; border-radius: 6px; border-left: 4px solid #ef5350;\">';\n    $html .= '<div style=\"font-size: 12px; opacity: 0.9; margin-bottom: 5px;\">Best Identity</div>';\n    $html .= '<div style=\"font-size: 24px; font-weight: bold;\">' . $best_hsp['percent_identity'] . '%</div>';\n    $html .= '<div style=\"font-size: 11px; opacity: 0.8; margin-top: 5px;\">' . $best_hsp['identities'] . '/' . $best_hsp['alignment_length'] . ' bp/aa</div>';\n    $html .= '</div>';\n    \n    // Total HSPs\n    $total_hsps = 0;\n    foreach ($results['hits'] as $hit) {\n        $total_hsps += $hit['num_hsps'];\n    }\n    $html .= '<div style=\"background: rgba(255,255,255,0.15); padding: 15px; border-radius: 6px; border-left: 4px solid #ab47bc;\">';\n    $html .= '<div style=\"font-size: 12px; opacity: 0.9; margin-bottom: 5px;\">Total HSPs</div>';\n    $html .= '<div style=\"font-size: 24px; font-weight: bold;\">' . $total_hsps . '</div>';\n    $html .= '<div style=\"font-size: 11px; opacity: 0.8; margin-top: 5px;\">Alignments</div>';\n    $html .= '</div>';\n    \n    // Program\n    $html .= '<div style=\"background: rgba(255,255,255,0.15); padding: 15px; border-radius: 6px; border-left: 4px solid #29b6f6;\">';\n    $html .= '<div style=\"font-size: 12px; opacity: 0.9; margin-bottom: 5px;\">Program</div>';\n    $html .= '<div style=\"font-size: 18px; font-weight: bold;\">' . strtoupper(htmlspecialchars($blast_program)) . '</div>';\n    $html .= '<div style=\"font-size: 11px; opacity: 0.8; margin-top: 5px;\">Sequence search</div>';\n    $html .= '</div>';\n    \n    $html .= '</div>'; // End grid\n    \n    $html .= '</div>'; // End container\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "results",
                            "type": "array",
                            "description": "Parsed BLAST results"
                        },
                        {
                            "name": "query_seq",
                            "type": "string",
                            "description": "Query sequence"
                        },
                        {
                            "name": "blast_program",
                            "type": "string",
                            "description": "BLAST program name"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML statistics card",
                    "internalCalls": [
                        "generateBlastStatisticsSummary"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "generateCompleteBlastVisualization",
                    "line": 732,
                    "comment": "/**\n* Generate complete BLAST results visualization\n* Combines all visualization components\n*\n* @param array $blast_result Result from executeBlastSearch()\n* @param string $query_seq The query sequence\n* @param string $blast_program The BLAST program used\n* @return string Complete HTML visualization\n*/",
                    "code": "function generateCompleteBlastVisualization($blast_result, $query_seq, $blast_program, $blast_options = []) {\n    if (!$blast_result['success']) {\n        return '<div class=\"alert alert-danger\"><i class=\"fa fa-exclamation-circle\"></i> No results to visualize</div>';\n    }\n    \n    $parse_result = parseBlastResults($blast_result['output']);\n    \n    // Check for parsing errors\n    if (!empty($parse_result['error'])) {\n        return '<div class=\"alert alert-danger\"><i class=\"fa fa-exclamation-circle\"></i> Error parsing results: ' . htmlspecialchars($parse_result['error']) . '</div>';\n    }\n    \n    $queries = $parse_result['queries'] ?? [];\n    if (empty($queries)) {\n        return '<div class=\"alert alert-info\"><i class=\"fa fa-info-circle\"></i> No queries found in results</div>';\n    }\n    \n    $html = '<div class=\"blast-visualization\">';\n    \n    // Determine correct unit based on program\n    $unit = 'bp';\n    if (strpos($blast_program, 'blastp') !== false || strpos($blast_program, 'tblastn') !== false) {\n        $unit = 'aa';\n    }\n    \n    // Search Parameters Section (moved up, collapsible)\n    $html .= '<div style=\"background: white; border: 1px solid #dee2e6; border-radius: 8px; margin-bottom: 20px;\">';\n    $html .= '<div style=\"padding: 15px; cursor: pointer; background: #f8f9fa; border-bottom: 1px solid #dee2e6; display: flex; justify-content: space-between; align-items: center;\" onclick=\"document.getElementById(\\'search-params\\').style.display = document.getElementById(\\'search-params\\').style.display === \\'none\\' ? \\'block\\' : \\'none\\'; this.querySelector(\\'i\\').style.transform = document.getElementById(\\'search-params\\').style.display === \\'none\\' ? \\'rotate(0deg)\\' : \\'rotate(180deg)\\';\">';\n    $html .= '<h6 style=\"margin: 0; color: #333;\"><i class=\"fa fa-cog\"></i> Search Parameters</h6>';\n    $html .= '<i class=\"fa fa-chevron-down\" style=\"transition: transform 0.2s; transform: rotate(0deg);\"></i>';\n    $html .= '</div>';\n    \n    $html .= '<div id=\"search-params\" style=\"display: none; padding: 15px;\">';\n    \n    // Original search parameters - first grid\n    $html .= '<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 15px;\">';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Database</small><br>';\n    $html .= '<small>protein.aa.fa</small>';\n    $html .= '</div>';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Posted Date</small><br>';\n    $html .= '<small>Nov 12, 2025 10:40 PM</small>';\n    $html .= '</div>';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Database Size</small><br>';\n    $html .= '<small>21,106,416 letters | 54,384 sequences</small>';\n    $html .= '</div>';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Program</small><br>';\n    $html .= '<small>' . strtoupper(htmlspecialchars($blast_program)) . '</small>';\n    $html .= '</div>';\n    \n    $html .= '</div>';\n    \n    // Original search parameters - second grid\n    $html .= '<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px;\">';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Matrix</small><br>';\n    $html .= '<small>BLOSUM62</small>';\n    $html .= '</div>';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Gap Penalties</small><br>';\n    $html .= '<small>Existence: 11, Extension: 1</small>';\n    $html .= '</div>';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Window for Multiple Hits</small><br>';\n    $html .= '<small>40</small>';\n    $html .= '</div>';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Threshold</small><br>';\n    $html .= '<small>11</small>';\n    $html .= '</div>';\n    \n    $html .= '</div>';\n    \n    // New search parameters from form - third grid\n    $html .= '<hr style=\"margin: 15px 0;\">';\n    $html .= '<h6 style=\"color: #333; margin-bottom: 15px;\"><i class=\"fa fa-sliders-h\"></i> Form Parameters</h6>';\n    $html .= '<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;\">';\n    \n    // Basic parameters\n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">E-value Threshold</small><br>';\n    $html .= '<small>' . htmlspecialchars($blast_options['evalue'] ?? '1e-3') . '</small>';\n    $html .= '</div>';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Maximum Hits</small><br>';\n    $html .= '<small>' . ($blast_options['max_hits'] ?? 10) . '</small>';\n    $html .= '</div>';\n    \n    $html .= '<div>';\n    $html .= '<small style=\"color: #666; font-weight: bold;\">Scoring Matrix</small><br>';\n    $html .= '<small>' . htmlspecialchars($blast_options['matrix'] ?? 'BLOSUM62') . '</small>';\n    $html .= '</div>';\n    \n    // Advanced parameters\n    if (!empty($blast_options['word_size'])) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Word Size</small><br>';\n        $html .= '<small>' . htmlspecialchars($blast_options['word_size']) . '</small>';\n        $html .= '</div>';\n    }\n    \n    if (!empty($blast_options['gapopen'])) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Gap Open Penalty</small><br>';\n        $html .= '<small>' . htmlspecialchars($blast_options['gapopen']) . '</small>';\n        $html .= '</div>';\n    }\n    \n    if (!empty($blast_options['gapextend'])) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Gap Extend Penalty</small><br>';\n        $html .= '<small>' . htmlspecialchars($blast_options['gapextend']) . '</small>';\n        $html .= '</div>';\n    }\n    \n    if (!empty($blast_options['max_hsps'])) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Max HSPs</small><br>';\n        $html .= '<small>' . htmlspecialchars($blast_options['max_hsps']) . '</small>';\n        $html .= '</div>';\n    }\n    \n    if (!empty($blast_options['perc_identity'])) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Percent Identity</small><br>';\n        $html .= '<small>' . htmlspecialchars($blast_options['perc_identity']) . '%</small>';\n        $html .= '</div>';\n    }\n    \n    if (!empty($blast_options['culling_limit'])) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Culling Limit</small><br>';\n        $html .= '<small>' . htmlspecialchars($blast_options['culling_limit']) . '</small>';\n        $html .= '</div>';\n    }\n    \n    if (!empty($blast_options['threshold'])) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Threshold</small><br>';\n        $html .= '<small>' . htmlspecialchars($blast_options['threshold']) . '</small>';\n        $html .= '</div>';\n    }\n    \n    if (!empty($blast_options['strand'])) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Strand</small><br>';\n        $html .= '<small>' . htmlspecialchars($blast_options['strand']) . '</small>';\n        $html .= '</div>';\n    }\n    \n    if ($blast_options['soft_masking'] ?? false) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Soft Masking</small><br>';\n        $html .= '<small><i class=\"fa fa-check\" style=\"color: green;\"></i> Enabled</small>';\n        $html .= '</div>';\n    }\n    \n    if ($blast_options['filter'] ?? false) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Filter Low Complexity</small><br>';\n        $html .= '<small><i class=\"fa fa-check\" style=\"color: green;\"></i> Enabled</small>';\n        $html .= '</div>';\n    }\n    \n    if ($blast_options['ungapped'] ?? false) {\n        $html .= '<div>';\n        $html .= '<small style=\"color: #666; font-weight: bold;\">Ungapped</small><br>';\n        $html .= '<small><i class=\"fa fa-check\" style=\"color: green;\"></i> Enabled</small>';\n        $html .= '</div>';\n    }\n    \n    $html .= '</div>';\n    $html .= '</div>';\n    $html .= '</div>';\n    \n    // Query Summary Table - all queries with links to their sections\n    $html .= '<div style=\"background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin-bottom: 20px;\">';\n    $html .= '<h6 style=\"margin-bottom: 15px;\"><i class=\"fa fa-list\"></i> Query Summary</h6>';\n    $html .= '<div style=\"overflow-x: auto;\">';\n    $html .= '<table class=\"table table-sm table-striped\">';\n    $html .= '<thead class=\"table-light\">';\n    $html .= '<tr>';\n    $html .= '<th style=\"width: 5%\">#</th>';\n    $html .= '<th style=\"width: 35%\">Query Name</th>';\n    $html .= '<th style=\"width: 15%\">Length</th>';\n    $html .= '<th style=\"width: 15%\">Hits</th>';\n    $html .= '<th style=\"width: 30%\">Best E-value</th>';\n    $html .= '</tr>';\n    $html .= '</thead>';\n    $html .= '<tbody>';\n    \n    foreach ($queries as $query_idx => $query) {\n        $query_num = $query_idx + 1;\n        $query_name = !empty($query['query_desc']) ? htmlspecialchars($query['query_desc']) : 'Query ' . $query_num;\n        $best_evalue = $query['total_hits'] > 0 ? $query['hits'][0]['best_evalue'] : PHP_FLOAT_MAX;\n        $best_evalue_display = $best_evalue < PHP_FLOAT_MAX ? sprintf('%.2e', $best_evalue) : 'N/A';\n        \n        $html .= '<tr style=\"cursor: pointer;\" onclick=\"document.getElementById(\\'query-' . $query_num . '\\').scrollIntoView({behavior: \\'smooth\\', block: \\'start\\'});\">';\n        $html .= '<td><strong>' . $query_num . '</strong></td>';\n        $html .= '<td><small>' . $query_name . '</small></td>';\n        $html .= '<td>' . $query['query_length'] . ' ' . $unit . '</td>';\n        $html .= '<td>' . $query['total_hits'] . '</td>';\n        $html .= '<td><small>' . $best_evalue_display . '</small></td>';\n        $html .= '</tr>';\n    }\n    \n    $html .= '</tbody>';\n    $html .= '</table>';\n    $html .= '</div>';\n    $html .= '</div>';\n    \n    // Individual Query Sections - each query with all its results\n    foreach ($queries as $query_idx => $query) {\n        $query_num = $query_idx + 1;\n        $query_name = !empty($query['query_desc']) ? htmlspecialchars($query['query_desc']) : 'Query ' . $query_num;\n        \n        // Collapsible query section\n        $html .= '<div id=\"query-' . $query_num . '\" style=\"background: white; border: 1px solid #dee2e6; border-radius: 8px; margin-bottom: 20px; scroll-margin-top: 20px;\">';\n        \n        // Query header (collapsible)\n        $html .= '<div id=\"query-' . $query_num . '-header\" style=\"padding: 15px; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center;\" onclick=\"toggleQuerySection(\\'query-' . $query_num . '-content\\', this);\">';\n        $html .= '<h5 style=\"margin: 0;\"><i class=\"fa fa-dna\"></i> Query ' . $query_num . ': ' . $query_name . '</h5>';\n        $html .= '<i class=\"fa fa-chevron-down\" style=\"transition: transform 0.2s; transform: rotate(0deg);\"></i>';\n        $html .= '</div>';\n        \n        // Query content (collapsible)\n        $html .= '<div id=\"query-' . $query_num . '-content\" style=\"padding: 15px;\">';\n        \n        // Query info\n        $html .= '<div style=\"background: #f8f9fa; border-left: 4px solid #667eea; padding: 12px; margin-bottom: 15px; border-radius: 4px;\">';\n        $html .= '<small>';\n        if (!empty($query['query_desc'])) {\n            $html .= '<strong>Description:</strong> ' . htmlspecialchars($query['query_desc']) . '<br>';\n        }\n        $html .= '<strong>Length:</strong> ' . $query['query_length'] . ' ' . $unit . ' | ';\n        $html .= '<strong>Total Hits:</strong> ' . $query['total_hits'];\n        $html .= '</small>';\n        $html .= '</div>';\n        \n        if ($query['total_hits'] === 0) {\n            $html .= '<div class=\"alert alert-info\"><small>No significant matches found for this query</small></div>';\n        } else {\n            // HSP visualization for this query\n            $html .= generateHspVisualizationWithLines($query, $blast_program, $query_num);\n            \n            // Hits summary table for this query\n            $html .= generateHitsSummaryTable($query, $query_num);\n            \n            // Alignment viewer for this query\n            $html .= generateAlignmentViewer($query, $blast_program, $query_num);\n        }\n        \n        $html .= '</div>'; // End query content\n        $html .= '</div>'; // End query section\n    }\n    \n    $html .= '</div>';\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "blast_result",
                            "type": "array",
                            "description": "Result from executeBlastSearch()"
                        },
                        {
                            "name": "query_seq",
                            "type": "string",
                            "description": "The query sequence"
                        },
                        {
                            "name": "blast_program",
                            "type": "string",
                            "description": "The BLAST program used"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Complete HTML visualization",
                    "internalCalls": [
                        "generateCompleteBlastVisualization",
                        "parseBlastResults",
                        "toggleQuerySection",
                        "generateHspVisualizationWithLines",
                        "generateHitsSummaryTable",
                        "generateAlignmentViewer"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/blast.php",
                            "line": 292,
                            "context": "<?= generateCompleteBlastVisualization($blast_result, $search_query, $blast_program, $blast_options ?? []) ?>"
                        }
                    ]
                },
                {
                    "name": "generateHspVisualizationWithLines",
                    "line": 987,
                    "comment": "/**\n* Generate HSP visualization with connecting lines\n* Displays HSPs as colored segments with lines connecting adjacent HSPs\n* Original MOOP implementation using HTML/CSS flexbox and inline JavaScript\n* (not Canvas or SVG as used in other implementations)\n*\n* @param array $results Parsed BLAST results\n* @param string $blast_program BLAST program name (blastn, blastp, etc.)\n* @return string HTML with HSP visualization\n*/",
                    "code": "function generateHspVisualizationWithLines($results, $blast_program = 'blastn', $query_num = 1) {\n    if (empty($results['hits']) || $results['query_length'] <= 0) {\n        return '';\n    }\n    \n    // Determine unit based on program\n    $unit = 'bp';\n    if (strpos($blast_program, 'blastp') !== false || strpos($blast_program, 'tblastn') !== false) {\n        $unit = 'aa';\n    }\n    \n    $html = '<div class=\"blast-hsp-visualization\" style=\"margin: 20px 0; background: white; border: 1px solid #ddd; border-radius: 8px; padding: 20px;\">';\n    $html .= '<h6 style=\"text-align: center;\"><i class=\"fa fa-ruler-horizontal\"></i> Query Length (' . $results['query_length'] . ' ' . $unit . ')</h6>';\n    \n    // Add CSS for HSP visualization\n    $html .= '<style>';\n    $html .= '.hsp-row { display: flex; align-items: center; margin-bottom: 12px; }';\n    $html .= '.hsp-label { min-width: 100px; padding-right: 15px; font-size: 11px; font-weight: bold; word-break: break-all; }';\n    $html .= '.hsp-segments { display: flex; align-items: center; width: 800px; position: relative; z-index: 5; }';\n    $html .= '.hsp-segment { height: 16px; display: inline-block; margin-right: 0; cursor: pointer; border: 1px solid #333; transition: opacity 0.2s; }';\n    $html .= '.hsp-segment:hover { opacity: 0.8; }';\n    $html .= '.hsp-gap { height: 4px; background: #e0e0e0; display: inline-block; margin-top: 6px; }';\n    $html .= '.hsp-connector { width: 1px; height: 6px; background: #000; display: inline-block; margin: 5px 0; }';\n    $html .= '.color-black { background-color: #000000; }';\n    $html .= '.color-blue { background-color: #0047c8; }';\n    $html .= '.color-green { background-color: #77de75; }';\n    $html .= '.color-purple { background-color: #e967f5; }';\n    $html .= '.color-red { background-color: #e83a2d; }';\n    $html .= '.hit-highlighted { background-color: #ffffcc !important; transition: background-color 0.3s ease-out; }';\n    $html .= '.hsp-row:hover { background-color: rgba(100, 150, 255, 0.1); }';\n    $html .= '</style>';\n    \n     // Add JavaScript for hit navigation and highlighting\n     $html .= '<script>';\n     $html .= 'function jumpToHit(hitIndex, queryNum) {';\n     $html .= '  if (queryNum === undefined) queryNum = 1;';\n     $html .= '  const hitId = \"query-\" + queryNum + \"-hit-\" + (hitIndex + 1);';\n     $html .= '  const element = document.getElementById(hitId);';\n     $html .= '  if (element) {';\n     $html .= '    element.scrollIntoView({ behavior: \"smooth\", block: \"start\" });';\n     $html .= '    highlightHitElement(element);';\n     $html .= '  }';\n     $html .= '}';\n     $html .= 'function highlightHitElement(element) {';\n     $html .= '  if (!element) return;';\n     $html .= '  element.classList.remove(\"hit-highlighted\");';\n     $html .= '  void element.offsetWidth;';\n     $html .= '  element.classList.add(\"hit-highlighted\");';\n     $html .= '  setTimeout(() => {';\n     $html .= '    element.classList.remove(\"hit-highlighted\");';\n     $html .= '  }, 3500);';\n     $html .= '}';\n     $html .= 'function highlightHit(hitIndex, queryNum) {';\n     $html .= '  if (queryNum === undefined) queryNum = 1;';\n     $html .= '  jumpToHit(hitIndex, queryNum);';\n     $html .= '}';\n     $html .= '</script>';\n    \n    $html .= '<div style=\"margin-top: 15px; margin: 0 auto; width: 1000px; text-align: center;\">';\n\n    // Generate just the score legend (outside overflow:hidden)\n    $html .= generateQueryScoreLegend($results['query_length'], $results['query_name']);\n\n    // Pixel unit calculation based on query length (800px width)\n    $px_unit = 800 / $results['query_length'];\n\n    // Calculate total HSP rows\n    $total_hsp_rows = 0;\n    foreach ($results['hits'] as $hit) {\n        $total_hsp_rows += count($hit['hsps']) + 1; // +1 for spacing between hits\n    }\n    \n    // Calculate height needed for HSP rows (each row ~25px + spacing)\n    $hsp_content_height = ($total_hsp_rows * 25) + 50;\n    // Set max height before scrolling (e.g., 400px)\n    $max_hsp_height = 400;\n    $use_scroll = $hsp_content_height > $max_hsp_height;\n    \n    // Total container height: ticks (80px) + HSP area (either content height or max height)\n    $hsp_display_height = min($hsp_content_height, $max_hsp_height);\n    $total_container_height = 80 + $hsp_display_height;\n\n    // Create a container for scale ticks and HSPs with relative positioning\n    // This must be tall enough for all tick lines to extend down\n    $html .= '<div style=\"position: relative; overflow: hidden; height: ' . $total_container_height . 'px;\">';\n    \n    // Generate the query scale ruler with ticks (inside overflow:hidden to be clipped properly)\n    $html .= generateQueryScaleTicks($results['query_length']);\n    \n    // Create a scrollable wrapper for HSP rows positioned below the ticks\n    $scroll_style = $use_scroll ? 'overflow-y: scroll;' : 'overflow: hidden;';\n    $html .= '<div style=\"position: absolute; top: 80px; left: 0; right: 0; height: ' . $hsp_display_height . 'px; ' . $scroll_style . '\">';\n    \n    // Wrapper for HSP rows\n    $html .= '<div style=\"padding-top: 0;\">';\n    \n    foreach ($results['hits'] as $hit_idx => $hit) {\n        $hit_num = $hit_idx + 1;\n        \n        // Organize HSPs by their query coordinates\n        $hsp_positions = [];\n        $hsp_scores = [];\n        $hsp_details = [];\n        \n        foreach ($hit['hsps'] as $hsp_idx => $hsp) {\n            $q_start = min($hsp['query_from'], $hsp['query_to']);\n            $q_end = max($hsp['query_from'], $hsp['query_to']);\n            \n            $hsp_positions[] = [\n                'start' => $q_start,\n                'end' => $q_end,\n                'index' => $hsp_idx\n            ];\n            \n            $hsp_scores[$hsp_idx] = $hsp['bit_score'];\n            $hsp_details[$hsp_idx] = $hsp;\n        }\n        \n        // Sort by start position\n        usort($hsp_positions, function($a, $b) {\n            return $a['start'] - $b['start'];\n        });\n        \n        // Build HTML row\n        $html .= '<div class=\"hsp-row\" style=\"cursor: pointer;\" onclick=\"jumpToHit(' . $hit_idx . ', ' . $query_num . '); highlightHit(' . $hit_idx . ', ' . $query_num . ');\">';\n        $html .= '<div class=\"hsp-label\"></div>';\n        $html .= '<div class=\"hsp-segments\">';\n        \n        // First HSP\n        if (!empty($hsp_positions)) {\n            $first_hsp = $hsp_positions[0];\n            $first_idx = $first_hsp['index'];\n            $color = getHspColorClass($hsp_scores[$first_idx]);\n            $segment_width = ($first_hsp['end'] - $first_hsp['start']) * $px_unit;\n            \n            // Add leading gap if needed\n            if ($first_hsp['start'] > 1) {\n                $gap_width = ($first_hsp['start'] - 1) * $px_unit;\n                $html .= '<div class=\"hsp-gap\" style=\"width: ' . $gap_width . 'px;\"></div>';\n            }\n            \n            $hsp = $hsp_details[$first_idx];\n            // Extract just the subject name (first word/identifier before space or bracket)\n            $hit_name = 'Hit ' . $hit_num;\n            if (!empty($hit['subject'])) {\n                $desc = htmlspecialchars($hit['subject']);\n                // Extract first word or identifier (up to first space, bracket, or pipe)\n                preg_match('/^([^\\s\\[\\|\\-]+)/', $desc, $matches);\n                if (!empty($matches[1])) {\n                    $hit_name = $matches[1];\n                }\n            }\n            $title = $hit_name . ' - HSP ' . ($first_idx + 1) . ': ' . $hsp['percent_identity'] . '% identity | E-value: ' . sprintf('%.2e', $hsp['evalue']);\n            $html .= '<div class=\"hsp-segment ' . $color . '\" style=\"width: ' . $segment_width . 'px;\" title=\"' . htmlspecialchars($title) . '\"></div>';\n            \n            // Additional HSPs with connecting logic\n            for ($k = 1; $k < count($hsp_positions); $k++) {\n                $current = $hsp_positions[$k];\n                $previous = $hsp_positions[$k - 1];\n                $current_idx = $current['index'];\n                \n                $gap = $current['start'] - $previous['end'];\n                \n                if ($gap > 0) {\n                    // Add connector lines for gaps\n                    $html .= '<div class=\"hsp-connector\"></div>';\n                    \n                    // Add gap\n                    $gap_width = $gap * $px_unit;\n                    $html .= '<div class=\"hsp-gap\" style=\"width: ' . $gap_width . 'px;\"></div>';\n                    \n                    // Add connector on other side\n                    $html .= '<div class=\"hsp-connector\"></div>';\n                } else {\n                    // Overlapping or adjacent HSPs - just connector line\n                    $html .= '<div class=\"hsp-connector\"></div>';\n                }\n                \n                // Add current segment\n                $color = getHspColorClass($hsp_scores[$current_idx]);\n                $segment_width = ($current['end'] - $current['start']) * $px_unit;\n                $hsp = $hsp_details[$current_idx];\n                // Extract just the subject name (first word/identifier before space or bracket)\n                $hit_name = 'Hit ' . $hit_num;\n                if (!empty($hit['subject'])) {\n                    $desc = htmlspecialchars($hit['subject']);\n                    // Extract first word or identifier (up to first space, bracket, or pipe)\n                    preg_match('/^([^\\s\\[\\|\\-]+)/', $desc, $matches);\n                    if (!empty($matches[1])) {\n                        $hit_name = $matches[1];\n                    }\n                }\n                $title = $hit_name . ' - HSP ' . ($current_idx + 1) . ': ' . $hsp['percent_identity'] . '% identity | E-value: ' . sprintf('%.2e', $hsp['evalue']);\n                $html .= '<div class=\"hsp-segment ' . $color . '\" style=\"width: ' . $segment_width . 'px;\" title=\"' . htmlspecialchars($title) . '\"></div>';\n            }\n            \n            // Trailing gap\n            $last_end = $hsp_positions[count($hsp_positions) - 1]['end'];\n            if ($last_end < $results['query_length']) {\n                $trailing_gap = ($results['query_length'] - $last_end) * $px_unit;\n                $html .= '<div class=\"hsp-gap\" style=\"width: ' . $trailing_gap . 'px;\"></div>';\n            }\n        }\n        \n        $html .= '</div>';\n        $html .= '</div>';\n    }\n    \n    // Close the HSP rows wrapper\n    $html .= '</div>';\n    \n    // Close the scrollable HSP container\n    $html .= '</div>';\n    \n    // Close the main overflow:hidden container and outer div\n    $html .= '</div>';\n    $html .= '</div>';\n    \n    // Add description below the HSP visualization (outside the relative container so ticks don't overlap)\n    $html .= '<small class=\"text-muted\" style=\"display: block; margin-top: 15px; margin-bottom: 30px; text-align: center;\">Each color represents a different bit score range. Lines connect adjacent HSPs on the query sequence.</small>';\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "results",
                            "type": "array",
                            "description": "Parsed BLAST results"
                        },
                        {
                            "name": "blast_program",
                            "type": "string",
                            "description": "BLAST program name (blastn, blastp, etc.)"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML with HSP visualization",
                    "internalCalls": [
                        "generateHspVisualizationWithLines",
                        "generateQueryScoreLegend",
                        "generateQueryScaleTicks",
                        "getHspColorClass"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 987,
                            "context": "$html .= generateHspVisualizationWithLines($query, $blast_program, $query_num);"
                        }
                    ]
                },
                {
                    "name": "getHspColorClass",
                    "line": 1147,
                    "comment": "/**\n* Get HSP color class based on bit score\n* Color scheme informed by locBLAST color_key function concept\n* Implementation is original MOOP code with independently chosen RGB values\n*\n* @param float $score Bit score\n* @return string CSS class name for color\n*/",
                    "code": "function getHspColorClass($score) {\n    if ($score <= 40) {\n        return 'color-black';\n    } elseif ($score <= 50) {\n        return 'color-blue';\n    } elseif ($score <= 80) {\n        return 'color-green';\n    } elseif ($score <= 200) {\n        return 'color-purple';\n    } else {\n        return 'color-red';\n    }\n}",
                    "parameters": [
                        {
                            "name": "score",
                            "type": "float",
                            "description": "Bit score"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "CSS class name for color",
                    "internalCalls": [
                        "getHspColorClass"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 1147,
                            "context": "$color = getHspColorClass($hsp_scores[$first_idx]);"
                        },
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 1194,
                            "context": "$color = getHspColorClass($hsp_scores[$current_idx]);"
                        }
                    ]
                },
                {
                    "name": "getColorStyle",
                    "line": 1267,
                    "comment": "/**\n* Get inline CSS style for color class\n*\n* @param string $colorClass CSS class name\n* @return string Inline style\n*/",
                    "code": "function getColorStyle($colorClass) {\n    $styles = [\n        'color-black' => 'background-color: #000000;',\n        'color-blue' => 'background-color: #0047c8;',\n        'color-green' => 'background-color: #77de75;',\n        'color-purple' => 'background-color: #e967f5;',\n        'color-red' => 'background-color: #e83a2d;'\n    ];\n    \n    return isset($styles[$colorClass]) ? $styles[$colorClass] : '';\n}",
                    "parameters": [
                        {
                            "name": "colorClass",
                            "type": "string",
                            "description": "CSS class name"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Inline style",
                    "internalCalls": [
                        "getColorStyle"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "formatBlastAlignment",
                    "line": 605,
                    "comment": "/**\n* Format BLAST alignment output with frame-aware coordinate tracking\n* Frame-aware formatting approach inspired by locBLAST fmtprint() - handles frame shifts for BLASTx/tBLASTx\n* Implementation is original MOOP code independently developed from the concept\n*\n* @param int $length Alignment length\n* @param string $query_seq Query sequence with gaps\n* @param int $query_seq_from Query start coordinate\n* @param int $query_seq_to Query end coordinate\n* @param string $align_seq Midline (match indicators)\n* @param string $sbjct_seq Subject sequence with gaps\n* @param int $sbjct_seq_from Subject start coordinate\n* @param int $sbjct_seq_to Subject end coordinate\n* @param string $p_m Plus/Minus strand\n* @param int $query_frame Query reading frame (0=none, \u00b11,2,3 for proteins)\n* @param int $hit_frame Subject reading frame\n* @return string Formatted alignment text\n*/",
                    "code": "function formatBlastAlignment($length, $query_seq, $query_seq_from, $query_seq_to, $align_seq, $sbjct_seq, $sbjct_seq_from, $sbjct_seq_to, $p_m = 'Plus', $query_frame = 0, $hit_frame = 0) {\n    $output = '';\n    $large = max(array((int)$query_seq_from, (int)$query_seq_to, (int)$sbjct_seq_from, (int)$sbjct_seq_to));\n    $large_len = strlen($large);\n    $n = (int)($length / 60);\n    $r = $length % 60;\n    if ($r > 0) $t = $n + 1;\n    else $t = $n;\n    \n    if ($query_frame != 0 && $hit_frame != 0) {\n        // Both query and subject are in frames (protein vs protein or translated)\n        for ($i = 0; $i < $t; $i++) {\n            if ($query_frame > 0) {\n                $xn4 = $query_seq_from;\n                $xs4 = substr($query_seq, 60*$i, 60);\n                $xs4 = preg_replace(\"/-/\", \"\", $xs4);\n                $yn4 = $xn4 + (strlen($xs4) * 3) - 1;\n                $output .= \"\\nQuery  \" . str_pad($xn4, $large_len) . \"  \" . substr($query_seq, 60*$i, 60) . \"  \" . $yn4;\n                $xn4 = $yn4 + 1;\n                $output .= \"\\n       \". str_pad(\" \", $large_len) . \"  \" . substr($align_seq, 60*$i, 60);\n            } else {\n                $xn = $query_seq_to;\n                $xs = substr($query_seq, 60*$i, 60);\n                $xs = preg_replace(\"/-/\", \"\", $xs);\n                $yn = $xn - (strlen($xs) * 3) + 1;\n                $output .= \"\\nQuery  \" . str_pad($xn, $large_len) . \"  \" . substr($query_seq, 60*$i, 60) . \"  \" . $yn;\n                $xn = $yn - 1;\n                $output .= \"\\n       \". str_pad(\" \", $large_len) . \"  \" . substr($align_seq, 60*$i, 60);\n            }\n            if ($hit_frame > 0) {\n                $an4 = $sbjct_seq_from;\n                $ys4 = substr($sbjct_seq, 60*$i, 60);\n                $ys4 = preg_replace(\"/-/\", \"\", $ys4);\n                $bn4 = $an4 + (strlen($ys4) *3) - 1;\n                $output .= \"\\nSbjct  \" . str_pad($an4, $large_len) . \"  \" . substr($sbjct_seq, 60*$i, 60) . \"  \" . $bn4 . \"\\n\";\n                $an4 = $bn4 + 1;\n            } else {\n                $an = $sbjct_seq_to;\n                $ys = substr($sbjct_seq, 60*$i, 60);\n                $ys = preg_replace(\"/-/\", \"\", $ys);\n                $bn = $an - (strlen($ys) *3) + 1;\n                $output .= \"\\nSbjct  \" . str_pad($an, $large_len) . \"  \" . substr($sbjct_seq, 60*$i, 60) . \"  \" . $bn . \"\\n\";\n                $an = $bn - 1;\n            }\n        }\n    } elseif ($query_frame != 0 && $hit_frame == 0) {\n        // Query is framed (tBLASTx, BLASTx), subject is not\n        if ($query_frame > 0) { $xn1 = $query_seq_from; } else { $xn1 = $query_seq_to; }\n        $an1 = $sbjct_seq_from;\n        for ($i = 0; $i < $t; $i++) {\n            if ($query_frame > 0) {\n                $xs1 = substr($query_seq, 60*$i, 60);\n                $xs1 = preg_replace(\"/-/\", \"\", $xs1);\n                $yn1 = $xn1 + (strlen($xs1) * 3) - 1;\n                $output .= \"\\nQuery  \" . str_pad($xn1, $large_len) . \"  \" . substr($query_seq, 60*$i, 60) . \"  \" . $yn1;\n                $xn1 = $yn1 + 1;\n                $output .= \"\\n       \". str_pad(\" \", $large_len) . \"  \" . substr($align_seq, 60*$i, 60);\n                $ys1 = substr($sbjct_seq, 60*$i, 60);\n                $ys1 = preg_replace(\"/-/\", \"\", $ys1);\n                $bn1 = $an1 + strlen($ys1) - 1;\n                $output .= \"\\nSbjct  \" . str_pad($an1, $large_len) . \"  \" . substr($sbjct_seq, 60*$i, 60) . \"  \" . $bn1 . \"\\n\";\n                $an1 = $bn1 + 1;\n            } else {\n                $xs1 = substr($query_seq, 60*$i, 60);\n                $xs1 = preg_replace(\"/-/\", \"\", $xs1);\n                $yn1 = $xn1 - (strlen($xs1) * 3) + 1;\n                $output .= \"\\nQuery  \" . str_pad($xn1, $large_len) . \"  \" . substr($query_seq, 60*$i, 60) . \"  \" . $yn1;\n                $xn1 = $yn1 - 1;\n                $output .= \"\\n       \". str_pad(\" \", $large_len) . \"  \" . substr($align_seq, 60*$i, 60);\n                $ys1 = substr($sbjct_seq, 60*$i, 60);\n                $ys1 = preg_replace(\"/-/\", \"\", $ys1);\n                $bn1 = $an1 + strlen($ys1) - 1;\n                $output .= \"\\nSbjct  \" . str_pad($an1, $large_len) . \"  \" . substr($sbjct_seq, 60*$i, 60) . \"  \" . $bn1 . \"\\n\";\n                $an1 = $bn1 + 1;\n            }\n        }\n    } elseif ($query_frame == 0 && $hit_frame != 0) {\n        // Subject is framed, query is not\n        if ($hit_frame > 0) { $an3 = $sbjct_seq_from; } else { $an3 = $sbjct_seq_to; }\n        $xn3 = $query_seq_from;\n        for ($i = 0; $i < $t; $i++) {\n            if ($hit_frame > 0) {\n                $xs3 = substr($query_seq, 60*$i, 60);\n                $xs3 = preg_replace(\"/-/\", \"\", $xs3);\n                $yn3 = $xn3 + strlen($xs3) - 1;\n                $output .= \"\\nQuery  \" . str_pad($xn3, $large_len) . \"  \" . substr($query_seq, 60*$i, 60) . \"  \" . $yn3;\n                $xn3 = $yn3 + 1;\n                $output .= \"\\n       \". str_pad(\" \", $large_len) . \"  \" . substr($align_seq, 60*$i, 60);\n                $ys3 = substr($sbjct_seq, 60*$i, 60);\n                $ys3 = preg_replace(\"/-/\", \"\", $ys3);\n                $bn3 = $an3 + (strlen($ys3) * 3) - 1;\n                $output .= \"\\nSbjct  \" . str_pad($an3, $large_len) . \"  \" . substr($sbjct_seq, 60*$i, 60) . \"  \" . $bn3 . \"\\n\";\n                $an3 = $bn3 + 1;\n            } else {\n                $xs3 = substr($query_seq, 60*$i, 60);\n                $xs3 = preg_replace(\"/-/\", \"\", $xs3);\n                $yn3 = $xn3 + strlen($xs3) - 1;\n                $output .= \"\\nQuery  \" . str_pad($xn3, $large_len) . \"  \" . substr($query_seq, 60*$i, 60) . \"  \" . $yn3;\n                $xn3 = $yn3 + 1;\n                $output .= \"\\n       \". str_pad(\" \", $large_len) . \"  \" . substr($align_seq, 60*$i, 60);\n                $ys3 = substr($sbjct_seq, 60*$i, 60);\n                $ys3 = preg_replace(\"/-/\", \"\", $ys3);\n                $bn3 = $an3 - (strlen($ys3) * 3) + 1;\n                $output .= \"\\nSbjct  \" . str_pad($an3, $large_len) . \"  \" . substr($sbjct_seq, 60*$i, 60) . \"  \" . $bn3 . \"\\n\";\n                $an3 = $bn3 - 1;\n            }\n        }\n    } else {\n        // No frames - standard nucleotide vs nucleotide\n        $xn2 = $query_seq_from;\n        $an2 = $sbjct_seq_from;\n        for ($i = 0; $i < $t; $i++) {\n            $xs2 = substr($query_seq, 60*$i, 60);\n            $xs2 = preg_replace(\"/-/\", \"\", $xs2);\n            $yn2 = $xn2 + strlen($xs2) - 1;\n            $output .= \"\\nQuery  \" . str_pad($xn2, $large_len) . \"  \" . substr($query_seq, 60*$i, 60) . \"  \" . $yn2;\n            $xn2 = $yn2 + 1;\n            $output .= \"\\n       \". str_pad(\" \", $large_len) . \"  \" . substr($align_seq, 60*$i, 60);\n            $ys2 = substr($sbjct_seq, 60*$i, 60);\n            $ys2 = preg_replace(\"/-/\", \"\", $ys2);\n            if ($p_m == \"Plus\") {\n                $bn2 = $an2 + strlen($ys2) - 1;\n                $output .= \"\\nSbjct  \" . str_pad($an2, $large_len) . \"  \" . substr($sbjct_seq, 60*$i, 60) . \"  \" . $bn2 . \"\\n\";\n                $an2 = $bn2 + 1;\n            } else {\n                $bn2 = $an2 - strlen($ys2) + 1;\n                $output .= \"\\nSbjct  \" . str_pad($an2, $large_len) . \"  \" . substr($sbjct_seq, 60*$i, 60) . \"  \" . $bn2 . \"\\n\";\n                $an2 = $bn2 - 1;\n            }\n        }\n    }\n    \n    return $output;\n}",
                    "parameters": [
                        {
                            "name": "length",
                            "type": "int",
                            "description": "Alignment length"
                        },
                        {
                            "name": "query_seq",
                            "type": "string",
                            "description": "Query sequence with gaps"
                        },
                        {
                            "name": "query_seq_from",
                            "type": "int",
                            "description": "Query start coordinate"
                        },
                        {
                            "name": "query_seq_to",
                            "type": "int",
                            "description": "Query end coordinate"
                        },
                        {
                            "name": "align_seq",
                            "type": "string",
                            "description": "Midline (match indicators)"
                        },
                        {
                            "name": "sbjct_seq",
                            "type": "string",
                            "description": "Subject sequence with gaps"
                        },
                        {
                            "name": "sbjct_seq_from",
                            "type": "int",
                            "description": "Subject start coordinate"
                        },
                        {
                            "name": "sbjct_seq_to",
                            "type": "int",
                            "description": "Subject end coordinate"
                        },
                        {
                            "name": "p_m",
                            "type": "string",
                            "description": "Plus/Minus strand"
                        },
                        {
                            "name": "query_frame",
                            "type": "int",
                            "description": "Query reading frame (0=none, \u00b11,2,3 for proteins)"
                        },
                        {
                            "name": "hit_frame",
                            "type": "int",
                            "description": "Subject reading frame"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Formatted alignment text",
                    "internalCalls": [
                        "formatBlastAlignment"
                    ],
                    "category": "tools-blast",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 605,
                            "context": "$alignment_text = formatBlastAlignment("
                        }
                    ]
                },
                {
                    "name": "generateQueryScoreLegend",
                    "line": 1076,
                    "comment": "/**\n* Generate query score legend (outside overflow container)\n* Shows score color ranges and query bar info\n*\n* @param int $query_length Total query length\n* @param string $query_name Optional query name/ID\n* @return string HTML for legend and query bar\n*/",
                    "code": "function generateQueryScoreLegend($query_length, $query_name = '') {\n    $output = '<div style=\"margin: 0 auto 0px auto; width: 1000px;\">';\n    \n    // Score legend bar - discrete colored boxes (800px total width to match query)\n    $output .= '<div style=\"display: flex; align-items: center; margin-bottom: 0;\">';\n    $output .= '<div style=\"min-width: 100px; padding-right: 15px; font-size: 11px; font-weight: bold; text-align: right;\">Score:</div>';\n    $output .= '<div style=\"display: flex; gap: 0; width: 800px;\">';\n    \n    $score_ranges = [\n        ['color' => '#000000', 'label' => '\u226440<br><small>(Weak)</small>'],\n        ['color' => '#0047c8', 'label' => '40-50'],\n        ['color' => '#77de75', 'label' => '50-80'],\n        ['color' => '#e967f5', 'label' => '80-200'],\n        ['color' => '#e83a2d', 'label' => '\u2265200<br><small>(Excellent)</small>']\n    ];\n    \n    $box_width = (800 / 5); // Divide 800px by 5 color ranges evenly\n    foreach ($score_ranges as $range) {\n        $output .= '<div style=\"width: ' . $box_width . 'px; height: 25px; background-color: ' . $range['color'] . '; border-right: 1px solid #333; display: flex; align-items: center; justify-content: center;\">';\n        $output .= '<span style=\"color: white; font-size: 10px; font-weight: bold; text-align: center; line-height: 1.2;\">' . $range['label'] . '</span>';\n        $output .= '</div>';\n    }\n    \n    $output .= '</div>';\n    $output .= '</div>';\n    \n    // Query bar - 800px width (no margins or padding, directly touches everything)\n    $output .= '<div style=\"display: flex; align-items: center; margin: 0; padding: 0;\">';\n    $output .= '<div style=\"min-width: 100px; padding-right: 15px; font-size: 11px; font-weight: bold; text-align: right;\">';\n    $output .= 'Query:';\n    if (!empty($query_name)) {\n        $output .= '<br><small style=\"font-weight: normal; color: #666;\">' . htmlspecialchars(substr($query_name, 0, 20)) . '</small>';\n    }\n    $output .= '</div>';\n    $output .= '<div style=\"width: 800px; height: 20px; position: relative; background: #f0f0f0; border-left: 1px solid #999; border-right: 1px solid #999; margin: 0; padding: 0;\">';\n    $output .= '<div style=\"position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: linear-gradient(to right, #4CAF50 0%, #45a049 100%); margin: 0; padding: 0;\"></div>';\n    $output .= '<div style=\"position: absolute; left: 5px; top: 2px; color: white; font-size: 11px; font-weight: bold;\">1 - ' . $query_length . ' bp</div>';\n    $output .= '</div>';\n    $output .= '</div>';\n    \n    $output .= '</div>';\n    \n    return $output;\n}",
                    "parameters": [
                        {
                            "name": "query_length",
                            "type": "int",
                            "description": "Total query length"
                        },
                        {
                            "name": "query_name",
                            "type": "string",
                            "description": "Optional query name/ID"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML for legend and query bar",
                    "internalCalls": [
                        "generateQueryScoreLegend"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 1076,
                            "context": "$html .= generateQueryScoreLegend($results['query_length'], $results['query_name']);"
                        }
                    ]
                },
                {
                    "name": "generateQueryScaleTicks",
                    "line": 1102,
                    "comment": "/**\n* Generate query scale ticks (inside overflow container to be clipped)\n* Shows tick marks and vertical reference lines\n* Must be positioned at top of the HSP rows\n*\n* @param int $query_length Total query length\n* @return string HTML for scale ticks and vertical lines\n*/",
                    "code": "function generateQueryScaleTicks($query_length) {\n    $pxls = 800 / $query_length;\n    $output = '';\n    \n    // Generate exactly 10 evenly-spaced ticks across the query length\n    $tick_numbers = [];\n    \n    // Calculate the spacing to get 10 ticks\n    $tick_interval = $query_length / 10;\n    \n    // Generate 10 ticks\n    for ($i = 1; $i <= 10; $i++) {\n        $tick_numbers[] = (int)($tick_interval * $i);\n    }\n    \n    // Ensure the last tick is exactly the query length\n    if (!empty($tick_numbers)) {\n        $tick_numbers[count($tick_numbers) - 1] = $query_length;\n    }\n    \n    // Scale ruler container with absolute positioning at the top\n    // Use lower z-index so HSP bars appear on top of the reference lines\n    $output .= '<div style=\"position: absolute; top: 0; left: 0; width: 100%; height: 80px; z-index: 1; margin: 0; padding: 0;\">';\n    \n    // Flex container for alignment\n    $output .= '<div style=\"display: flex; align-items: flex-start; width: 100%; margin: 0; padding: 0;\">';\n    $output .= '<div style=\"min-width: 100px; padding-right: 15px; margin: 0;\"></div>';\n    \n    // Container for ruler - 800px width\n    $output .= '<div style=\"position: relative; width: 800px; height: 80px; margin: 0; padding: 0;\">';\n    \n    // Draw \"1\" marker at the start (aligned with other tick numbers at top: 10px)\n    $output .= '<div style=\"position: absolute; left: -15px; top: 10px; width: 30px; text-align: center; font-size: 11px; font-weight: bold;\">1</div>';\n    \n    // Draw tick marks with labels and vertical reference lines\n    foreach ($tick_numbers as $tick_num) {\n        // Calculate pixel position for this tick number (accounting for 1-based indexing)\n        $pixel_pos = (int)($pxls * ($tick_num - 1));\n        \n        // Vertical reference line - extends from top through ticks to HSP boxes below\n        $output .= '<div style=\"position: absolute; left: ' . $pixel_pos . 'px; top: 0px; width: 1px; height: 2000px; background: #cccccc; pointer-events: none;\"></div>';\n        \n        // Tick mark at the top (dark gray)\n        $output .= '<div style=\"position: absolute; left: ' . $pixel_pos . 'px; top: 0px; width: 1px; height: 8px; background: #999;\"></div>';\n        \n        // Tick label number (aligned with \"1\" marker)\n        $output .= '<div style=\"position: absolute; left: ' . ($pixel_pos - 15) . 'px; top: 10px; width: 30px; text-align: center; font-size: 11px; font-weight: bold;\">' . $tick_num . '</div>';\n    }\n    \n    $output .= '</div>';\n    $output .= '</div>';\n    $output .= '</div>';\n    \n    return $output;\n}",
                    "parameters": [
                        {
                            "name": "query_length",
                            "type": "int",
                            "description": "Total query length"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML for scale ticks and vertical lines",
                    "internalCalls": [
                        "generateQueryScaleTicks"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 1102,
                            "context": "$html .= generateQueryScaleTicks($results['query_length']);"
                        }
                    ]
                },
                {
                    "name": "generateQueryScale",
                    "line": 1102,
                    "comment": "/**\n* Generate query scale ruler with intelligent tick spacing\n* Original MOOP implementation displaying as positioned overlay\n* Includes horizontal query bar representation aligned with HSP boxes\n* Tick lines are positioned absolutely and will be clipped by parent container\n*\n* @param int $query_length Total query length\n* @param string $query_name Optional query name/ID\n* @return string HTML for scale labels, ticks, and query bar\n*/",
                    "code": "function generateQueryScale($query_length, $query_name = '') {\n    $pxls = 800 / $query_length;  // Wider 800px instead of 500px\n    $output = '<div style=\"margin: 0 auto 20px auto; width: 1000px;\">';\n    \n    // Score legend bar - discrete colored boxes (800px total width to match query)\n    $output .= '<div style=\"display: flex; align-items: center; margin-bottom: 10px;\">';\n    $output .= '<div style=\"min-width: 100px; padding-right: 15px; font-size: 11px; font-weight: bold; text-align: right;\">Score:</div>';\n    $output .= '<div style=\"display: flex; gap: 0; width: 800px;\">';\n    \n    $score_ranges = [\n        ['color' => '#000000', 'label' => '\u226440<br><small>(Weak)</small>'],\n        ['color' => '#0047c8', 'label' => '40-50'],\n        ['color' => '#77de75', 'label' => '50-80'],\n        ['color' => '#e967f5', 'label' => '80-200'],\n        ['color' => '#e83a2d', 'label' => '\u2265200<br><small>(Excellent)</small>']\n    ];\n    \n    $box_width = (800 / 5); // Divide 800px by 5 color ranges evenly\n    foreach ($score_ranges as $range) {\n        $output .= '<div style=\"width: ' . $box_width . 'px; height: 25px; background-color: ' . $range['color'] . '; border-right: 1px solid #333; display: flex; align-items: center; justify-content: center;\">';\n        $output .= '<span style=\"color: white; font-size: 10px; font-weight: bold; text-align: center; line-height: 1.2;\">' . $range['label'] . '</span>';\n        $output .= '</div>';\n    }\n    \n    $output .= '</div>';\n    $output .= '</div>';\n    \n    // Query bar - 800px width\n    $output .= '<div style=\"display: flex; align-items: center; margin-bottom: 0;\">';\n    $output .= '<div style=\"min-width: 100px; padding-right: 15px; font-size: 11px; font-weight: bold; text-align: right;\">';\n    $output .= 'Query:';\n    if (!empty($query_name)) {\n        $output .= '<br><small style=\"font-weight: normal; color: #666;\">' . htmlspecialchars(substr($query_name, 0, 20)) . '</small>';\n    }\n    $output .= '</div>';\n    $output .= '<div style=\"width: 800px; height: 20px; position: relative; background: #f0f0f0; border-left: 1px solid #999; border-right: 1px solid #999; border-bottom: 1px solid #999; border-radius: 0 0 3px 3px; margin-right: 10px;\">';\n    $output .= '<div style=\"position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: linear-gradient(to right, #4CAF50 0%, #45a049 100%); border-radius: 0 0 2px 2px;\"></div>';\n    $output .= '<div style=\"position: absolute; left: 5px; top: 2px; color: white; font-size: 11px; font-weight: bold;\">1 - ' . $query_length . ' bp</div>';\n    $output .= '</div>';\n    $output .= '</div>';\n    \n    // Generate scale tick numbers: Calculate evenly spaced rounded intervals\n    $tick_numbers = [];\n    $tick_interval = $query_length / 10;  // Base interval for 10 ticks\n    \n    // Determine rounding interval based on query length for clean numbers\n    if ($query_length <= 100) {\n        $round_to = 10;\n    } elseif ($query_length <= 500) {\n        $round_to = 50;\n    } elseif ($query_length <= 1000) {\n        $round_to = 100;\n    } elseif ($query_length <= 5000) {\n        $round_to = 500;\n    } else {\n        $round_to = 1000;\n    }\n    \n    // Round the base interval to get consistent tick spacing\n    $rounded_interval = round($tick_interval / $round_to) * $round_to;\n    \n    // Generate 10 tick numbers using the rounded interval\n    for ($i = 1; $i <= 10; $i++) {\n        $tick_num = $i * $rounded_interval;\n        if ($tick_num <= $query_length) {\n            $tick_numbers[] = $tick_num;\n        }\n    }\n    \n    // Scale ruler with ticks and vertical lines down to HSPs\n    $output .= '<div style=\"display: flex; align-items: flex-start;\">';\n    $output .= '<div style=\"min-width: 100px; padding-right: 15px;\"></div>';\n    \n    // Container for ruler - 800px width, extended height for vertical lines\n    $output .= '<div style=\"position: relative; height: 40px; width: 800px; margin-right: 10px;\">';\n    \n    // Draw \"1\" marker at the start\n    $output .= '<div style=\"position: absolute; left: -15px; top: 10px; width: 30px; text-align: center; font-size: 11px; font-weight: bold;\">1</div>';\n    \n    // Draw tick marks with labels and vertical reference lines\n    foreach ($tick_numbers as $tick_num) {\n        // Calculate pixel position for this tick number (accounting for 1-based indexing)\n        $pixel_pos = (int)($pxls * ($tick_num - 1));\n        \n        // Vertical reference line (light gray) extending down - will be clipped by parent container's overflow:hidden\n        $output .= '<div style=\"position: absolute; left: ' . $pixel_pos . 'px; top: 0; width: 1px; height: 2000px; background: #cccccc; pointer-events: none;\"></div>';\n        \n        // Tick mark at the top (dark gray)\n        $output .= '<div style=\"position: absolute; left: ' . $pixel_pos . 'px; top: 0; width: 1px; height: 8px; background: #999;\"></div>';\n        \n        // Tick label number (centered below tick mark)\n        $output .= '<div style=\"position: absolute; left: ' . ($pixel_pos - 15) . 'px; top: 10px; width: 30px; text-align: center; font-size: 11px; font-weight: bold;\">' . $tick_num . '</div>';\n    }\n    \n    $output .= '</div>';\n    $output .= '</div>';\n    $output .= '</div>';\n    \n    return $output;\n}",
                    "parameters": [
                        {
                            "name": "query_length",
                            "type": "int",
                            "description": "Total query length"
                        },
                        {
                            "name": "query_name",
                            "type": "string",
                            "description": "Optional query name/ID"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML for scale labels, ticks, and query bar",
                    "internalCalls": [
                        "generateQueryScale"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "getToggleQuerySectionScript",
                    "line": 1664,
                    "comment": "/**\n* JavaScript function for toggling query sections (embedded in PHP output)\n* Called onclick from query section headers\n*/",
                    "code": "function getToggleQuerySectionScript() {\n    return <<<'JS'\n<script>\nfunction toggleQuerySection(contentId, headerElement) {\n    const content = document.getElementById(contentId);\n    const chevron = headerElement.querySelector('i');\n    \n    if (content.style.display === 'none') {\n        content.style.display = 'block';\n        chevron.style.transform = 'rotate(180deg)';\n    } else {\n        content.style.display = 'none';\n        chevron.style.transform = 'rotate(0deg)';\n    }\n}\n</script>\nJS;\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "getToggleQuerySectionScript",
                        "toggleQuerySection"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/blast.php",
                            "line": 291,
                            "context": "<?= getToggleQuerySectionScript() ?>"
                        }
                    ]
                },
                {
                    "name": "toggleQuerySection",
                    "line": 964,
                    "comment": "",
                    "code": "function toggleQuerySection(contentId, headerElement) {\n    const content = document.getElementById(contentId);\n    const chevron = headerElement.querySelector('i');\n    \n    if (content.style.display === 'none') {\n        content.style.display = 'block';\n        chevron.style.transform = 'rotate(180deg)';\n    } else {\n        content.style.display = 'none';\n        chevron.style.transform = 'rotate(0deg)';\n    }\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "toggleQuerySection"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/blast_results_visualizer.php",
                            "line": 964,
                            "context": "$html .= '<div id=\"query-' . $query_num . '-header\" style=\"padding: 15px; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center;\" onclick=\"toggleQuerySection(\\'query-' . $query_num . '-content\\', this);\">';"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/database_queries.php",
            "count": 15,
            "functions": [
                {
                    "name": "getFeatureById",
                    "line": 28,
                    "comment": "/**\n* Get feature data by feature_id\n* Returns complete feature information including organism and genome data\n*\n* @param int $feature_id - Feature ID to retrieve\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results\n* @return array - Feature row with organism and genome info, or empty array\n*/",
                    "code": "function getFeatureById($feature_id, $dbFile, $genome_ids = []) {\n    if (!empty($genome_ids)) {\n        $placeholders = implode(',', array_fill(0, count($genome_ids), '?'));\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.parent_feature_id, f.genome_id, f.organism_id,\n                         o.genus, o.species, o.subtype, o.common_name, o.taxon_id,\n                         g.genome_accession, g.genome_name\n                  FROM feature f\n                  JOIN organism o ON f.organism_id = o.organism_id\n                  JOIN genome g ON f.genome_id = g.genome_id\n                  WHERE f.feature_id = ? AND f.genome_id IN ($placeholders)\";\n        $params = array_merge([$feature_id], $genome_ids);\n    } else {\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.parent_feature_id, f.genome_id, f.organism_id,\n                         o.genus, o.species, o.subtype, o.common_name, o.taxon_id,\n                         g.genome_accession, g.genome_name\n                  FROM feature f\n                  JOIN organism o ON f.organism_id = o.organism_id\n                  JOIN genome g ON f.genome_id = g.genome_id\n                  WHERE f.feature_id = ?\";\n        $params = [$feature_id];\n    }\n    \n    $results = fetchData($query, $dbFile, $params);\n    return !empty($results) ? $results[0] : [];\n}",
                    "parameters": [
                        {
                            "name": "feature_id",
                            "type": "int",
                            "description": "Feature ID to retrieve"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Feature row with organism and genome info, or empty array",
                    "internalCalls": [
                        "getFeatureById",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 974,
                            "context": "$parent = getFeatureById(feature.parent_feature_id);"
                        },
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 154,
                            "context": "$row = getFeatureById($ancestor_feature_id, $db, $accessible_genome_ids);"
                        }
                    ]
                },
                {
                    "name": "getFeatureByUniquename",
                    "line": 65,
                    "comment": "/**\n* Get feature data by feature_uniquename\n* Returns complete feature information including organism and genome data\n*\n* @param string $feature_uniquename - Feature uniquename to retrieve\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results\n* @return array - Feature row with organism and genome info, or empty array\n*/",
                    "code": "function getFeatureByUniquename($feature_uniquename, $dbFile, $genome_ids = []) {\n    if (!empty($genome_ids)) {\n        $placeholders = implode(',', array_fill(0, count($genome_ids), '?'));\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.parent_feature_id, f.genome_id, f.organism_id,\n                         o.genus, o.species, o.subtype, o.common_name, o.taxon_id,\n                         g.genome_accession, g.genome_name\n                  FROM feature f\n                  JOIN organism o ON f.organism_id = o.organism_id\n                  JOIN genome g ON f.genome_id = g.genome_id\n                  WHERE f.feature_uniquename = ? AND f.genome_id IN ($placeholders)\";\n        $params = array_merge([$feature_uniquename], $genome_ids);\n    } else {\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.parent_feature_id, f.genome_id, f.organism_id,\n                         o.genus, o.species, o.subtype, o.common_name, o.taxon_id,\n                         g.genome_accession, g.genome_name\n                  FROM feature f\n                  JOIN organism o ON f.organism_id = o.organism_id\n                  JOIN genome g ON f.genome_id = g.genome_id\n                  WHERE f.feature_uniquename = ?\";\n        $params = [$feature_uniquename];\n    }\n    \n    $results = fetchData($query, $dbFile, $params);\n    return !empty($results) ? $results[0] : [];\n}",
                    "parameters": [
                        {
                            "name": "feature_uniquename",
                            "type": "string",
                            "description": "Feature uniquename to retrieve"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Feature row with organism and genome info, or empty array",
                    "internalCalls": [
                        "getFeatureByUniquename",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 4,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 19,
                            "context": "$feature = getFeatureByUniquename($feature_uniquename, $dbFile, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 807,
                            "context": "$feature = getFeatureByUniquename($uniquename, $db, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 877,
                            "context": "<td><code>getFeatureByUniquename()</code></td>"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 165,
                            "context": "$feature_result = getFeatureByUniquename($uniquename, $db);"
                        }
                    ]
                },
                {
                    "name": "getChildrenByFeatureId",
                    "line": 102,
                    "comment": "/**\n* Get immediate children of a feature (not recursive)\n* Returns direct children only\n*\n* @param int $parent_feature_id - Parent feature ID\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results\n* @return array - Array of child feature rows\n*/",
                    "code": "function getChildrenByFeatureId($parent_feature_id, $dbFile, $genome_ids = []) {\n    if (!empty($genome_ids)) {\n        $placeholders = implode(',', array_fill(0, count($genome_ids), '?'));\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.parent_feature_id\n                  FROM feature f\n                  WHERE f.parent_feature_id = ? AND f.genome_id IN ($placeholders)\";\n        $params = array_merge([$parent_feature_id], $genome_ids);\n    } else {\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.parent_feature_id\n                  FROM feature f\n                  WHERE f.parent_feature_id = ?\";\n        $params = [$parent_feature_id];\n    }\n    \n    return fetchData($query, $dbFile, $params);\n}",
                    "parameters": [
                        {
                            "name": "parent_feature_id",
                            "type": "int",
                            "description": "Parent feature ID"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of child feature rows",
                    "internalCalls": [
                        "getChildrenByFeatureId",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 75,
                            "context": "$results = getChildrenByFeatureId($feature_id, $dbFile, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 97,
                            "context": "$results = getChildrenByFeatureId($feature_id, $dbFile, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 281,
                            "context": "$results = getChildrenByFeatureId($feature_id, $dbFile, $genome_ids);"
                        }
                    ]
                },
                {
                    "name": "getParentFeature",
                    "line": 130,
                    "comment": "/**\n* Get immediate parent of a feature by ID\n* Returns minimal parent info for hierarchy traversal\n*\n* @param int $feature_id - Feature ID to get parent of\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results\n* @return array - Parent feature row (minimal fields), or empty array\n*/",
                    "code": "function getParentFeature($feature_id, $dbFile, $genome_ids = []) {\n    if (!empty($genome_ids)) {\n        $placeholders = implode(',', array_fill(0, count($genome_ids), '?'));\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_type, f.parent_feature_id\n                  FROM feature f\n                  WHERE f.feature_id = ? AND f.genome_id IN ($placeholders)\";\n        $params = array_merge([$feature_id], $genome_ids);\n    } else {\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_type, f.parent_feature_id\n                  FROM feature f\n                  WHERE f.feature_id = ?\";\n        $params = [$feature_id];\n    }\n    \n    $results = fetchData($query, $dbFile, $params);\n    return !empty($results) ? $results[0] : [];\n}",
                    "parameters": [
                        {
                            "name": "feature_id",
                            "type": "int",
                            "description": "Feature ID to get parent of"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Parent feature row (minimal fields), or empty array",
                    "internalCalls": [
                        "getParentFeature",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 46,
                            "context": "$feature = getParentFeature($feature_id, $dbFile, $genome_ids);"
                        }
                    ]
                },
                {
                    "name": "getFeaturesByType",
                    "line": 157,
                    "comment": "/**\n* Get all features of specific types in a genome\n* Useful for getting genes, mRNAs, or other feature types\n*\n* @param string $feature_type - Feature type to retrieve (e.g., 'gene', 'mRNA')\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results\n* @return array - Array of features with specified type\n*/",
                    "code": "function getFeaturesByType($feature_type, $dbFile, $genome_ids = []) {\n    if (!empty($genome_ids)) {\n        $placeholders = implode(',', array_fill(0, count($genome_ids), '?'));\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.genome_id\n                  FROM feature f\n                  WHERE f.feature_type = ? AND f.genome_id IN ($placeholders)\n                  ORDER BY f.feature_uniquename\";\n        $params = array_merge([$feature_type], $genome_ids);\n    } else {\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.genome_id\n                  FROM feature f\n                  WHERE f.feature_type = ?\n                  ORDER BY f.feature_uniquename\";\n        $params = [$feature_type];\n    }\n    \n    return fetchData($query, $dbFile, $params);\n}",
                    "parameters": [
                        {
                            "name": "feature_type",
                            "type": "string",
                            "description": "Feature type to retrieve (e.g., 'gene', 'mRNA')"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of features with specified type",
                    "internalCalls": [
                        "getFeaturesByType",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "searchFeaturesByUniquename",
                    "line": 187,
                    "comment": "/**\n* Search features by uniquename with optional organism filter\n* Used for quick feature lookup and search suggestions\n*\n* @param string $search_term - Search term for feature uniquename (supports wildcards)\n* @param string $dbFile - Path to SQLite database\n* @param string $organism_name - Optional: Filter by organism name\n* @return array - Array of matching features\n*/",
                    "code": "function searchFeaturesByUniquename($search_term, $dbFile, $organism_name = '') {\n    if ($organism_name) {\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.organism_id, o.genus, o.species\n                  FROM feature f\n                  JOIN organism o ON f.organism_id = o.organism_id\n                  WHERE f.feature_uniquename LIKE ? AND o.genus || ' ' || o.species LIKE ?\n                  ORDER BY f.feature_uniquename\n                  LIMIT 50\";\n        $params = [\"%$search_term%\", \"%$organism_name%\"];\n    } else {\n        $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_name, f.feature_description, \n                         f.feature_type, f.organism_id, o.genus, o.species\n                  FROM feature f\n                  JOIN organism o ON f.organism_id = o.organism_id\n                  WHERE f.feature_uniquename LIKE ?\n                  ORDER BY f.feature_uniquename\n                  LIMIT 50\";\n        $params = [\"%$search_term%\"];\n    }\n    \n    return fetchData($query, $dbFile, $params);\n}",
                    "parameters": [
                        {
                            "name": "search_term",
                            "type": "string",
                            "description": "Search term for feature uniquename (supports wildcards)"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Optional: Filter by organism name"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of matching features",
                    "internalCalls": [
                        "searchFeaturesByUniquename",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "getAnnotationsByFeature",
                    "line": 219,
                    "comment": "/**\n* Get all annotations for a feature\n* Returns annotations with their sources and metadata\n*\n* @param int $feature_id - Feature ID to get annotations for\n* @param string $dbFile - Path to SQLite database\n* @return array - Array of annotation records\n*/",
                    "code": "function getAnnotationsByFeature($feature_id, $dbFile) {\n    $query = \"SELECT a.annotation_id, a.annotation_accession, a.annotation_description, \n                     ans.annotation_source_name, ans.annotation_source_id,\n                     fa.score, fa.date, fa.additional_info\n              FROM annotation a\n              JOIN feature_annotation fa ON a.annotation_id = fa.annotation_id\n              JOIN annotation_source ans ON a.annotation_source_id = ans.annotation_source_id\n              WHERE fa.feature_id = ?\n              ORDER BY fa.date DESC\";\n    \n    return fetchData($query, $dbFile, [$feature_id]);\n}",
                    "parameters": [
                        {
                            "name": "feature_id",
                            "type": "int",
                            "description": "Feature ID to get annotations for"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of annotation records",
                    "internalCalls": [
                        "getAnnotationsByFeature",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "getOrganismInfo",
                    "line": 240,
                    "comment": "/**\n* Get organism information\n* Returns complete organism record with taxonomic data\n*\n* @param string $organism_name - Organism name (genus + species)\n* @param string $dbFile - Path to SQLite database\n* @return array - Organism record, or empty array if not found\n*/",
                    "code": "function getOrganismInfo($organism_name, $dbFile) {\n    $query = \"SELECT organism_id, genus, species, common_name, subtype, taxon_id\n              FROM organism\n              WHERE (genus || ' ' || species = ? OR common_name = ?)\n              LIMIT 1\";\n    \n    $results = fetchData($query, [$organism_name, $organism_name], $dbFile);\n    return !empty($results) ? $results[0] : [];\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name (genus + species)"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Organism record, or empty array if not found",
                    "internalCalls": [
                        "getOrganismInfo",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "getAssemblyStats",
                    "line": 258,
                    "comment": "/**\n* Get assembly/genome statistics\n* Returns feature counts and metadata for an assembly\n*\n* @param string $genome_accession - Genome/assembly accession\n* @param string $dbFile - Path to SQLite database\n* @return array - Genome record with feature counts, or empty array\n*/",
                    "code": "function getAssemblyStats($genome_id_param, $dbFile) {\n    $query = \"SELECT g.genome_id, g.genome_accession, g.genome_name,\n                     COUNT(DISTINCT CASE WHEN f.feature_type = 'gene' THEN f.feature_id END) as gene_count,\n                     COUNT(DISTINCT CASE WHEN f.feature_type = 'mRNA' THEN f.feature_id END) as mrna_count,\n                     COUNT(DISTINCT f.feature_id) as total_features\n              FROM genome g\n              LEFT JOIN feature f ON g.genome_id = f.genome_id\n              WHERE g.genome_accession = ? OR g.genome_name = ?\n              GROUP BY g.genome_id\";\n    \n    $results = fetchData($query, $dbFile, [$genome_id_param, $genome_id_param]);\n    return !empty($results) ? $results[0] : [];\n}",
                    "parameters": [
                        {
                            "name": "genome_accession",
                            "type": "string",
                            "description": "Genome/assembly accession"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Genome record with feature counts, or empty array",
                    "internalCalls": [
                        "getAssemblyStats",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/assembly.php",
                            "line": 53,
                            "context": "$assembly_info = getAssemblyStats($assembly_param, $db_path);"
                        }
                    ]
                },
                {
                    "name": "searchFeaturesAndAnnotations",
                    "line": 282,
                    "comment": "/**\n* Search features and annotations by keyword\n* Supports both keyword and quoted phrase searches\n* Used by annotation_search_ajax.php\n*\n* @param string $search_term - Search term or phrase\n* @param bool $is_quoted_search - Whether this is a quoted phrase search\n* @param string $dbFile - Path to SQLite database\n* @return array - Array of matching features with annotations\n*/",
                    "code": "function searchFeaturesAndAnnotations($search_term, $is_quoted_search, $dbFile, $source_names = [], $assembly_accession = '') {\n    // Use provided source names filter, or empty array if not provided\n    $source_filter = !empty($source_names) ? $source_names : [];\n    $search_term_clean = $search_term;\n    \n    // Build the WHERE clause for annotations with REGEXP ranking\n    if ($is_quoted_search) {\n        // Exact phrase match\n        $like_pattern = \"%$search_term_clean%\";\n        $regex_exact = '\\b' . preg_quote($search_term_clean, '/') . '\\b';\n        $regex_start = '\\b' . preg_quote($search_term_clean, '/');\n        $regex_start_of_string = '^' . preg_quote($search_term_clean, '/');\n        \n        $query = \"SELECT f.feature_uniquename, f.feature_name, f.feature_description, \n                         a.annotation_accession, a.annotation_description, \n                         fa.score, fa.date, ans.annotation_source_name, \n                         o.genus, o.species, o.common_name, o.subtype, f.feature_type, f.organism_id,\n                         g.genome_accession\n                  FROM annotation a, feature f, feature_annotation fa, annotation_source ans, organism o, genome g\n                  WHERE ans.annotation_source_id = a.annotation_source_id \n                    AND f.feature_id = fa.feature_id \n                    AND fa.annotation_id = a.annotation_id \n                    AND f.organism_id = o.organism_id\n                    AND f.genome_id = g.genome_id\n                    AND (a.annotation_description LIKE ? \n                       OR f.feature_name LIKE ? \n                       OR f.feature_description LIKE ?\n                       OR a.annotation_accession LIKE ?)\";\n        \n        $params = [$like_pattern, $like_pattern, $like_pattern, $like_pattern];\n        \n        // Add assembly filter if specified\n        if (!empty($assembly_accession)) {\n            $query .= \" AND g.genome_accession = ?\";\n            $params[] = $assembly_accession;\n        }\n        \n        // Add source filter if specified (exact match with IN)\n        if (!empty($source_filter)) {\n            $placeholders = implode(',', array_fill(0, count($source_filter), '?'));\n            $query .= \" AND ans.annotation_source_name IN ($placeholders)\";\n            $params = array_merge($params, $source_filter);\n        }\n        \n        $query .= \" ORDER BY \n                     CASE \n                       WHEN f.feature_name REGEXP ? THEN 1\n                       WHEN f.feature_name REGEXP ? THEN 2\n                       WHEN f.feature_description REGEXP ? THEN 3\n                       WHEN f.feature_description REGEXP ? THEN 4\n                       WHEN f.feature_description LIKE ? THEN 5\n                       WHEN a.annotation_description REGEXP ? THEN 6\n                       ELSE 7\n                     END,\n                     f.feature_uniquename\";\n        \n        $params[] = $regex_exact;\n        $params[] = $regex_start;\n        $params[] = $regex_start_of_string;\n        $params[] = $regex_start;\n        $params[] = \"%$search_term_clean%\";\n        $params[] = $regex_exact;\n        \n    } else {\n        // Multi-term keyword search (all terms must appear somewhere)\n        $terms = array_filter(array_map('trim', preg_split('/\\s+/', $search_term_clean)));\n        if (empty($terms)) {\n            return ['results' => [], 'capped' => false, 'warning' => null];\n        }\n        \n        // Extract primary term for relevance scoring (first word of search)\n        $primary_term = $terms[0];\n        $primary_pattern = \"%$primary_term%\";\n        $regex_exact = '\\b' . preg_quote($primary_term, '/') . '\\b';\n        $regex_start = '\\b' . preg_quote($primary_term, '/');\n        $regex_start_of_string = '^' . preg_quote($primary_term, '/');\n        \n        // Build conditions: (col1 LIKE term1 OR col2 LIKE term1 OR ...) AND (col1 LIKE term2 OR ...)\n        $conditions = [];\n        $params = [];\n        $columns = ['a.annotation_description', 'f.feature_name', 'f.feature_description', 'a.annotation_accession'];\n        \n        foreach ($terms as $term) {\n            $term_conditions = implode(' OR ', array_map(function($col) { return \"$col LIKE ?\"; }, $columns));\n            $conditions[] = \"($term_conditions)\";\n            for ($i = 0; $i < count($columns); $i++) {\n                $params[] = \"%$term%\";\n            }\n        }\n        \n        $where_clause = implode(' AND ', $conditions);\n        \n        $query = \"SELECT f.feature_uniquename, f.feature_name, f.feature_description, \n                         a.annotation_accession, a.annotation_description, \n                         fa.score, fa.date, ans.annotation_source_name, \n                         o.genus, o.species, o.common_name, o.subtype, f.feature_type, f.organism_id,\n                         g.genome_accession\n                  FROM annotation a, feature f, feature_annotation fa, annotation_source ans, organism o, genome g\n                  WHERE ans.annotation_source_id = a.annotation_source_id \n                    AND f.feature_id = fa.feature_id \n                    AND fa.annotation_id = a.annotation_id \n                    AND f.organism_id = o.organism_id\n                    AND f.genome_id = g.genome_id\n                    AND $where_clause\";\n        \n        // Add assembly filter if specified\n        if (!empty($assembly_accession)) {\n            $query .= \" AND g.genome_accession = ?\";\n            $params[] = $assembly_accession;\n        }\n        \n        // Add source filter if specified (exact match with IN)\n        if (!empty($source_filter)) {\n            $placeholders = implode(',', array_fill(0, count($source_filter), '?'));\n            $query .= \" AND ans.annotation_source_name IN ($placeholders)\";\n            $params = array_merge($params, $source_filter);\n        }\n        \n        $query .= \" ORDER BY \n                    CASE \n                      WHEN f.feature_name REGEXP ? THEN 1\n                      WHEN f.feature_name REGEXP ? THEN 2\n                      WHEN f.feature_description REGEXP ? THEN 3\n                      WHEN f.feature_description REGEXP ? THEN 4\n                      WHEN f.feature_description LIKE ? THEN 5\n                      WHEN a.annotation_description REGEXP ? THEN 6\n                      ELSE 7\n                    END,\n                    f.feature_uniquename\";\n        \n        // Add primary term patterns for CASE statement to params\n        $params[] = $regex_exact;\n        $params[] = $regex_start;\n        $params[] = $regex_start_of_string;\n        $params[] = $regex_start;\n        $params[] = \"%$primary_term%\";\n        $params[] = $regex_exact;\n    }\n    \n    // Use LIMIT+check approach: query for 2501 results to detect if there are more\n    $max_display = 2500;\n    $query .= \" LIMIT \" . ($max_display + 1);\n    \n    try {\n        $dbh = new PDO(\"sqlite:\" . $dbFile);\n        $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n        \n        // Register REGEXP function\n        $dbh->sqliteCreateFunction('REGEXP', function($pattern, $text) {\n            return preg_match('/' . $pattern . '/i', $text) ? 1 : 0;\n        }, 2);\n        \n        $stmt = $dbh->prepare($query);\n        $stmt->execute($params);\n        $all_results = $stmt->fetchAll(PDO::FETCH_ASSOC);\n        \n        $dbh = null;\n        \n        // Check if results were capped\n        $capped = count($all_results) > $max_display;\n        $warning = null;\n        \n        if ($capped) {\n            // We got 2501+ results, so we know it's \"2500+\"\n            $results = array_slice($all_results, 0, $max_display);\n            $warning = \"2,500+ results found. Use Advanced Filter or add more search terms to refine.\";\n        } else {\n            // We got fewer than 2501, so all results are displayed\n            $results = $all_results;\n        }\n        \n        return [\n            'results' => $results,\n            'capped' => $capped,\n            'warning' => $warning\n        ];\n        \n    } catch (PDOException $e) {\n        return [\n            'results' => [],\n            'capped' => false,\n            'warning' => 'Search error: ' . $e->getMessage()\n        ];\n    }\n}",
                    "parameters": [
                        {
                            "name": "search_term",
                            "type": "string",
                            "description": "Search term or phrase"
                        },
                        {
                            "name": "is_quoted_search",
                            "type": "bool",
                            "description": "Whether this is a quoted phrase search"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of matching features with annotations",
                    "internalCalls": [
                        "searchFeaturesAndAnnotations"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 97,
                            "context": "$search_result = searchFeaturesAndAnnotations($search_input, $quoted_search, $db, $source_filter, $assembly);"
                        }
                    ]
                },
                {
                    "name": "searchFeaturesAndAnnotationsLike",
                    "line": 468,
                    "comment": "",
                    "code": "function searchFeaturesAndAnnotationsLike($search_term, $is_quoted_search, $dbFile) {\n    if ($is_quoted_search) {\n        $like_pattern = \"%$search_term%\";\n        $params = [$like_pattern, $like_pattern, $like_pattern, $like_pattern];\n    } else {\n        $terms = array_filter(array_map('trim', preg_split('/\\s+/', $search_term)));\n        if (empty($terms)) {\n            return [];\n        }\n        \n        $conditions = [];\n        $params = [];\n        $columns = ['a.annotation_description', 'f.feature_name', 'f.feature_description', 'a.annotation_accession'];\n        \n        foreach ($terms as $term) {\n            $term_conditions = implode(' OR ', array_map(function($col) { return \"$col LIKE ?\"; }, $columns));\n            $conditions[] = \"($term_conditions)\";\n            for ($i = 0; $i < count($columns); $i++) {\n                $params[] = \"%$term%\";\n            }\n        }\n        $where_clause = implode(' AND ', $conditions);\n    }\n    \n    if ($is_quoted_search) {\n        $query = \"SELECT f.feature_uniquename, f.feature_name, f.feature_description, \n                         a.annotation_accession, a.annotation_description, \n                         fa.score, fa.date, ans.annotation_source_name, \n                         o.genus, o.species, o.common_name, o.subtype, f.feature_type, f.organism_id,\n                         g.genome_accession\n                  FROM annotation a, feature f, feature_annotation fa, annotation_source ans, organism o, genome g\n                  WHERE ans.annotation_source_id = a.annotation_source_id \n                    AND f.feature_id = fa.feature_id \n                    AND fa.annotation_id = a.annotation_id \n                    AND f.organism_id = o.organism_id\n                    AND f.genome_id = g.genome_id\n                    AND (a.annotation_description LIKE ? \n                       OR f.feature_name LIKE ? \n                       OR f.feature_description LIKE ?\n                       OR a.annotation_accession LIKE ?)\n                  ORDER BY f.feature_uniquename\";\n    } else {\n        $query = \"SELECT f.feature_uniquename, f.feature_name, f.feature_description, \n                         a.annotation_accession, a.annotation_description, \n                         fa.score, fa.date, ans.annotation_source_name, \n                         o.genus, o.species, o.common_name, o.subtype, f.feature_type, f.organism_id,\n                         g.genome_accession\n                  FROM annotation a, feature f, feature_annotation fa, annotation_source ans, organism o, genome g\n                  WHERE ans.annotation_source_id = a.annotation_source_id \n                    AND f.feature_id = fa.feature_id \n                    AND fa.annotation_id = a.annotation_id \n                    AND f.organism_id = o.organism_id\n                    AND f.genome_id = g.genome_id\n                    AND $where_clause\n                  ORDER BY f.feature_uniquename\";\n    }\n    \n    return fetchData($query, $dbFile, $params);\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "searchFeaturesAndAnnotationsLike",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "searchFeaturesByUniquenameForSearch",
                    "line": 538,
                    "comment": "/**\n* Search features by uniquename (primary search)\n* Returns only features, not annotations\n* Used as fast path before annotation search\n*\n* @param string $search_term - Search term for uniquename\n* @param string $dbFile - Path to SQLite database\n* @param string $organism_name - Optional: Filter by organism\n* @return array - Array of matching features\n*/",
                    "code": "function searchFeaturesByUniquenameForSearch($search_term, $dbFile, $organism_name = '', $assembly_accession = '') {\n    if ($organism_name) {\n        $query = \"SELECT f.feature_uniquename, f.feature_name, f.feature_description, \n                         o.genus, o.species, o.common_name, o.subtype, f.feature_type, f.organism_id,\n                         g.genome_accession\n                  FROM feature f, organism o, genome g\n                  WHERE f.organism_id = o.organism_id\n                    AND f.genome_id = g.genome_id\n                    AND f.feature_uniquename LIKE ? \n                    AND (o.genus || ' ' || o.species = ?)\";\n        $params = [\"%$search_term%\", $organism_name];\n        \n        // Add assembly filter if specified\n        if (!empty($assembly_accession)) {\n            $query .= \" AND g.genome_accession = ?\";\n            $params[] = $assembly_accession;\n        }\n        \n        $query .= \" ORDER BY f.feature_uniquename\";\n    } else {\n        $query = \"SELECT f.feature_uniquename, f.feature_name, f.feature_description, \n                         o.genus, o.species, o.common_name, o.subtype, f.feature_type, f.organism_id,\n                         g.genome_accession\n                  FROM feature f, organism o, genome g\n                  WHERE f.organism_id = o.organism_id\n                    AND f.genome_id = g.genome_id\n                    AND f.feature_uniquename LIKE ?\";\n        $params = [\"%$search_term%\"];\n        \n        // Add assembly filter if specified\n        if (!empty($assembly_accession)) {\n            $query .= \" AND g.genome_accession = ?\";\n            $params[] = $assembly_accession;\n        }\n        \n        $query .= \" ORDER BY f.feature_uniquename\";\n    }\n    \n    return fetchData($query, $dbFile, $params);\n}",
                    "parameters": [
                        {
                            "name": "search_term",
                            "type": "string",
                            "description": "Search term for uniquename"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Optional: Filter by organism"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of matching features",
                    "internalCalls": [
                        "searchFeaturesByUniquenameForSearch",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 91,
                            "context": "$results = searchFeaturesByUniquenameForSearch($search_input, $db, '', $assembly);"
                        }
                    ]
                },
                {
                    "name": "getAnnotationSources",
                    "line": 587,
                    "comment": "/**\n* Get all annotation sources for an organism with counts\n* Used to populate search help/tutorial\n*\n* @param string $dbFile - Path to SQLite database\n* @return array - Array of sources with name and count\n*/",
                    "code": "function getAnnotationSources($dbFile) {\n    try {\n        $query = \"SELECT DISTINCT \n                         ans.annotation_source_name as name,\n                         COUNT(a.annotation_id) as count\n                  FROM annotation_source ans\n                  LEFT JOIN annotation a ON ans.annotation_source_id = a.annotation_source_id\n                  GROUP BY ans.annotation_source_id\n                  ORDER BY count DESC\";\n        \n        return fetchData($query, $dbFile, []);\n    } catch (Exception $e) {\n        return [];\n    }\n}",
                    "parameters": [
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of sources with name and count",
                    "internalCalls": [
                        "getAnnotationSources",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/get_annotation_sources.php",
                            "line": 39,
                            "context": "$sources = getAnnotationSources($db);"
                        }
                    ]
                },
                {
                    "name": "getAnnotationSourcesByType",
                    "line": 610,
                    "comment": "/**\n* Get annotation sources grouped by type\n* Used to populate advanced search filter modal\n*\n* @param string $dbFile - Path to SQLite database\n* @return array - Grouped sources: {type: [{name, count}, ...], ...}\n*/",
                    "code": "function getAnnotationSourcesByType($dbFile) {\n    try {\n        // Get all sources with their annotation types from the database\n        $query = \"SELECT \n                    ans.annotation_source_name as name,\n                    ans.annotation_type as type,\n                    COUNT(a.annotation_id) as count\n                  FROM annotation_source ans\n                  LEFT JOIN annotation a ON ans.annotation_source_id = a.annotation_source_id\n                  GROUP BY ans.annotation_source_id, ans.annotation_type\n                  ORDER BY ans.annotation_type, COUNT(a.annotation_id) DESC\";\n        \n        $sources_with_types = fetchData($query, $dbFile, []);\n        \n        // Group by annotation_type\n        $grouped = [];\n        foreach ($sources_with_types as $source) {\n            $type = $source['type'];\n            \n            if (!isset($grouped[$type])) {\n                $grouped[$type] = [];\n            }\n            \n            $grouped[$type][] = [\n                'name' => $source['name'],\n                'count' => $source['count']\n            ];\n        }\n        \n        // Load annotation config to get proper ordering\n        global $config;\n        $metadata_path = $config->getPath('metadata_path');\n        $config_file = \"$metadata_path/annotation_config.json\";\n        $annotation_config = loadJsonFile($config_file, []);\n        \n        // Use annotation_type_order from config if available\n        $sorted = [];\n        if (!empty($annotation_config['annotation_type_order'])) {\n            // Add types in the order defined in config\n            foreach ($annotation_config['annotation_type_order'] as $type) {\n                if (isset($grouped[$type])) {\n                    $sorted[$type] = $grouped[$type];\n                }\n            }\n        }\n        \n        // Add any remaining types not in the config order (in case of dynamic types)\n        foreach ($grouped as $type => $sources) {\n            if (!isset($sorted[$type])) {\n                $sorted[$type] = $sources;\n            }\n        }\n        \n        return $sorted;\n        \n    } catch (Exception $e) {\n        return [];\n    }\n}",
                    "parameters": [
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Grouped sources: {type: [{name, count}, ...], ...}",
                    "internalCalls": [
                        "getAnnotationSourcesByType",
                        "fetchData",
                        "loadJsonFile"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/get_annotation_sources_grouped.php",
                            "line": 53,
                            "context": "$source_types = getAnnotationSourcesByType($db);"
                        }
                    ]
                },
                {
                    "name": "getAnnotationTypesFromDB",
                    "line": 681,
                    "comment": "/**\n* Get all annotation types from database with their counts and feature counts\n* Queries annotation_source and feature_annotation tables for:\n*   - Distinct annotation_type values\n*   - Count of annotations per type\n*   - Count of distinct features per type\n*\n* @param string $dbFile - Path to SQLite database\n* @return array - [annotation_type => ['annotation_count' => N, 'feature_count' => M]]\n*                  ordered by feature_count DESC\n*/",
                    "code": "function getAnnotationTypesFromDB($dbFile) {\n    try {\n        $query = \"SELECT DISTINCT ans.annotation_type,\n                         COUNT(DISTINCT a.annotation_id) as annotation_count,\n                         COUNT(DISTINCT fa.feature_id) as feature_count\n                  FROM annotation_source ans\n                  LEFT JOIN annotation a ON ans.annotation_source_id = a.annotation_source_id\n                  LEFT JOIN feature_annotation fa ON a.annotation_id = fa.annotation_id\n                  WHERE ans.annotation_type IS NOT NULL AND ans.annotation_type != ''\n                  GROUP BY ans.annotation_type\n                  ORDER BY feature_count DESC, ans.annotation_type ASC\";\n        \n        $results = fetchData($query, $dbFile, []);\n        \n        $types = [];\n        foreach ($results as $row) {\n            $types[$row['annotation_type']] = [\n                'annotation_count' => (int)$row['annotation_count'],\n                'feature_count' => (int)$row['feature_count']\n            ];\n        }\n        \n        return $types;\n    } catch (Exception $e) {\n        error_log(\"Error getting annotation types from DB: \" . $e->getMessage());\n        return [];\n    }\n}",
                    "parameters": [
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "[annotation_type => ['annotation_count' => N, 'feature_count' => M]]",
                    "internalCalls": [
                        "getAnnotationTypesFromDB",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 90,
                            "context": "$db_types = getAnnotationTypesFromDB($db_file);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/extract_search_helpers.php",
            "count": 12,
            "functions": [
                {
                    "name": "parseOrganismParameter",
                    "line": 29,
                    "comment": "/**\n* Parse organism parameter from various sources and formats\n*\n* Handles multiple input formats:\n* - Array from multi-search context (organisms[])\n* - Single organism from context parameters\n* - Comma-separated string\n*\n* @param string|array $organisms_param - Raw parameter value\n* @param string $context_organism - Optional fallback organism\n* @return array - ['organisms' => [], 'string' => 'comma,separated,list']\n*/",
                    "code": "function parseOrganismParameter($organisms_param, $context_organism = '') {\n    $filter_organisms = [];\n    $filter_organisms_string = '';\n    \n    // First check for array (highest priority - from multi-search)\n    if (is_array($organisms_param)) {\n        $filter_organisms = array_filter($organisms_param);\n        $filter_organisms_string = implode(',', $filter_organisms);\n    } \n    // Then check for single organism context\n    elseif (!empty($context_organism)) {\n        $filter_organisms = [$context_organism];\n        $filter_organisms_string = $context_organism;\n    }\n    // Finally try comma-separated string format\n    else {\n        $filter_organisms_string = trim($organisms_param);\n        if (!empty($filter_organisms_string)) {\n            $filter_organisms = array_map('trim', explode(',', $filter_organisms_string));\n            $filter_organisms = array_filter($filter_organisms);\n        }\n    }\n    \n    return [\n        'organisms' => $filter_organisms,\n        'string' => $filter_organisms_string\n    ];\n}",
                    "parameters": [
                        {
                            "name": "organisms_param",
                            "type": "string|array",
                            "description": "Raw parameter value"
                        },
                        {
                            "name": "context_organism",
                            "type": "string",
                            "description": "Optional fallback organism"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['organisms' => [], 'string' => 'comma,separated,list']",
                    "internalCalls": [
                        "parseOrganismParameter"
                    ],
                    "category": "data-processing",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/blast.php",
                            "line": 54,
                            "context": "$organism_result = parseOrganismParameter($organisms_param, '');"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 64,
                            "context": "$organism_result = parseOrganismParameter($organisms_param, '');"
                        }
                    ]
                },
                {
                    "name": "parseContextParameters",
                    "line": 65,
                    "comment": "/**\n* Extract context parameters from request\n*\n* Checks explicit context_* fields first (highest priority), then regular fields as fallback\n*\n* @return array - ['organism' => '', 'assembly' => '', 'group' => '', 'display_name' => '', 'context_page' => '']\n*/",
                    "code": "function parseContextParameters() {\n    return [\n        'organism' => trim($_GET['context_organism'] ?? $_POST['context_organism'] ?? $_GET['organism'] ?? $_POST['organism'] ?? ''),\n        'assembly' => trim($_GET['context_assembly'] ?? $_POST['context_assembly'] ?? $_GET['assembly'] ?? $_POST['assembly'] ?? ''),\n        'group' => trim($_GET['context_group'] ?? $_POST['context_group'] ?? $_GET['group'] ?? $_POST['group'] ?? ''),\n        'display_name' => trim($_GET['display_name'] ?? $_POST['display_name'] ?? ''),\n        'context_page' => trim($_GET['context_page'] ?? $_POST['context_page'] ?? '')\n    ];\n}",
                    "parameters": [],
                    "returnType": "array",
                    "returnDescription": "['organism' => '', 'assembly' => '', 'group' => '', 'display_name' => '', 'context_page' => '']",
                    "internalCalls": [
                        "parseContextParameters"
                    ],
                    "category": "data-processing",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/blast.php",
                            "line": 45,
                            "context": "$context = parseContextParameters();"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 61,
                            "context": "$context = parseContextParameters();"
                        }
                    ]
                },
                {
                    "name": "parseFeatureIds",
                    "line": 84,
                    "comment": "/**\n* Parse and validate feature IDs from user input\n*\n* Handles both comma and newline separated formats\n* Detects range patterns (ID:1..10, ID:1-10, ID 1..10, ID 1-10) and returns them separately\n*\n* @param string $uniquenames_string - Comma or newline separated IDs with optional ranges\n* @return array - ['valid' => bool, 'uniquenames' => [], 'ranges' => [], 'has_ranges' => bool, 'error' => '']\n*/",
                    "code": "function parseFeatureIds($uniquenames_string) {\n    $uniquenames = [];\n    $ranges = [];\n    \n    if (empty($uniquenames_string)) {\n        return ['valid' => false, 'uniquenames' => [], 'ranges' => [], 'has_ranges' => false, 'error' => 'No feature IDs provided'];\n    }\n    \n    // Handle both comma and newline separated formats\n    $entries = array_filter(array_map('trim', \n        preg_split('/[\\n,]+/', $uniquenames_string)\n    ));\n    \n    if (empty($entries)) {\n        return ['valid' => false, 'uniquenames' => [], 'ranges' => [], 'has_ranges' => false, 'error' => 'No valid feature IDs found'];\n    }\n    \n    // Process each entry to detect range patterns\n    // Patterns: \"ID:1..10\", \"ID:1-10\", \"ID 1..10\", \"ID 1-10\"\n    foreach ($entries as $entry) {\n        // Check for range patterns\n        if (preg_match('/^(.+?)[\\s:]+(\\d+)[.\\-]\\.?(\\d+)$/', $entry, $matches)) {\n            $id = trim($matches[1]);\n            $start = $matches[2];\n            $end = $matches[3];\n            \n            // Validate range (start should be <= end)\n            if ((int)$start <= (int)$end) {\n                // Store in format expected by blastdbcmd: \"ID:start-end\"\n                $ranges[] = \"$id:$start-$end\";\n                $uniquenames[] = $id;\n            } else {\n                // Invalid range, skip or treat as error\n                continue;\n            }\n        } else {\n            // Regular ID without range\n            $uniquenames[] = $entry;\n        }\n    }\n    \n    $uniquenames = array_unique($uniquenames);\n    \n    if (empty($uniquenames)) {\n        return ['valid' => false, 'uniquenames' => [], 'ranges' => [], 'has_ranges' => false, 'error' => 'No valid feature IDs found'];\n    }\n    \n    return [\n        'valid' => true, \n        'uniquenames' => array_values($uniquenames), \n        'ranges' => $ranges,\n        'has_ranges' => !empty($ranges),\n        'error' => ''\n    ];\n}",
                    "parameters": [
                        {
                            "name": "uniquenames_string",
                            "type": "string",
                            "description": "Comma or newline separated IDs with optional ranges"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['valid' => bool, 'uniquenames' => [], 'ranges' => [], 'has_ranges' => bool, 'error' => '']",
                    "internalCalls": [
                        "parseFeatureIds"
                    ],
                    "category": "data-processing",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/retrieve_selected_sequences.php",
                            "line": 86,
                            "context": "$id_parse = parseFeatureIds($uniquenames_string);"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 130,
                            "context": "$id_parse = parseFeatureIds($uniquenames_string);"
                        }
                    ]
                },
                {
                    "name": "extractSequencesForAllTypes",
                    "line": 154,
                    "comment": "/**\n* Extract sequences for all available types from BLAST database\n*\n* Iterates through all sequence types and extracts for the given feature IDs\n* Supports range notation for subsequence extraction\n*\n* @param string $assembly_dir - Path to assembly directory\n* @param array $uniquenames - Feature IDs to extract\n* @param array $sequence_types - Available sequence type configurations (from site_config)\n* @param string $organism - Organism name (for parent/child database lookup)\n* @param string $assembly - Assembly name (for parent/child database lookup)\n* @param array $ranges - Optional array of range strings (\"ID:start-end\") for subsequence extraction\n* @return array - ['success' => bool, 'content' => [...], 'errors' => []]\n*/",
                    "code": "function extractSequencesForAllTypes($assembly_dir, $uniquenames, $sequence_types, $organism = '', $assembly = '', $ranges = [], $original_input_ids = [], $parent_to_children = []) {\n    $displayed_content = [];\n    $errors = [];\n    \n    foreach ($sequence_types as $seq_type => $config) {\n        $files = glob(\"$assembly_dir/*{$config['pattern']}\");\n        \n        if (!empty($files)) {\n            $fasta_file = $files[0];\n            $extract_result = extractSequencesFromBlastDb($fasta_file, $uniquenames, $organism, $assembly, $ranges, $original_input_ids, $parent_to_children);\n            \n            if ($extract_result['success']) {\n                // Remove blank lines\n                $lines = explode(\"\\n\", $extract_result['content']);\n                $lines = array_filter($lines, function($line) {\n                    return trim($line) !== '';\n                });\n                $displayed_content[$seq_type] = implode(\"\\n\", $lines);\n            } else {\n                $errors[] = \"Failed to extract $seq_type sequences\";\n            }\n        }\n    }\n    \n    // Only report \"no sequences found\" errors if we got no content at all\n    if (empty($displayed_content)) {\n        foreach ($sequence_types as $seq_type => $config) {\n            $files = glob(\"$assembly_dir/*{$config['pattern']}\");\n            if (!empty($files)) {\n                $fasta_file = $files[0];\n                $extract_result = extractSequencesFromBlastDb($fasta_file, $uniquenames, $organism, $assembly, $ranges, $original_input_ids, $parent_to_children);\n                if (!empty($extract_result['error'])) {\n                    $errors[] = $extract_result['error'];\n                    break;\n                }\n            }\n        }\n    }\n    \n    return [\n        'success' => !empty($displayed_content),\n        'content' => $displayed_content,\n        'errors' => $errors\n    ];\n}",
                    "parameters": [
                        {
                            "name": "assembly_dir",
                            "type": "string",
                            "description": "Path to assembly directory"
                        },
                        {
                            "name": "uniquenames",
                            "type": "array",
                            "description": "Feature IDs to extract"
                        },
                        {
                            "name": "sequence_types",
                            "type": "array",
                            "description": "Available sequence type configurations (from site_config)"
                        },
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Organism name (for parent/child database lookup)"
                        },
                        {
                            "name": "assembly",
                            "type": "string",
                            "description": "Assembly name (for parent/child database lookup)"
                        },
                        {
                            "name": "ranges",
                            "type": "array",
                            "description": "Optional array of range strings (\"ID:start-end\") for subsequence extraction"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['success' => bool, 'content' => [...], 'errors' => []]",
                    "internalCalls": [
                        "extractSequencesForAllTypes",
                        "extractSequencesFromBlastDb"
                    ],
                    "category": "data-processing",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 215,
                            "context": "$extract_result = extractSequencesForAllTypes($assembly_dir, $feature_ids, $sequence_types, $organism_name, $genome_accession);"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_selected_sequences.php",
                            "line": 111,
                            "context": "$extract_result = extractSequencesForAllTypes($assembly_dir, $uniquenames, $sequence_types);"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 232,
                            "context": "$extract_result = extractSequencesForAllTypes($fasta_source['path'], $uniquenames, $sequence_types, $selected_organism, $selected_assembly_accession, $ranges, $original_uniquenames ?? [], $parent_to_children ?? []);"
                        }
                    ]
                },
                {
                    "name": "formatSequenceResults",
                    "line": 209,
                    "comment": "/**\n* Format extracted sequences for display component\n*\n* Converts extracted content into format expected by sequences_display.php\n*\n* @param array $displayed_content - Extracted sequences by type\n* @param array $sequence_types - Type configurations (from site_config)\n* @return array - Formatted for sequences_display.php inclusion\n*/",
                    "code": "function formatSequenceResults($displayed_content, $sequence_types) {\n    $available_sequences = [];\n    \n    foreach ($displayed_content as $seq_type => $content) {\n        \n        // Parse FASTA content into individual sequences by ID\n        $sequences = [];\n        if (!empty($content)) {\n            $current_id = null;\n            $current_seq = [];\n            $lines = explode(\"\\n\", $content);\n            \n            foreach ($lines as $line) {\n                if (strpos($line, '>') === 0) {\n                    // Header line\n                    if (!is_null($current_id)) {\n                        // Store previous sequence with full FASTA format (including >)\n                        $sequences[$current_id] = implode(\"\\n\", array_merge([\">\" . $current_id], $current_seq));\n                    }\n                    // Extract ID from header (remove leading '>')\n                    $current_id = substr($line, 1);\n                    $current_seq = [];\n                } else if (!empty($line)) {\n                    // Sequence line (skip empty lines)\n                    $current_seq[] = $line;\n                }\n            }\n            \n            // Store last sequence with full FASTA format\n            if (!is_null($current_id)) {\n                $sequences[$current_id] = implode(\"\\n\", array_merge([\">\" . $current_id], $current_seq));\n            }\n        }\n        \n        foreach ($sequences as $id => $seq_content) {\n            $first_line = explode(\"\\n\", $seq_content)[0];\n        }\n        \n        $available_sequences[$seq_type] = [\n            'label' => $sequence_types[$seq_type]['label'] ?? ucfirst($seq_type),\n            'sequences' => $sequences\n        ];\n    }\n    \n    return $available_sequences;\n}",
                    "parameters": [
                        {
                            "name": "displayed_content",
                            "type": "array",
                            "description": "Extracted sequences by type"
                        },
                        {
                            "name": "sequence_types",
                            "type": "array",
                            "description": "Type configurations (from site_config)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Formatted for sequences_display.php inclusion",
                    "internalCalls": [
                        "formatSequenceResults"
                    ],
                    "category": "ui",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/retrieve_selected_sequences.php",
                            "line": 152,
                            "context": "'available_sequences' => !empty($displayed_content) ? formatSequenceResults($displayed_content, $sequence_types) : [],"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 302,
                            "context": "'available_sequences' => !empty($displayed_content) ? formatSequenceResults($displayed_content, $sequence_types) : [],"
                        }
                    ]
                },
                {
                    "name": "sendFileDownload",
                    "line": 266,
                    "comment": "/**\n* Send file download response and exit\n*\n* Sets appropriate headers and outputs file content\n* Should be called before any HTML output\n*\n* @param string $content - File content to download\n* @param string $sequence_type - Type of sequence (for filename)\n* @param string $file_format - Format (fasta or txt)\n*/",
                    "code": "function sendFileDownload($content, $sequence_type, $file_format = 'fasta') {\n    $ext = ($file_format === 'txt') ? 'txt' : 'fasta';\n    $filename = \"sequences_{$sequence_type}_\" . date(\"Y-m-d_His\") . \".{$ext}\";\n    \n    header('Content-Type: application/octet-stream');\n    header(\"Content-Disposition: attachment; filename={$filename}\");\n    header('Content-Length: ' . strlen($content));\n    echo $content;\n    exit;\n}",
                    "parameters": [
                        {
                            "name": "content",
                            "type": "string",
                            "description": "File content to download"
                        },
                        {
                            "name": "sequence_type",
                            "type": "string",
                            "description": "Type of sequence (for filename)"
                        },
                        {
                            "name": "file_format",
                            "type": "string",
                            "description": "Format (fasta or txt)"
                        }
                    ],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "sendFileDownload"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/extract_search_helpers.php",
                            "line": 405,
                            "context": "sendFileDownload($fasta_content, $sequence_type, $file_format);"
                        }
                    ]
                },
                {
                    "name": "buildFilteredSourcesList",
                    "line": 286,
                    "comment": "/**\n* Build organism-filtered list of accessible assembly sources\n*\n* Filters nested sources array by organism list\n*\n* @param array $sources_by_group - Nested array from getAccessibleAssemblies()\n* @param array $filter_organisms - Optional organism filter list\n* @return array - Nested array [group][organism][...assemblies]\n*/",
                    "code": "function buildFilteredSourcesList($sources_by_group, $filter_organisms = []) {\n    $filtered = [];\n    \n    foreach ($sources_by_group as $group_name => $organisms) {\n        foreach ($organisms as $organism => $assemblies) {\n            // Skip if organism filter is set and this organism is not in it\n            if (!empty($filter_organisms) && !in_array($organism, $filter_organisms)) {\n                continue;\n            }\n            \n            if (!isset($filtered[$group_name])) {\n                $filtered[$group_name] = [];\n            }\n            $filtered[$group_name][$organism] = $assemblies;\n        }\n    }\n    \n    return $filtered;\n}",
                    "parameters": [
                        {
                            "name": "sources_by_group",
                            "type": "array",
                            "description": "Nested array from getAccessibleAssemblies()"
                        },
                        {
                            "name": "filter_organisms",
                            "type": "array",
                            "description": "Optional organism filter list"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Nested array [group][organism][...assemblies]",
                    "internalCalls": [
                        "buildFilteredSourcesList"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "flattenSourcesList",
                    "line": 315,
                    "comment": "/**\n* Flatten nested sources array for sequential processing\n*\n* Converts nested [group][organism][...sources] structure to flat list\n* Useful for iterating all sources without nested loops\n*\n* @param array $sources_by_group - Nested array from getAccessibleAssemblies()\n* @return array - Flat list of all sources\n*/",
                    "code": "function flattenSourcesList($sources_by_group) {\n    $accessible_sources = [];\n    \n    foreach ($sources_by_group as $group => $organisms) {\n        foreach ($organisms as $org => $assemblies) {\n            $accessible_sources = array_merge($accessible_sources, $assemblies);\n        }\n    }\n    \n    return $accessible_sources;\n}",
                    "parameters": [
                        {
                            "name": "sources_by_group",
                            "type": "array",
                            "description": "Nested array from getAccessibleAssemblies()"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Flat list of all sources",
                    "internalCalls": [
                        "flattenSourcesList"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/blast.php",
                            "line": 50,
                            "context": "$accessible_sources = flattenSourcesList($sources_by_group);"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 71,
                            "context": "$accessible_sources = flattenSourcesList($sources_by_group);"
                        }
                    ]
                },
                {
                    "name": "assignGroupColors",
                    "line": 336,
                    "comment": "/**\n* Assign Bootstrap colors to groups for consistent UI display\n*\n* Uses Bootstrap color palette cyclically across groups\n* Same group always gets same color (idempotent)\n*\n* @param array $sources_by_group - Groups to assign colors to\n* @return array - [group_name => bootstrap_color]\n*/",
                    "code": "function assignGroupColors($sources_by_group) {\n    $group_colors = ['primary', 'success', 'info', 'warning', 'danger', 'secondary', 'dark'];\n    $group_color_map = [];\n    \n    foreach ($sources_by_group as $group_name => $organisms) {\n        if (!isset($group_color_map[$group_name])) {\n            $group_color_map[$group_name] = $group_colors[count($group_color_map) % count($group_colors)];\n        }\n    }\n    \n    return $group_color_map;\n}",
                    "parameters": [
                        {
                            "name": "sources_by_group",
                            "type": "array",
                            "description": "Groups to assign colors to"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "[group_name => bootstrap_color]",
                    "internalCalls": [
                        "assignGroupColors"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "getAvailableSequenceTypesForDisplay",
                    "line": 359,
                    "comment": "/**\n* Get available sequence types from all accessible sources\n*\n* Scans assembly directories to determine which sequence types are available\n* Useful for populating UI dropdowns/display options\n*\n* @param array $accessible_sources - Flattened list of sources\n* @param array $sequence_types - Type configurations (from site_config)\n* @return array - [type => label] for types that have available files\n*/",
                    "code": "function getAvailableSequenceTypesForDisplay($accessible_sources, $sequence_types) {\n    $available_types = [];\n    \n    foreach ($accessible_sources as $source) {\n        foreach ($sequence_types as $seq_type => $config) {\n            $files = glob($source['path'] . \"/*{$config['pattern']}\");\n            if (!empty($files)) {\n                $available_types[$seq_type] = $config['label'];\n            }\n        }\n    }\n    \n    return $available_types;\n}",
                    "parameters": [
                        {
                            "name": "accessible_sources",
                            "type": "array",
                            "description": "Flattened list of sources"
                        },
                        {
                            "name": "sequence_types",
                            "type": "array",
                            "description": "Type configurations (from site_config)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "[type => label] for types that have available files",
                    "internalCalls": [
                        "getAvailableSequenceTypesForDisplay"
                    ],
                    "category": "ui",
                    "tags": [
                        "readonly",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 277,
                            "context": "$available_types = getAvailableSequenceTypesForDisplay($accessible_sources, $sequence_types);"
                        }
                    ]
                },
                {
                    "name": "handleSequenceDownload",
                    "line": 386,
                    "comment": "/**\n* Handle sequence download request\n*\n* Checks for download flag and sends file if conditions are met.\n* Works with both array-based sequences (from extractSequencesFromFasta)\n* and string-based sequences (from extractSequencesForAllTypes).\n*\n* @param bool $download_flag - Whether download was requested\n* @param string $sequence_type - The sequence type to download\n* @param array|string $sequence_data - Either array of sequences or a string\n* @return bool - True if download was sent and script exited, false otherwise\n*/",
                    "code": "function handleSequenceDownload($download_flag, $sequence_type, $sequence_data) {\n    if (!$download_flag || empty($sequence_type)) {\n        return false;\n    }\n    \n    // Handle both formats: array (from extractSequencesFromFasta) and string (from extractSequencesForAllTypes)\n    $fasta_content = '';\n    if (is_array($sequence_data)) {\n        // Array format: feature_id => content\n        if (!empty($sequence_data)) {\n            $fasta_content = implode(\"\\n\", $sequence_data);\n        }\n    } else if (is_string($sequence_data)) {\n        // String format: already combined FASTA content\n        $fasta_content = $sequence_data;\n    }\n    \n    if (!empty($fasta_content)) {\n        $file_format = $_POST['file_format'] ?? 'fasta';\n        sendFileDownload($fasta_content, $sequence_type, $file_format);\n        exit;\n    }\n    \n    return false;\n}",
                    "parameters": [
                        {
                            "name": "download_flag",
                            "type": "bool",
                            "description": "Whether download was requested"
                        },
                        {
                            "name": "sequence_type",
                            "type": "string",
                            "description": "The sequence type to download"
                        },
                        {
                            "name": "sequence_data",
                            "type": "array|string",
                            "description": "Either array of sequences or a string"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "True if download was sent and script exited, false otherwise",
                    "internalCalls": [
                        "handleSequenceDownload",
                        "sendFileDownload"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 4,
                    "usages": [
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 223,
                            "context": "handleSequenceDownload($download_file_flag, $sequence_type, $displayed_content[$sequence_type]);"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_selected_sequences.php",
                            "line": 120,
                            "context": "handleSequenceDownload($download_file_flag, $sequence_type, $displayed_content[$sequence_type] ?? null);"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 273,
                            "context": "handleSequenceDownload($download_file_flag, $sequence_type, $displayed_content[$sequence_type] ?? null);"
                        },
                        {
                            "file": "/data/moop/tools/sequences_display.php",
                            "line": 155,
                            "context": "handleSequenceDownload($download_file_flag, $sequence_type, $available_sequences[$sequence_type]['sequences']);"
                        }
                    ]
                },
                {
                    "name": "determineSelectedSource",
                    "line": 428,
                    "comment": "/**\n* Determine selected source (organism/assembly) based on URL/POST parameters\n*\n* Selection priority (highest to lowest):\n* 1. Explicit assembly parameter\n* 2. Explicit organism parameter\n* 3. Group parameter (select first organism from group)\n* 4. Organisms filter list (select first organism)\n*\n* @param array $context - Context parameters [organism, assembly, group, display_name, context_page]\n* @param array $filter_organisms - Pre-filtered list of organisms (from organisms[] or group)\n* @param array $accessible_sources - Flat list of all accessible sources\n* @param string $selected_organism - Optional pre-selected organism (input/output)\n* @param string $selected_assembly_accession - Optional pre-selected assembly (input/output)\n* @return array - ['selected_source' => 'org|assembly', 'selected_organism' => 'org', 'selected_assembly_accession' => 'accession', 'selected_assembly_name' => 'name']\n*/",
                    "code": "function determineSelectedSource($context, $filter_organisms, $accessible_sources, $selected_organism = '', $selected_assembly_accession = '') {\n    $result = [\n        'selected_source' => '',\n        'selected_organism' => $selected_organism,\n        'selected_assembly_accession' => $selected_assembly_accession,\n        'selected_assembly_name' => ''\n    ];\n    \n    // Case 1: Both organism and assembly explicitly specified\n    if (!empty($selected_organism) && !empty($selected_assembly_accession)) {\n        $result['selected_source'] = $selected_organism . '|' . $selected_assembly_accession;\n        return $result;\n    }\n    \n    // Case 2: Only organism specified (select its first assembly)\n    if (!empty($selected_organism)) {\n        foreach ($accessible_sources as $source) {\n            if ($source['organism'] === $selected_organism) {\n                $result['selected_source'] = $selected_organism . '|' . $source['assembly'];\n                $result['selected_assembly_accession'] = $source['assembly'];\n                $result['selected_assembly_name'] = $source['genome_name'] ?? $source['assembly'];\n                return $result;\n            }\n        }\n    }\n    \n    // Case 3: Group specified (select first organism from group, then its first assembly)\n    if (!empty($context['group']) && !empty($filter_organisms)) {\n        $first_organism = reset($filter_organisms);\n        foreach ($accessible_sources as $source) {\n            if ($source['organism'] === $first_organism && in_array($context['group'], $source['groups'] ?? [])) {\n                $result['selected_source'] = $first_organism . '|' . $source['assembly'];\n                $result['selected_organism'] = $first_organism;\n                $result['selected_assembly_accession'] = $source['assembly'];\n                $result['selected_assembly_name'] = $source['genome_name'] ?? $source['assembly'];\n                return $result;\n            }\n        }\n    }\n    \n    // Case 4: Organisms filter list specified (select first organism, then its first assembly)\n    if (!empty($filter_organisms)) {\n        $first_organism = reset($filter_organisms);\n        foreach ($accessible_sources as $source) {\n            if ($source['organism'] === $first_organism) {\n                $result['selected_source'] = $first_organism . '|' . $source['assembly'];\n                $result['selected_organism'] = $first_organism;\n                $result['selected_assembly_accession'] = $source['assembly'];\n                $result['selected_assembly_name'] = $source['genome_name'] ?? $source['assembly'];\n                return $result;\n            }\n        }\n    }\n    \n    // No selection could be determined\n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "context",
                            "type": "array",
                            "description": "Context parameters [organism, assembly, group, display_name, context_page]"
                        },
                        {
                            "name": "filter_organisms",
                            "type": "array",
                            "description": "Pre-filtered list of organisms (from organisms[] or group)"
                        },
                        {
                            "name": "accessible_sources",
                            "type": "array",
                            "description": "Flat list of all accessible sources"
                        },
                        {
                            "name": "selected_organism",
                            "type": "string",
                            "description": "Optional pre-selected organism (input/output)"
                        },
                        {
                            "name": "selected_assembly_accession",
                            "type": "string",
                            "description": "Optional pre-selected assembly (input/output)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['selected_source' => 'org|assembly', 'selected_organism' => 'org', 'selected_assembly_accession' => 'accession', 'selected_assembly_name' => 'name']",
                    "internalCalls": [
                        "determineSelectedSource"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/includes/source-selector-helpers.php",
                            "line": 135,
                            "context": "$selection_result = determineSelectedSource("
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_access.php",
            "count": 7,
            "functions": [
                {
                    "name": "getAssemblyInfo",
                    "line": 15,
                    "comment": "/**\n* Get assembly information from database\n* Queries the organism.sqlite database to get genome_id and genome_name for an assembly\n*\n* @param string $assembly - Assembly accession\n* @param string $db_path - Path to organism.sqlite database\n* @return array - [genome_id, genome_name, genome_accession] or [null, null, $assembly] on error\n*/",
                    "code": "function getAssemblyInfo($assembly, $db_path) {\n    $genome_id = null;\n    $genome_name = null;\n    $genome_accession = $assembly;\n    \n    if (!file_exists($db_path)) {\n        return [$genome_id, $genome_name, $genome_accession];\n    }\n    \n    try {\n        $query = \"SELECT genome_id, genome_name, genome_accession FROM genome WHERE genome_accession = ? OR genome_name = ?\";\n        $results = fetchData($query, $db_path, [$assembly, $assembly]);\n        if (!empty($results)) {\n            $genome_id = $results[0]['genome_id'];\n            $genome_name = $results[0]['genome_name'];\n            $genome_accession = $results[0]['genome_accession'];\n        }\n    } catch (Exception $e) {\n        // If query fails, return defaults\n    }\n    \n    return [$genome_id, $genome_name, $genome_accession];\n}",
                    "parameters": [
                        {
                            "name": "assembly",
                            "type": "string",
                            "description": "Assembly accession"
                        },
                        {
                            "name": "db_path",
                            "type": "string",
                            "description": "Path to organism.sqlite database"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "[genome_id, genome_name, genome_accession] or [null, null, $assembly] on error",
                    "internalCalls": [
                        "getAssemblyInfo",
                        "fetchData"
                    ],
                    "category": "security",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_access.php",
                            "line": 67,
                            "context": "[$genome_id_param, $genome_name_param, $genome_accession_param] = getAssemblyInfo($assembly, $db_path);"
                        },
                        {
                            "file": "/data/moop/tools/pages/assembly.php",
                            "line": 136,
                            "context": "list($genome_id, $genome_name, $genome_accession) = getAssemblyInfo($assembly_accession, $db_path);"
                        }
                    ]
                },
                {
                    "name": "resolveSourceSelection",
                    "line": 49,
                    "comment": "/**\n* Resolve source selection from organism and assembly parameters\n* Handles both genome_name and genome_accession formats\n* Returns the correct selected_source string for pre-selecting radio buttons\n*\n* @param string $organism Organism name\n* @param string $assembly Assembly (could be genome_name or genome_accession)\n* @param array $accessible_sources Flattened list of sources with genome_id, genome_name, etc.\n* @return string Selected source in format \"organism|assembly_dir\" or empty string if not found\n*/",
                    "code": "function resolveSourceSelection($organism, $assembly, $accessible_sources) {\n    // Try direct matches first: assembly dir, genome_name, or genome_id\n    foreach ($accessible_sources as $source) {\n        if ($source['organism'] === $organism) {\n            if ($source['assembly'] === $assembly || \n                $source['genome_name'] === $assembly ||\n                $source['genome_id'] === $assembly) {\n                return $organism . '|' . $source['assembly'];\n            }\n        }\n    }\n    \n    // If not found by direct match, try via database lookup\n    $config = ConfigManager::getInstance();\n    $organism_data = $config->getPath('organism_data');\n    \n    try {\n        $db_path = \"$organism_data/$organism/organism.sqlite\";\n        [$genome_id_param, $genome_name_param, $genome_accession_param] = getAssemblyInfo($assembly, $db_path);\n        \n        // Try matching by resolved genome_name\n        if (!empty($genome_name_param)) {\n            foreach ($accessible_sources as $source) {\n                if ($source['organism'] === $organism && $source['genome_name'] === $genome_name_param) {\n                    return $organism . '|' . $source['assembly'];\n                }\n            }\n        }\n    } catch (Exception $e) {\n        // If lookup fails, return empty\n    }\n    \n    return '';\n}",
                    "parameters": [
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "assembly",
                            "type": "string",
                            "description": "Assembly (could be genome_name or genome_accession)"
                        },
                        {
                            "name": "accessible_sources",
                            "type": "array",
                            "description": "Flattened list of sources with genome_id, genome_name, etc."
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Selected source in format \"organism|assembly_dir\" or empty string if not found",
                    "internalCalls": [
                        "resolveSourceSelection",
                        "getAssemblyInfo"
                    ],
                    "category": "security",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "getAccessibleAssemblies",
                    "line": 92,
                    "comment": "/**\n* Get assemblies accessible to current user\n* Filters assemblies based on user access level and group membership\n*\n* @param string $specific_organism Optional organism to filter by\n* @param string $specific_assembly Optional assembly to filter by\n* @return array Organized by group -> organism, or assemblies for specific organism/assembly\n*/",
                    "code": "function getAccessibleAssemblies($specific_organism = null, $specific_assembly = null) {\n    $config = ConfigManager::getInstance();\n    $organism_data = $config->getPath('organism_data');\n    $metadata_path = $config->getPath('metadata_path');\n    \n    // Load groups data\n    $groups_data = [];\n    $groups_file = \"$metadata_path/organism_assembly_groups.json\";\n    if (file_exists($groups_file)) {\n        $groups_data = json_decode(file_get_contents($groups_file), true) ?: [];\n    }\n    \n    $accessible_sources = [];\n    \n    // Filter entries based on referrer (specific org/assembly or all)\n    $entries_to_process = $groups_data;\n    \n    if (!empty($specific_organism)) {\n        $entries_to_process = array_filter($groups_data, function($entry) use ($specific_organism) {\n            return $entry['organism'] === $specific_organism;\n        });\n    }\n    \n    if (!empty($specific_assembly)) {\n        $entries_to_process = array_filter($entries_to_process, function($entry) use ($specific_assembly) {\n            return $entry['assembly'] === $specific_assembly;\n        });\n    }\n    \n    // Build list of accessible sources using assembly-based permissions\n    foreach ($entries_to_process as $entry) {\n        $org = $entry['organism'];\n        $assembly = $entry['assembly'];\n        $entry_groups = $entry['groups'] ?? [];\n        \n        // Check if user has access to this specific assembly\n        // 1. ALL/Admin users have access to everything\n        // 2. Public assemblies are accessible to everyone\n        // 3. Collaborators can access assemblies in their $_SESSION['access'] list\n        $access_granted = false;\n        \n        if (has_access('ALL')) {\n            $access_granted = true;\n        } elseif (is_public_assembly($org, $assembly)) {\n            $access_granted = true;\n        } elseif (has_access('Collaborator')) {\n            // Check if user has access to this specific assembly\n            $user_access = get_user_access();\n            if (isset($user_access[$org]) && is_array($user_access[$org]) && in_array($assembly, $user_access[$org])) {\n                $access_granted = true;\n            }\n        }\n        \n        if ($access_granted) {\n            $assembly_path = \"$organism_data/$org/$assembly\";\n            \n            // Only include assembly if directory exists AND has FASTA files\n            if (is_dir($assembly_path)) {\n                // Check if assembly has any FASTA files (protein, transcript, cds, or genome)\n                $has_fasta = false;\n                foreach (['.fa', '.fasta', '.faa', '.nt.fa', '.aa.fa'] as $ext) {\n                    if (glob(\"$assembly_path/*$ext\")) {\n                        $has_fasta = true;\n                        break;\n                    }\n                }\n                \n                if ($has_fasta) {\n                    $db_path = \"$organism_data/$org/organism.sqlite\";\n                    \n                    // Use validateAssemblyDirectories to get the actual directory mapping\n                    $assembly_validation = validateAssemblyDirectories($db_path, \"$organism_data/$org\");\n                    \n                    $genome_id = null;\n                    $genome_name = null;\n                    $genome_accession = null;\n                    $actual_assembly_dir = $assembly;  // Default to the directory name as-is\n                    \n                    // Find matching genome in validation results\n                    if ($assembly_validation && !empty($assembly_validation['genomes'])) {\n                        foreach ($assembly_validation['genomes'] as $genome) {\n                            // Match by either genome_name or genome_accession\n                            if ($genome['genome_name'] === $assembly || $genome['genome_accession'] === $assembly) {\n                                $genome_id = $genome['genome_id'];\n                                $genome_name = $genome['genome_name'];\n                                $genome_accession = $genome['genome_accession'];\n                                $actual_assembly_dir = $genome['directory_found'] ?? $assembly;\n                                break;\n                            }\n                        }\n                    }\n                    \n                    $accessible_sources[] = [\n                        'organism' => $org,\n                        'assembly' => $actual_assembly_dir,  // Use the actual directory name\n                        'genome_name' => $genome_name,\n                        'genome_accession' => $genome_accession,\n                        'path' => \"$organism_data/$org/$actual_assembly_dir\",\n                        'groups' => $entry_groups,\n                        'genome_id' => $genome_id\n                    ];\n                }\n            }\n        }\n    }\n    \n    // Organize by group -> organism\n    $organized = [];\n    foreach ($accessible_sources as $source) {\n        foreach ($source['groups'] as $group) {\n            if (!isset($organized[$group])) {\n                $organized[$group] = [];\n            }\n            $org = $source['organism'];\n            if (!isset($organized[$group][$org])) {\n                $organized[$group][$org] = [];\n            }\n            $organized[$group][$org][] = $source;\n        }\n    }\n    \n    // Sort groups (Public first, then alphabetically)\n    uksort($organized, function($a, $b) {\n        if ($a === 'Public') return -1;\n        if ($b === 'Public') return 1;\n        return strcasecmp($a, $b);\n    });\n    \n    // Sort organisms within each group alphabetically\n    foreach ($organized as &$group_data) {\n        ksort($group_data);\n    }\n    \n    return $organized;\n}",
                    "parameters": [
                        {
                            "name": "specific_organism",
                            "type": "string",
                            "description": "Optional organism to filter by"
                        },
                        {
                            "name": "specific_assembly",
                            "type": "string",
                            "description": "Optional assembly to filter by"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Organized by group -> organism, or assemblies for specific organism/assembly",
                    "internalCalls": [
                        "getAccessibleAssemblies",
                        "validateAssemblyDirectories"
                    ],
                    "category": "security",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "security-related",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/blast.php",
                            "line": 49,
                            "context": "$sources_by_group = getAccessibleAssemblies();"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 70,
                            "context": "$sources_by_group = getAccessibleAssemblies();"
                        }
                    ]
                },
                {
                    "name": "getTaxonomyTreeUserAccess",
                    "line": 235,
                    "comment": "/**\n* Get taxonomy tree user access for display\n* Returns organisms accessible to current user for taxonomy tree display\n*\n* @param array $group_data Array of organism/assembly/groups data\n* @return array Array of accessible organisms with true value\n*/",
                    "code": "function getTaxonomyTreeUserAccess($group_data) {\n    $taxonomy_user_access = [];\n    \n    if (get_access_level() === 'ALL' || get_access_level() === 'Admin') {\n        // Admin gets access to all organisms\n        foreach ($group_data as $data) {\n            $organism = $data['organism'];\n            if (!isset($taxonomy_user_access[$organism])) {\n                $taxonomy_user_access[$organism] = true;\n            }\n        }\n    } elseif (is_logged_in()) {\n        // Logged-in users get their specific access\n        $taxonomy_user_access = get_user_access();\n    } else {\n        // Public users: get organisms in Public group\n        foreach ($group_data as $data) {\n            if (in_array('Public', $data['groups'])) {\n                $organism = $data['organism'];\n                if (!isset($taxonomy_user_access[$organism])) {\n                    $taxonomy_user_access[$organism] = true;\n                }\n            }\n        }\n    }\n    \n    return $taxonomy_user_access;\n}",
                    "parameters": [
                        {
                            "name": "group_data",
                            "type": "array",
                            "description": "Array of organism/assembly/groups data"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of accessible organisms with true value",
                    "internalCalls": [
                        "getTaxonomyTreeUserAccess"
                    ],
                    "category": "security",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/organism.php",
                            "line": 53,
                            "context": "$taxonomy_user_access = getTaxonomyTreeUserAccess($group_data);"
                        },
                        {
                            "file": "/data/moop/index.php",
                            "line": 34,
                            "context": "$taxonomy_user_access = getTaxonomyTreeUserAccess($group_data);"
                        }
                    ]
                },
                {
                    "name": "countOrganismsAtTaxonomyRank",
                    "line": 273,
                    "comment": "/**\n* Count organisms at a specific taxonomy rank that user has access to\n* Traverses the taxonomy tree and counts all organisms under the given rank\n*\n* @param array $tree_node Tree node to search in\n* @param string $rank_name Name of the rank to count (e.g., 'Chordata', 'Mammalia')\n* @param array $user_access User access array (organism_name => true)\n* @return int Count of accessible organisms under this rank\n*/",
                    "code": "function countOrganismsAtTaxonomyRank($tree_node, $rank_name, $user_access) {\n    if (empty($tree_node) || empty($rank_name) || empty($user_access)) {\n        return 0;\n    }\n    \n    $count = 0;\n    \n    $traverse = function($node) use ($rank_name, $user_access, &$count, &$traverse) {\n        // Check if this is the node we're looking for\n        if ($node['name'] === $rank_name) {\n            // Count all organisms under this rank\n            $countOrganisms = function($n) use (&$countOrganisms, $user_access, &$count) {\n                if (isset($n['organism']) && isset($user_access[$n['organism']])) {\n                    $count++;\n                }\n                if (isset($n['children']) && is_array($n['children'])) {\n                    foreach ($n['children'] as $child) {\n                        $countOrganisms($child);\n                    }\n                }\n            };\n            $countOrganisms($node);\n            return;\n        }\n        \n        // Continue traversing down\n        if (isset($node['children']) && is_array($node['children'])) {\n            foreach ($node['children'] as $child) {\n                $traverse($child);\n            }\n        }\n    };\n    \n    $traverse($tree_node);\n    return $count;\n}",
                    "parameters": [
                        {
                            "name": "tree_node",
                            "type": "array",
                            "description": "Tree node to search in"
                        },
                        {
                            "name": "rank_name",
                            "type": "string",
                            "description": "Name of the rank to count (e.g., 'Chordata', 'Mammalia')"
                        },
                        {
                            "name": "user_access",
                            "type": "array",
                            "description": "User access array (organism_name => true)"
                        }
                    ],
                    "returnType": "int",
                    "returnDescription": "Count of accessible organisms under this rank",
                    "internalCalls": [
                        "countOrganismsAtTaxonomyRank"
                    ],
                    "category": "security",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_access.php",
                            "line": 324,
                            "context": "$item['count'] = countOrganismsAtTaxonomyRank($tree_node, $item['name'], $user_access);"
                        }
                    ]
                },
                {
                    "name": "getTaxonomyLineageWithCounts",
                    "line": 318,
                    "comment": "/**\n* Get taxonomy lineage with organism counts at each rank\n*\n* @param array $lineage Array of lineage items with 'rank' and 'name' keys\n* @param array $tree_node Root of taxonomy tree\n* @param array $user_access User access array (organism_name => true)\n* @return array Lineage with added 'count' key for each item\n*/",
                    "code": "function getTaxonomyLineageWithCounts($lineage, $tree_node, $user_access) {\n    if (empty($lineage) || empty($tree_node) || empty($user_access)) {\n        return $lineage;\n    }\n    \n    return array_map(function($item) use ($tree_node, $user_access) {\n        $item['count'] = countOrganismsAtTaxonomyRank($tree_node, $item['name'], $user_access);\n        return $item;\n    }, $lineage);\n}",
                    "parameters": [
                        {
                            "name": "lineage",
                            "type": "array",
                            "description": "Array of lineage items with 'rank' and 'name' keys"
                        },
                        {
                            "name": "tree_node",
                            "type": "array",
                            "description": "Root of taxonomy tree"
                        },
                        {
                            "name": "user_access",
                            "type": "array",
                            "description": "User access array (organism_name => true)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Lineage with added 'count' key for each item",
                    "internalCalls": [
                        "getTaxonomyLineageWithCounts",
                        "countOrganismsAtTaxonomyRank"
                    ],
                    "category": "security",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/organism.php",
                            "line": 161,
                            "context": "$lineage_with_counts = getTaxonomyLineageWithCounts($lineage, $taxonomy_tree_data['tree'], $taxonomy_user_access);"
                        }
                    ]
                },
                {
                    "name": "requireAccess",
                    "line": 339,
                    "comment": "/**\n* Require user to have specific access level or redirect to access denied\n*\n* @param string $level Required access level (e.g., 'Collaborator', 'Admin')\n* @param string $resource Resource name (e.g., group name or organism name)\n* @param array $options Options array with keys:\n*   - redirect_on_deny (bool, default: true) - Redirect to deny page if no access\n*   - deny_page (string, default: /$site/access_denied.php) - URL to redirect to\n* @return bool True if user has access, false otherwise\n*/",
                    "code": "function requireAccess($level, $resource, $options = []) {\n    global $site;\n    \n    $redirect_on_deny = $options['redirect_on_deny'] ?? true;\n    $deny_page = $options['deny_page'] ?? \"/$site/access_denied.php\";\n    \n    $has_access = has_access($level, $resource);\n    \n    if (!$has_access && $redirect_on_deny) {\n        header(\"Location: $deny_page\");\n        exit;\n    }\n    \n    return $has_access;\n}",
                    "parameters": [
                        {
                            "name": "level",
                            "type": "string",
                            "description": "Required access level (e.g., 'Collaborator', 'Admin')"
                        },
                        {
                            "name": "resource",
                            "type": "string",
                            "description": "Resource name (e.g., group name or organism name)"
                        },
                        {
                            "name": "options",
                            "type": "array",
                            "description": "Options array with keys:"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "True if user has access, false otherwise",
                    "internalCalls": [
                        "requireAccess"
                    ],
                    "category": "security",
                    "tags": [
                        "readonly",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/groups.php",
                            "line": 112,
                            "context": "requireAccess('Collaborator', $group_name);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_data.php",
            "count": 24,
            "functions": [
                {
                    "name": "getGroupData",
                    "line": 12,
                    "comment": "/**\n* Get group metadata from organism_assembly_groups.json\n*\n* @return array Array of organism/assembly/groups data\n*/",
                    "code": "function getGroupData() {\n    $config = ConfigManager::getInstance();\n    $metadata_path = $config->getPath('metadata_path');\n    $groups_file = \"$metadata_path/organism_assembly_groups.json\";\n    $groups_data = [];\n    if (file_exists($groups_file)) {\n        $groups_data = json_decode(file_get_contents($groups_file), true);\n    }\n    return $groups_data;\n}",
                    "parameters": [],
                    "returnType": "array",
                    "returnDescription": "Array of organism/assembly/groups data",
                    "internalCalls": [
                        "getGroupData"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 6,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 131,
                            "context": "$group_data = getGroupData();"
                        },
                        {
                            "file": "/data/moop/tools/groups.php",
                            "line": 59,
                            "context": "$group_data = getGroupData();"
                        },
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 77,
                            "context": "$group_data = getGroupData();"
                        },
                        {
                            "file": "/data/moop/tools/organism.php",
                            "line": 52,
                            "context": "$group_data = getGroupData();"
                        },
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 12,
                            "context": "$groups_data = getGroupData();"
                        },
                        {
                            "file": "/data/moop/index.php",
                            "line": 26,
                            "context": "$group_data = getGroupData();"
                        }
                    ]
                },
                {
                    "name": "getAllGroupCards",
                    "line": 30,
                    "comment": "/**\n* Get all group cards from metadata\n* Returns card objects for every group in the system\n*\n* @param array $group_data Array of organism/assembly/groups data\n* @return array Associative array of group_name => card_info\n*/",
                    "code": "function getAllGroupCards($group_data) {\n    $cards = [];\n    foreach ($group_data as $data) {\n        foreach ($data['groups'] as $group) {\n            if (!isset($cards[$group])) {\n                $cards[$group] = [\n                    'title' => $group,\n                    'text' => \"Explore $group Data\",\n                    'link' => 'tools/groups.php?group=' . urlencode($group)\n                ];\n            }\n        }\n    }\n    return $cards;\n}",
                    "parameters": [
                        {
                            "name": "group_data",
                            "type": "array",
                            "description": "Array of organism/assembly/groups data"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Associative array of group_name => card_info",
                    "internalCalls": [
                        "getAllGroupCards"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 307,
                            "context": "$all_cards = getAllGroupCards($group_data);"
                        }
                    ]
                },
                {
                    "name": "getPublicGroupCards",
                    "line": 53,
                    "comment": "/**\n* Get group cards that have at least one public assembly\n* Returns card objects only for groups containing assemblies in the \"Public\" group\n*\n* @param array $group_data Array of organism/assembly/groups data\n* @return array Associative array of group_name => card_info for public groups only\n*/",
                    "code": "function getPublicGroupCards($group_data) {\n    $public_groups = [];\n    \n    // Find all groups that contain at least one public assembly\n    foreach ($group_data as $data) {\n        if (in_array('Public', $data['groups'])) {\n            foreach ($data['groups'] as $group) {\n                if (!isset($public_groups[$group])) {\n                    $public_groups[$group] = [\n                        'title' => $group,\n                        'text' => \"Explore $group Data\",\n                        'link' => 'tools/groups.php?group=' . urlencode($group)\n                    ];\n                }\n            }\n        }\n    }\n    return $public_groups;\n}",
                    "parameters": [
                        {
                            "name": "group_data",
                            "type": "array",
                            "description": "Array of organism/assembly/groups data"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Associative array of group_name => card_info for public groups only",
                    "internalCalls": [
                        "getPublicGroupCards"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 313,
                            "context": "$cards_to_display = getPublicGroupCards($group_data);"
                        },
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 327,
                            "context": "$cards_to_display = getPublicGroupCards($group_data);"
                        }
                    ]
                },
                {
                    "name": "getAccessibleOrganismsInGroup",
                    "line": 81,
                    "comment": "/**\n* Filter organisms in a group to only those with at least one accessible assembly\n* Respects user permissions for assembly access\n*\n* @param string $group_name The group name to filter\n* @param array $group_data Array of organism/assembly/groups data\n* @return array Filtered array of organism => [accessible_assemblies]\n*/",
                    "code": "function getAccessibleOrganismsInGroup($group_name, $group_data) {\n    $group_organisms = [];\n    \n    // Find all organisms/assemblies in this group\n    foreach ($group_data as $data) {\n        if (in_array($group_name, $data['groups'])) {\n            $organism = $data['organism'];\n            $assembly = $data['assembly'];\n            \n            if (!isset($group_organisms[$organism])) {\n                $group_organisms[$organism] = [];\n            }\n            $group_organisms[$organism][] = $assembly;\n        }\n    }\n    \n    // Filter: only keep organisms with at least one accessible assembly\n    $accessible_organisms = [];\n    foreach ($group_organisms as $organism => $assemblies) {\n        $has_accessible_assembly = false;\n        \n        foreach ($assemblies as $assembly) {\n            // Check if user has access to this specific assembly\n            if (has_assembly_access($organism, $assembly)) {\n                $has_accessible_assembly = true;\n                break;\n            }\n        }\n        \n        if ($has_accessible_assembly) {\n            $accessible_organisms[$organism] = $assemblies;\n        }\n    }\n    \n    // Sort organisms alphabetically\n    ksort($accessible_organisms);\n    \n    return $accessible_organisms;\n}",
                    "parameters": [
                        {
                            "name": "group_name",
                            "type": "string",
                            "description": "The group name to filter"
                        },
                        {
                            "name": "group_data",
                            "type": "array",
                            "description": "Array of organism/assembly/groups data"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Filtered array of organism => [accessible_assemblies]",
                    "internalCalls": [
                        "getAccessibleOrganismsInGroup"
                    ],
                    "category": "security",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 152,
                            "context": "$accessible_organisms = getAccessibleOrganismsInGroup($group, $group_data);"
                        },
                        {
                            "file": "/data/moop/tools/groups.php",
                            "line": 107,
                            "context": "$group_organisms = getAccessibleOrganismsInGroup($group_name, $group_data);"
                        }
                    ]
                },
                {
                    "name": "getGroupsForOrganism",
                    "line": 129,
                    "comment": "/**\n* Get all groups that contain a specific organism\n* Returns group info including accessible organism count for each group\n*\n* @param string $organism_name The organism to find groups for\n* @param array $group_data Array of organism/assembly/groups data (optional, will load if not provided)\n* @return array Array of [group_name => ['count' => num_accessible_organisms, 'link' => url]]\n*/",
                    "code": "function getGroupsForOrganism($organism_name, $group_data = null) {\n    if ($group_data === null) {\n        $group_data = getGroupData();\n    }\n    \n    $organism_groups = [];\n    \n    // Find all groups containing this organism\n    foreach ($group_data as $data) {\n        if ($data['organism'] === $organism_name) {\n            foreach ($data['groups'] as $group) {\n                if (!isset($organism_groups[$group])) {\n                    $organism_groups[$group] = [\n                        'count' => 0,\n                        'link' => 'tools/groups.php?group=' . urlencode($group)\n                    ];\n                }\n            }\n        }\n    }\n    \n    // Count accessible organisms in each group\n    foreach ($organism_groups as $group => &$info) {\n        $accessible_organisms = getAccessibleOrganismsInGroup($group, $group_data);\n        $info['count'] = count($accessible_organisms);\n    }\n    \n    // Sort by group name\n    ksort($organism_groups);\n    \n    return $organism_groups;\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "The organism to find groups for"
                        },
                        {
                            "name": "group_data",
                            "type": "array",
                            "description": "Array of organism/assembly/groups data (optional, will load if not provided)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of [group_name => ['count' => num_accessible_organisms, 'link' => url]]",
                    "internalCalls": [
                        "getGroupsForOrganism",
                        "getGroupData",
                        "getAccessibleOrganismsInGroup"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/organism.php",
                            "line": 189,
                            "context": "$organism_groups = getGroupsForOrganism($organism_name, $group_data);"
                        }
                    ]
                },
                {
                    "name": "getOrganismsAtTaxonomyLevel",
                    "line": 171,
                    "comment": "/**\n* Get organisms at a specific taxonomy rank that user has access to\n* Traverses the taxonomy tree to find all organisms under a given taxonomic rank\n*\n* @param string $rank_name Name of the taxonomy rank (e.g., 'Primates', 'Mammalia')\n* @param array $tree_node Root of taxonomy tree\n* @param array $group_data Array of organism/assembly/groups data\n* @return array Array of [organism_name => [assemblies]] filtered by user access\n*/",
                    "code": "function getOrganismsAtTaxonomyLevel($rank_name, $tree_node, $group_data) {\n    if (empty($rank_name) || empty($tree_node) || empty($group_data)) {\n        return [];\n    }\n    \n    $organisms_at_level = [];\n    \n    // Find the rank in the tree and collect all organisms under it\n    $findOrganisms = function($node) use ($rank_name, &$organisms_at_level, &$findOrganisms) {\n        // Check if this is the target rank\n        if ($node['name'] === $rank_name) {\n            // Collect all organisms under this rank\n            $collectOrganisms = function($n) use (&$collectOrganisms, &$organisms_at_level) {\n                if (isset($n['organism'])) {\n                    $organisms_at_level[$n['organism']] = true;\n                }\n                if (isset($n['children']) && is_array($n['children'])) {\n                    foreach ($n['children'] as $child) {\n                        $collectOrganisms($child);\n                    }\n                }\n            };\n            $collectOrganisms($node);\n            return;\n        }\n        \n        // Continue traversing\n        if (isset($node['children']) && is_array($node['children'])) {\n            foreach ($node['children'] as $child) {\n                $findOrganisms($child);\n            }\n        }\n    };\n    \n    $findOrganisms($tree_node);\n    \n    // Now filter by user access and get assemblies\n    $accessible_organisms = [];\n    foreach ($organisms_at_level as $organism => $dummy) {\n        // Find all assemblies for this organism\n        $organism_assemblies = [];\n        foreach ($group_data as $data) {\n            if ($data['organism'] === $organism) {\n                $organism_assemblies[] = $data['assembly'];\n            }\n        }\n        \n        // Check if user has access to at least one assembly\n        $has_accessible_assembly = false;\n        foreach ($organism_assemblies as $assembly) {\n            if (has_assembly_access($organism, $assembly)) {\n                $has_accessible_assembly = true;\n                break;\n            }\n        }\n        \n        if ($has_accessible_assembly) {\n            $accessible_organisms[$organism] = $organism_assemblies;\n        }\n    }\n    \n    // Sort organisms alphabetically\n    ksort($accessible_organisms);\n    \n    return $accessible_organisms;\n}",
                    "parameters": [
                        {
                            "name": "rank_name",
                            "type": "string",
                            "description": "Name of the taxonomy rank (e.g., 'Primates', 'Mammalia')"
                        },
                        {
                            "name": "tree_node",
                            "type": "array",
                            "description": "Root of taxonomy tree"
                        },
                        {
                            "name": "group_data",
                            "type": "array",
                            "description": "Array of organism/assembly/groups data"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of [organism_name => [assemblies]] filtered by user access",
                    "internalCalls": [
                        "getOrganismsAtTaxonomyLevel"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/groups.php",
                            "line": 65,
                            "context": "$group_organisms = getOrganismsAtTaxonomyLevel($taxonomy_rank, $taxonomy_tree_data['tree'], $group_data);"
                        }
                    ]
                },
                {
                    "name": "getAssemblyFastaFiles",
                    "line": 249,
                    "comment": "/**\n* Get FASTA files for an assembly\n*\n* Scans the assembly directory for FASTA files matching configured sequence types.\n* Uses patterns from $sequence_types global to identify file types (genome, protein, transcript, cds).\n* Accepts either assembly accession or directory name.\n*\n* @param string $organism_name The organism name\n* @param string $assembly_name The assembly name (accession or directory name)\n* @return array Associative array of type => ['path' => relative_path, 'label' => label]\n*/",
                    "code": "function getAssemblyFastaFiles($organism_name, $assembly_name) {\n    $config = ConfigManager::getInstance();\n    $organism_data = $config->getPath('organism_data');\n    $sequence_types = $config->getSequenceTypes();\n    $fasta_files = [];\n    $assembly_dir = \"$organism_data/$organism_name/$assembly_name\";\n    \n    // If directory doesn't exist with the provided name, try to find it by querying the database\n    if (!is_dir($assembly_dir)) {\n        $db_path = getOrganismDatabase($organism_name, $organism_data);\n        if (!empty($db_path)) {\n            try {\n                $dbh = new PDO(\"sqlite:\" . $db_path);\n                $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n                \n                // Query by either accession or name\n                $stmt = $dbh->prepare(\"SELECT genome_name FROM genome WHERE genome_accession = ? OR genome_name = ?\");\n                $stmt->execute([$assembly_name, $assembly_name]);\n                $result = $stmt->fetch(PDO::FETCH_ASSOC);\n                \n                if ($result) {\n                    $assembly_dir = \"$organism_data/$organism_name/\" . $result['genome_name'];\n                }\n            } catch (PDOException $e) {\n                // If database query fails, continue with original directory\n            }\n        }\n    }\n    \n    if (is_dir($assembly_dir)) {\n        $fasta_files_found = glob($assembly_dir . '/*.fa');\n        foreach ($fasta_files_found as $fasta_file) {\n            $filename = basename($fasta_file);\n            $relative_path = \"$organism_name/\" . basename($assembly_dir) . \"/$filename\";\n            \n            foreach ($sequence_types as $type => $config) {\n                if (strpos($filename, $config['pattern']) !== false) {\n                    $fasta_files[$type] = [\n                        'path' => $relative_path,\n                        'label' => $config['label'],\n                        'color' => $config['color']\n                    ];\n                    break;\n                }\n            }\n        }\n    }\n    return $fasta_files;\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "The organism name"
                        },
                        {
                            "name": "assembly_name",
                            "type": "string",
                            "description": "The assembly name (accession or directory name)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Associative array of type => ['path' => relative_path, 'label' => label]",
                    "internalCalls": [
                        "getAssemblyFastaFiles",
                        "getOrganismDatabase"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/assembly.php",
                            "line": 138,
                            "context": "$fasta_files = getAssemblyFastaFiles($organism_name, $genome_name);"
                        },
                        {
                            "file": "/data/moop/tools/pages/assembly.php",
                            "line": 141,
                            "context": "$fasta_files = getAssemblyFastaFiles($organism_name, $genome_accession);"
                        }
                    ]
                },
                {
                    "name": "getIndexDisplayCards",
                    "line": 305,
                    "comment": "/**\n* Get cards to display on index page based on user access level\n*\n* @param array $group_data Array of group data from getGroupData()\n* @return array Cards to display with title, text, and link\n*/",
                    "code": "function getIndexDisplayCards($group_data) {\n    $cards_to_display = [];\n    $all_cards = getAllGroupCards($group_data);\n    \n    if (get_access_level() === 'ALL' || get_access_level() === 'Admin') {\n        $cards_to_display = $all_cards;\n    } elseif (is_logged_in()) {\n        // Logged-in users see: public groups + their permitted organisms\n        $cards_to_display = getPublicGroupCards($group_data);\n        \n        foreach (get_user_access() as $organism => $assemblies) {\n            if (!isset($cards_to_display[$organism])) {\n                $formatted_name = formatIndexOrganismName($organism);\n                $cards_to_display[$organism] = [\n                    'title' => $formatted_name,\n                    'text'  => \"Explore \" . strip_tags($formatted_name) . \" Data\",\n                    'link'  => 'tools/organism.php?organism=' . urlencode($organism)\n                ];\n            }\n        }\n    } else {\n        // Visitors see only groups with public assemblies\n        $cards_to_display = getPublicGroupCards($group_data);\n    }\n    \n    return $cards_to_display;\n}",
                    "parameters": [
                        {
                            "name": "group_data",
                            "type": "array",
                            "description": "Array of group data from getGroupData()"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Cards to display with title, text, and link",
                    "internalCalls": [
                        "getIndexDisplayCards",
                        "getAllGroupCards",
                        "getPublicGroupCards",
                        "formatIndexOrganismName"
                    ],
                    "category": "search",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/index.php",
                            "line": 27,
                            "context": "$cards_to_display = getIndexDisplayCards($group_data);"
                        }
                    ]
                },
                {
                    "name": "formatIndexOrganismName",
                    "line": 317,
                    "comment": "/**\n* Format organism name for index page display with italics\n*\n* @param string $organism Organism name with underscores\n* @return string Formatted name with proper capitalization and italics\n*/",
                    "code": "function formatIndexOrganismName($organism) {\n    $parts = explode('_', $organism);\n    $formatted_name = ucfirst(strtolower($parts[0]));\n    for ($i = 1; $i < count($parts); $i++) {\n        $formatted_name .= ' ' . strtolower($parts[$i]);\n    }\n    return '<i>' . $formatted_name . '</i>';\n}",
                    "parameters": [
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Organism name with underscores"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Formatted name with proper capitalization and italics",
                    "internalCalls": [
                        "formatIndexOrganismName"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 317,
                            "context": "$formatted_name = formatIndexOrganismName($organism);"
                        }
                    ]
                },
                {
                    "name": "loadAllOrganismsMetadata",
                    "line": 355,
                    "comment": "/**\n* Load all organisms' JSON metadata from organism_data directory\n* Central function used by manage_organisms.php and manage_taxonomy_tree.php\n*\n* @param string $organism_data_dir Path to organism data directory\n* @return array Associative array of organism_name => metadata\n*/",
                    "code": "function loadAllOrganismsMetadata($organism_data_dir) {\n    $organisms = [];\n    \n    if (!is_dir($organism_data_dir)) {\n        return $organisms;\n    }\n    \n    $entries = scandir($organism_data_dir);\n    foreach ($entries as $organism) {\n        // Skip hidden directories and non-directories\n        if ($organism[0] === '.' || !is_dir(\"$organism_data_dir/$organism\")) {\n            continue;\n        }\n        \n        // Load organism.json using loadJsonFile (from functions_json.php)\n        $organism_json_path = \"$organism_data_dir/$organism/organism.json\";\n        $organism_info = loadJsonFile($organism_json_path);\n        \n        if (!$organism_info) {\n            continue;\n        }\n        \n        // Handle improperly wrapped JSON (extra outer braces)\n        if (!isset($organism_info['genus']) && !isset($organism_info['common_name'])) {\n            $keys = array_keys($organism_info);\n            if (count($keys) > 0 && is_array($organism_info[$keys[0]]) && isset($organism_info[$keys[0]]['genus'])) {\n                $organism_info = $organism_info[$keys[0]];\n            }\n        }\n        \n        // Store organism metadata keyed by organism name\n        $organisms[$organism] = [\n            'genus' => $organism_info['genus'] ?? '',\n            'species' => $organism_info['species'] ?? '',\n            'common_name' => $organism_info['common_name'] ?? '',\n            'taxon_id' => $organism_info['taxon_id'] ?? '',\n            'images' => $organism_info['images'] ?? [],\n            'html_p' => $organism_info['html_p'] ?? []\n        ];\n    }\n    \n    return $organisms;\n}",
                    "parameters": [
                        {
                            "name": "organism_data_dir",
                            "type": "string",
                            "description": "Path to organism data directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Associative array of organism_name => metadata",
                    "internalCalls": [
                        "loadAllOrganismsMetadata",
                        "loadJsonFile"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 683,
                            "context": "$organisms_metadata = loadAllOrganismsMetadata($organism_data_path);"
                        },
                        {
                            "file": "/data/moop/admin/manage_taxonomy_tree.php",
                            "line": 31,
                            "context": "$organisms = loadAllOrganismsMetadata($organism_data_dir);"
                        }
                    ]
                },
                {
                    "name": "getOrganismsWithAssemblies",
                    "line": 409,
                    "comment": "/**\n* Get all organisms with their assemblies from filesystem\n*\n* Scans the organism data directory and returns a map of organisms to their assemblies.\n* Used for user permission management and group configuration.\n* Note: Database may have different/cached info - use this for filesystem truth.\n*\n* @param string $organism_data_path Path to organism data directory\n* @return array Associative array of organism_name => array of assembly names\n*/",
                    "code": "function getOrganismsWithAssemblies($organism_data_path) {\n    $orgs = [];\n    \n    if (!is_dir($organism_data_path)) {\n        return $orgs;\n    }\n    \n    $organisms = scandir($organism_data_path);\n    foreach ($organisms as $organism) {\n        if ($organism[0] === '.' || !is_dir(\"$organism_data_path/$organism\")) {\n            continue;\n        }\n        \n        $assemblies = [];\n        $assemblyPath = \"$organism_data_path/$organism\";\n        $files = scandir($assemblyPath);\n        foreach ($files as $file) {\n            if ($file[0] === '.' || !is_dir(\"$assemblyPath/$file\")) {\n                continue;\n            }\n            $assemblies[] = $file;\n        }\n        $orgs[$organism] = $assemblies;\n    }\n    return $orgs;\n}",
                    "parameters": [
                        {
                            "name": "organism_data_path",
                            "type": "string",
                            "description": "Path to organism data directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Associative array of organism_name => array of assembly names",
                    "internalCalls": [
                        "getOrganismsWithAssemblies"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 83,
                            "context": "$organisms = getOrganismsWithAssemblies($organisms_path);"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 56,
                            "context": "$all_organisms = getOrganismsWithAssemblies($organism_data_path);"
                        },
                        {
                            "file": "/data/moop/admin/manage_users.php",
                            "line": 27,
                            "context": "$organisms = getOrganismsWithAssemblies($organism_data_path);"
                        }
                    ]
                },
                {
                    "name": "getAllExistingGroups",
                    "line": 445,
                    "comment": "/**\n* Get all existing groups from group data\n*\n* Extracts unique group names from organism_assembly_groups.json data\n* and returns a sorted list\n*\n* @param array $groups_data Array of organism/assembly/groups data\n* @return array Sorted list of unique group names\n*/",
                    "code": "function getAllExistingGroups($groups_data) {\n    $all_groups = [];\n    foreach ($groups_data as $data) {\n        if (!empty($data['groups'])) {\n            foreach ($data['groups'] as $group) {\n                $all_groups[$group] = true;\n            }\n        }\n    }\n    $group_list = array_keys($all_groups);\n    sort($group_list);\n    return $group_list;\n}",
                    "parameters": [
                        {
                            "name": "groups_data",
                            "type": "array",
                            "description": "Array of organism/assembly/groups data"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Sorted list of unique group names",
                    "internalCalls": [
                        "getAllExistingGroups"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 58,
                            "context": "$all_existing_groups = getAllExistingGroups($groups_data);"
                        }
                    ]
                },
                {
                    "name": "syncGroupDescriptions",
                    "line": 469,
                    "comment": "/**\n* Sync group descriptions with existing groups\n*\n* Marks groups as in_use=true, marks unused groups as in_use=false,\n* and creates default structure for new groups\n*\n* @param array $existing_groups List of group names that exist\n* @param array $descriptions_data Current group descriptions\n* @return array Updated descriptions with synced in_use status\n*/",
                    "code": "function syncGroupDescriptions($existing_groups, $descriptions_data) {\n    $desc_map = [];\n    foreach ($descriptions_data as $desc) {\n        $desc_map[$desc['group_name']] = $desc;\n    }\n    \n    $updated_descriptions = [];\n    \n    // Update existing groups to in_use = true\n    foreach ($existing_groups as $group) {\n        if (isset($desc_map[$group])) {\n            $desc_map[$group]['in_use'] = true;\n            $updated_descriptions[] = $desc_map[$group];\n        } else {\n            // New group - add with default structure\n            $updated_descriptions[] = [\n                'group_name' => $group,\n                'images' => [\n                    [\n                        'file' => '',\n                        'caption' => ''\n                    ]\n                ],\n                'html_p' => [\n                    [\n                        'text' => '',\n                        'style' => '',\n                        'class' => ''\n                    ]\n                ],\n                'in_use' => true\n            ];\n        }\n        unset($desc_map[$group]);\n    }\n    \n    // Mark any remaining groups (not in existing groups) as in_use = false\n    foreach ($desc_map as $group_name => $desc) {\n        $desc['in_use'] = false;\n        $updated_descriptions[] = $desc;\n    }\n    \n    return $updated_descriptions;\n}",
                    "parameters": [
                        {
                            "name": "existing_groups",
                            "type": "array",
                            "description": "List of group names that exist"
                        },
                        {
                            "name": "descriptions_data",
                            "type": "array",
                            "description": "Current group descriptions"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Updated descriptions with synced in_use status",
                    "internalCalls": [
                        "syncGroupDescriptions"
                    ],
                    "category": "utility",
                    "tags": [
                        "mutation",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 60,
                            "context": "$updated_descriptions = syncGroupDescriptions($all_existing_groups, $descriptions_data);"
                        }
                    ]
                },
                {
                    "name": "fetch_taxonomy_lineage",
                    "line": 523,
                    "comment": "/**\n* Fetch taxonomic lineage from NCBI using XML parsing\n*\n* Retrieves the full taxonomic classification for an organism using NCBI's API\n* and returns it as an array of rank => name pairs\n*\n* @param int $taxon_id NCBI Taxonomy ID\n* @return array|null Array of ['rank' => x, 'name' => y] entries, or null if failed\n*/",
                    "code": "function fetch_taxonomy_lineage($taxon_id) {\n    $url = \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&id={$taxon_id}&retmode=xml\";\n    \n    $context = stream_context_create([\n        'http' => [\n            'timeout' => 10,\n            'user_agent' => 'MOOP Taxonomy Tree Generator'\n        ]\n    ]);\n    $response = @file_get_contents($url, false, $context);\n    \n    if ($response === false) {\n        return null;\n    }\n    \n    // Parse XML using regex since SimpleXML isn't always available\n    $lineage = [];\n    \n    // Extract Lineage text (semicolon-separated)\n    if (preg_match('/<Lineage>(.+?)<\\/Lineage>/s', $response, $matches)) {\n        $lineage_text = trim($matches[1]);\n        $lineage_parts = array_filter(array_map('trim', explode(';', $lineage_text)));\n        \n        // Extract ranks from LineageEx\n        $rank_map = [];\n        if (preg_match_all('/<Taxon>.*?<ScientificName>(.+?)<\\/ScientificName>.*?<Rank>(.+?)<\\/Rank>.*?<\\/Taxon>/s', $response, $matches, PREG_SET_ORDER)) {\n            foreach ($matches as $match) {\n                $sci_name = trim($match[1]);\n                $rank = trim($match[2]);\n                $rank_map[$sci_name] = $rank;\n            }\n        }\n        \n        // Build lineage array with matched ranks\n        $valid_ranks = ['superkingdom', 'kingdom', 'phylum', 'class', 'order', 'family', 'genus'];\n        foreach ($lineage_parts as $name) {\n            $rank = $rank_map[$name] ?? null;\n            \n            // Map domain to superkingdom\n            if ($rank === 'domain') {\n                $rank = 'superkingdom';\n            }\n            \n            // Only include standard taxonomic ranks (skip intermediate ranks like 'clade')\n            if ($rank && in_array($rank, $valid_ranks)) {\n                $lineage[] = [\n                    'rank' => $rank,\n                    'name' => $name\n                ];\n            }\n        }\n    }\n    \n    // Add the species itself\n    if (preg_match('/<ScientificName>(.+?)<\\/ScientificName>/', $response, $matches)) {\n        $sci_name = trim($matches[1]);\n        // Only add if it's not already in lineage\n        if (empty($lineage) || $lineage[count($lineage)-1]['name'] !== $sci_name) {\n            $lineage[] = [\n                'rank' => 'species',\n                'name' => $sci_name\n            ];\n        }\n    }\n    \n    return !empty($lineage) ? $lineage : null;\n}",
                    "parameters": [
                        {
                            "name": "taxon_id",
                            "type": "int",
                            "description": "NCBI Taxonomy ID"
                        }
                    ],
                    "returnType": "array|null",
                    "returnDescription": "Array of ['rank' => x, 'name' => y] entries, or null if failed",
                    "internalCalls": [
                        "fetch_taxonomy_lineage"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 608,
                            "context": "$lineage = fetch_taxonomy_lineage($data['taxon_id']);"
                        },
                        {
                            "file": "/data/moop/tools/pages/organism.php",
                            "line": 159,
                            "context": "$lineage = fetch_taxonomy_lineage($organism_info['taxon_id']);"
                        }
                    ]
                },
                {
                    "name": "build_tree_from_organisms",
                    "line": 600,
                    "comment": "/**\n* Build taxonomy tree from organisms\n*\n* Creates a hierarchical tree structure from a list of organisms by fetching\n* their taxonomic lineage from NCBI and organizing by taxonomic ranks\n*\n* @param array $organisms Array of organism_name => ['taxon_id' => x, 'common_name' => y, ...]\n* @return array Tree structure: ['tree' => [...]]\n*/",
                    "code": "function build_tree_from_organisms($organisms) {\n    $all_lineages = [];\n    \n    foreach ($organisms as $organism_name => $data) {\n        if (empty($data['taxon_id'])) {\n            continue;\n        }\n        \n        $lineage = fetch_taxonomy_lineage($data['taxon_id']);\n        $image = fetch_organism_image($data['taxon_id'], $organism_name);\n        if ($lineage) {\n            $all_lineages[$organism_name] = [\n                'lineage' => $lineage,\n                'common_name' => $data['common_name'],\n                'image' => $image\n            ];\n        }\n        \n        // Be nice to NCBI - rate limit\n        usleep(350000); // 350ms = ~3 requests per second\n    }\n    \n    // Build tree structure\n    $tree = ['name' => 'Life', 'children' => []];\n    \n    foreach ($all_lineages as $organism_name => $info) {\n        $current = &$tree;\n        \n        foreach ($info['lineage'] as $level) {\n            $name = $level['name'];\n            $rank = $level['rank'];\n            \n            // Find or create child node\n            $found = false;\n            foreach ($current['children'] as &$child) {\n                if ($child['name'] === $name) {\n                    $current = &$child;\n                    $found = true;\n                    break;\n                }\n            }\n            \n            if (!$found) {\n                $new_node = ['name' => $name];\n                \n                // If this is the species level, add organism info\n                if ($rank === 'species') {\n                    $new_node['organism'] = $organism_name;\n                    $new_node['common_name'] = $info['common_name'];\n                    if ($info['image']) {\n                        $new_node['image'] = $info['image'];\n                    }\n                } else {\n                    $new_node['children'] = [];\n                }\n                \n                $current['children'][] = $new_node;\n                $current = &$current['children'][count($current['children']) - 1];\n            }\n        }\n    }\n    \n    return ['tree' => $tree];\n}",
                    "parameters": [
                        {
                            "name": "organisms",
                            "type": "array",
                            "description": "Array of organism_name => ['taxon_id' => x, 'common_name' => y, ...]"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Tree structure: ['tree' => [...]]",
                    "internalCalls": [
                        "build_tree_from_organisms",
                        "fetch_taxonomy_lineage",
                        "fetch_organism_image"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_taxonomy_tree.php",
                            "line": 45,
                            "context": "$tree_data = build_tree_from_organisms($organisms);"
                        }
                    ]
                },
                {
                    "name": "getDetailedOrganismsInfo",
                    "line": 675,
                    "comment": "/**\n* Get detailed information about all organisms\n*\n* Aggregates organism metadata, assemblies, database info, and validation results\n* for all organisms in the system. Used for admin management and reporting.\n*\n* @param string $organism_data_path Path to organism data directory\n* @param array $sequence_types List of valid sequence types (e.g., ['cds', 'protein', 'genome'])\n* @return array Associative array of organism_name => array with metadata, assemblies, validations\n*/",
                    "code": "function getDetailedOrganismsInfo($organism_data_path, $sequence_types = []) {\n    $organisms_info = [];\n    \n    if (!is_dir($organism_data_path)) {\n        return $organisms_info;\n    }\n    \n    // Load all organisms' JSON metadata using consolidated function\n    $organisms_metadata = loadAllOrganismsMetadata($organism_data_path);\n    \n    $organisms = scandir($organism_data_path);\n    foreach ($organisms as $organism) {\n        if ($organism[0] === '.' || !is_dir(\"$organism_data_path/$organism\")) {\n            continue;\n        }\n        \n        // Get organism.json info (already loaded from consolidated function)\n        $organism_json = \"$organism_data_path/$organism/organism.json\";\n        $json_validation = validateOrganismJson($organism_json);\n        $info = $organisms_metadata[$organism] ?? [];\n        \n        // Get assemblies\n        $assemblies = [];\n        $assembly_path = \"$organism_data_path/$organism\";\n        $files = scandir($assembly_path);\n        foreach ($files as $file) {\n            if ($file[0] === '.' || !is_dir(\"$assembly_path/$file\")) {\n                continue;\n            }\n            $assemblies[] = $file;\n        }\n        \n        // Check for database file\n        $db_file = null;\n        if (file_exists(\"$organism_data_path/$organism/organism.sqlite\")) {\n            $db_file = \"$organism_data_path/$organism/organism.sqlite\";\n        }\n        \n        $has_db = !is_null($db_file);\n        \n        // Validate database integrity if database exists\n        $db_validation = null;\n        $assembly_validation = null;\n        $fasta_validation = null;\n        if ($has_db) {\n            $db_validation = validateDatabaseIntegrity($db_file);\n            // Also validate assembly directories\n            $assembly_validation = validateAssemblyDirectories($db_file, \"$organism_data_path/$organism\");\n        }\n        // Validate FASTA files in assembly directories\n        $fasta_validation = validateAssemblyFastaFiles(\"$organism_data_path/$organism\", $sequence_types);\n        \n        $organisms_info[$organism] = [\n            'info' => $info,\n            'assemblies' => $assemblies,\n            'has_db' => $has_db,\n            'db_file' => $db_file,\n            'db_validation' => $db_validation,\n            'assembly_validation' => $assembly_validation,\n            'fasta_validation' => $fasta_validation,\n            'json_validation' => $json_validation,\n            'path' => \"$organism_data_path/$organism\"\n        ];\n    }\n    \n    return $organisms_info;\n}",
                    "parameters": [
                        {
                            "name": "organism_data_path",
                            "type": "string",
                            "description": "Path to organism data directory"
                        },
                        {
                            "name": "sequence_types",
                            "type": "array",
                            "description": "List of valid sequence types (e.g., ['cds', 'protein', 'genome'])"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Associative array of organism_name => array with metadata, assemblies, validations",
                    "internalCalls": [
                        "getDetailedOrganismsInfo",
                        "loadAllOrganismsMetadata",
                        "validateOrganismJson",
                        "validateDatabaseIntegrity",
                        "validateAssemblyDirectories",
                        "validateAssemblyFastaFiles"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 16,
                            "context": "$organisms = getDetailedOrganismsInfo($organism_data, $sequence_types);"
                        }
                    ]
                },
                {
                    "name": "getAssemblyGroups",
                    "line": 750,
                    "comment": "/**\n* Check if an assembly is in any groups\n* @param string $organism Organism name\n* @param string $assembly Assembly name\n* @param array $groups_data Groups data array\n* @return array Array of group names containing this assembly, empty if none\n*/",
                    "code": "function getAssemblyGroups($organism, $assembly, $groups_data) {\n    $assembly_groups = [];\n    \n    foreach ($groups_data as $data) {\n        if (!empty($data['groups'])) {\n            foreach ($data['groups'] as $group) {\n                // Check if this organism and assembly match\n                if ($data['organism'] === $organism && $data['assembly'] === $assembly) {\n                    $assembly_groups[] = $group;\n                }\n            }\n        }\n    }\n    \n    return $assembly_groups;\n}",
                    "parameters": [
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "assembly",
                            "type": "string",
                            "description": "Assembly name"
                        },
                        {
                            "name": "groups_data",
                            "type": "array",
                            "description": "Groups data array"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of group names containing this assembly, empty if none",
                    "internalCalls": [
                        "getAssemblyGroups"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 864,
                            "context": "$assembly_groups = getAssemblyGroups($organism, $assembly, $groups_data);"
                        },
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 955,
                            "context": "$assembly_groups = getAssemblyGroups($organism, $assembly, $groups_data);"
                        }
                    ]
                },
                {
                    "name": "isAssemblyInTaxonomyTree",
                    "line": 774,
                    "comment": "/**\n* Check if an organism is in the taxonomy tree\n* @param string $organism Organism name\n* @param string $assembly Assembly name (optional, can be empty)\n* @param string $tree_file Path to taxonomy_tree_config.json file\n* @return bool True if organism is in tree, false otherwise\n*/",
                    "code": "function isAssemblyInTaxonomyTree($organism, $assembly, $tree_file) {\n    if (!file_exists($tree_file)) {\n        return false;\n    }\n    \n    $tree_content = file_get_contents($tree_file);\n    if (!$tree_content) {\n        return false;\n    }\n    \n    // Simply search for the organism name in the tree file\n    return strpos($tree_content, '\"organism\": \"' . $organism . '\"') !== false;\n}",
                    "parameters": [
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "assembly",
                            "type": "string",
                            "description": "Assembly name (optional, can be empty)"
                        },
                        {
                            "name": "tree_file",
                            "type": "string",
                            "description": "Path to taxonomy_tree_config.json file"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "True if organism is in tree, false otherwise",
                    "internalCalls": [
                        "isAssemblyInTaxonomyTree"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 4,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 874,
                            "context": "$checks['in_taxonomy_tree'] = isAssemblyInTaxonomyTree($organism, '', $taxonomy_tree_file);"
                        },
                        {
                            "file": "/data/moop/tools/pages/organism.php",
                            "line": 158,
                            "context": "if (!empty($organism_info['taxon_id']) && isAssemblyInTaxonomyTree($organism_name, '', $taxonomy_tree_file)):"
                        },
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 254,
                            "context": "$in_taxonomy_tree = isAssemblyInTaxonomyTree($organism, '', $taxonomy_tree_file);"
                        },
                        {
                            "file": "/data/moop/admin/pages/organism_checklist.php",
                            "line": 425,
                            "context": "if (!isAssemblyInTaxonomyTree($org, '', $tree_file)) {"
                        }
                    ]
                },
                {
                    "name": "getOrganismOverallStatus",
                    "line": 798,
                    "comment": "/**\n* Get comprehensive status of an organism across all checks\n* @param string $organism Organism name\n* @param array $data Organism data from getDetailedOrganismsInfo\n* @param array $groups_data Groups data\n* @param string $taxonomy_tree_file Path to taxonomy_tree_config.json\n* @param array $sequence_types Configured sequence types\n* @return array Status with checks and overall status\n*/",
                    "code": "function getOrganismOverallStatus($organism, $data, $groups_data, $taxonomy_tree_file, $sequence_types) {\n    $checks = [\n        'has_assemblies' => false,\n        'has_fasta' => false,\n        'has_blast_indexes' => false,\n        'has_database' => false,\n        'database_readable' => false,\n        'assemblies_in_groups' => false,\n        'in_taxonomy_tree' => false\n    ];\n    \n    // 1. Does it have at least one assembly?\n    $checks['has_assemblies'] = !empty($data['assemblies']);\n    \n    // 2. Is there at least one FASTA file in an assembly?\n    if ($checks['has_assemblies'] && !empty($data['fasta_validation']['assemblies'])) {\n        foreach ($data['fasta_validation']['assemblies'] as $asm_fasta) {\n            if (!empty($asm_fasta['fasta_files'])) {\n                foreach ($asm_fasta['fasta_files'] as $file_info) {\n                    if ($file_info['found']) {\n                        $checks['has_fasta'] = true;\n                        break 2;\n                    }\n                }\n            }\n        }\n    }\n    \n    // 3. Are BLAST indexes present for ALL FASTA files?\n    // This check fails if there are FASTA files but any are missing BLAST indexes\n    if ($checks['has_fasta']) {\n        $all_have_indexes = true;\n        $has_any_fasta = false;\n        \n        foreach ($data['assemblies'] as $assembly) {\n            $assembly_path = $data['path'] . '/' . $assembly;\n            $blast_validation = validateBlastIndexFiles($assembly_path, $sequence_types);\n            \n            if (!empty($blast_validation['databases'])) {\n                foreach ($blast_validation['databases'] as $db) {\n                    $has_any_fasta = true;\n                    // If any FASTA file doesn't have indexes, fail the check\n                    if (!$db['has_indexes']) {\n                        $all_have_indexes = false;\n                        break 2;\n                    }\n                }\n            }\n        }\n        \n        // Set to true only if we found FASTA files AND all have indexes\n        $checks['has_blast_indexes'] = ($has_any_fasta && $all_have_indexes);\n    }\n    \n    // 4. Is there a database file?\n    $checks['has_database'] = $data['has_db'];\n    \n    // 5. Is the database readable?\n    if ($checks['has_database'] && !empty($data['db_validation'])) {\n        $checks['database_readable'] = $data['db_validation']['readable'];\n    }\n    \n    // 6. Is each assembly a member of at least one group?\n    if ($checks['has_assemblies']) {\n        $all_in_groups = true;\n        foreach ($data['assemblies'] as $assembly) {\n            $assembly_groups = getAssemblyGroups($organism, $assembly, $groups_data);\n            if (empty($assembly_groups)) {\n                $all_in_groups = false;\n                break;\n            }\n        }\n        $checks['assemblies_in_groups'] = $all_in_groups;\n    }\n    \n    // 7. Is the organism found in the tree?\n    $checks['in_taxonomy_tree'] = isAssemblyInTaxonomyTree($organism, '', $taxonomy_tree_file);\n    \n    // 8. Is metadata complete?\n    if (!empty($data['json_validation'])) {\n        $json_val = $data['json_validation'];\n        $checks['metadata_complete'] = ($json_val['exists'] && $json_val['readable'] && $json_val['valid_json'] && $json_val['has_required_fields'] && $json_val['writable']);\n    }\n    \n    // Calculate overall status\n    $all_pass = array_reduce($checks, function($carry, $item) {\n        return $carry && $item;\n    }, true);\n    \n    $pass_count = count(array_filter($checks));\n    $total_count = count($checks);\n    \n    return [\n        'checks' => $checks,\n        'all_pass' => $all_pass,\n        'pass_count' => $pass_count,\n        'total_count' => $total_count\n    ];\n}",
                    "parameters": [
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "data",
                            "type": "array",
                            "description": "Organism data from getDetailedOrganismsInfo"
                        },
                        {
                            "name": "groups_data",
                            "type": "array",
                            "description": "Groups data"
                        },
                        {
                            "name": "taxonomy_tree_file",
                            "type": "string",
                            "description": "Path to taxonomy_tree_config.json"
                        },
                        {
                            "name": "sequence_types",
                            "type": "array",
                            "description": "Configured sequence types"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Status with checks and overall status",
                    "internalCalls": [
                        "getOrganismOverallStatus",
                        "validateBlastIndexFiles",
                        "getAssemblyGroups",
                        "isAssemblyInTaxonomyTree"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 391,
                            "context": "$status = getOrganismOverallStatus($organism, $data, $groups_data, $taxonomy_tree_file, $sequence_types);"
                        },
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 1320,
                            "context": "$status = getOrganismOverallStatus($organism, $data, $groups_data, $taxonomy_tree_file, $sequence_types);"
                        }
                    ]
                },
                {
                    "name": "getWikipediaTaxonomyData",
                    "line": 905,
                    "comment": "/**\n* Fetch Wikipedia data for a taxonomic rank/level\n* Gets description and image from Wikipedia using the search API\n*\n* @param string $rank_name Name of taxonomic rank (e.g., 'Primates', 'Mammalia')\n* @return array Array with 'description' (HTML), 'image_url', 'wikipedia_url', 'source'\n*/",
                    "code": "function getWikipediaTaxonomyData($rank_name) {\n    $result = [\n        'description' => '',\n        'image_url' => '',\n        'wikipedia_url' => '',\n        'source' => 'Wikipedia'\n    ];\n    \n    if (empty($rank_name)) {\n        return $result;\n    }\n    \n    // Use Wikipedia API to search for the taxonomic rank\n    $wiki_search_url = 'https://en.wikipedia.org/w/api.php?' . http_build_query([\n        'action' => 'query',\n        'titles' => $rank_name,\n        'format' => 'json',\n        'prop' => 'extracts|pageimages|info',\n        'exlimit' => 1,\n        'exintro' => true,\n        'explaintext' => true,\n        'piprop' => 'thumbnail|original',\n        'pithumbsize' => 300,\n        'redirects' => true\n    ]);\n    \n    $context = stream_context_create([\n        'http' => [\n            'timeout' => 5,\n            'user_agent' => 'MOOP (github.com)'\n        ]\n    ]);\n    \n    $response = @file_get_contents($wiki_search_url, false, $context);\n    \n    if ($response === false) {\n        return $result;\n    }\n    \n    $data = json_decode($response, true);\n    \n    if (empty($data['query']['pages'])) {\n        return $result;\n    }\n    \n    // Get first (and usually only) page result\n    $pages = array_values($data['query']['pages']);\n    $page = $pages[0];\n    \n    if (!isset($page['pageid'])) {\n        // Page not found, try search instead\n        return getWikipediaTaxonomyDataFromSearch($rank_name);\n    }\n    \n    // Determine the actual title (in case of redirects)\n    $actual_title = $page['title'] ?? $rank_name;\n    \n    // Get the page URL\n    $result['wikipedia_url'] = 'https://en.wikipedia.org/wiki/' . str_replace(' ', '_', $actual_title);\n    \n    // Extract description from intro\n    if (!empty($page['extract'])) {\n        $description = $page['extract'];\n        // Truncate if too long\n        if (strlen($description) > 500) {\n            $description = substr($description, 0, 500) . '...';\n        }\n        $result['description'] = trim($description);\n    }\n    \n    // Extract image (try thumbnail first, then original)\n    if (!empty($page['thumbnail']['source'])) {\n        $result['image_url'] = $page['thumbnail']['source'];\n    } elseif (!empty($page['original']['source'])) {\n        $result['image_url'] = $page['original']['source'];\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "rank_name",
                            "type": "string",
                            "description": "Name of taxonomic rank (e.g., 'Primates', 'Mammalia')"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with 'description' (HTML), 'image_url', 'wikipedia_url', 'source'",
                    "internalCalls": [
                        "getWikipediaTaxonomyData",
                        "getWikipediaTaxonomyDataFromSearch"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/groups.php",
                            "line": 68,
                            "context": "$wiki_data = getWikipediaTaxonomyData($taxonomy_rank);"
                        }
                    ]
                },
                {
                    "name": "getWikipediaTaxonomyDataFromSearch",
                    "line": 956,
                    "comment": "/**\n* Search Wikipedia for taxonomic rank information\n* Fallback when direct title lookup doesn't find good content\n*\n* @param string $rank_name Name of taxonomic rank\n* @return array Array with description, image, and Wikipedia URL\n*/",
                    "code": "function getWikipediaTaxonomyDataFromSearch($rank_name) {\n    $result = [\n        'description' => '',\n        'image_url' => '',\n        'wikipedia_url' => '',\n        'source' => 'Wikipedia'\n    ];\n    \n    // Search for the term\n    $search_url = 'https://en.wikipedia.org/w/api.php?' . http_build_query([\n        'action' => 'query',\n        'list' => 'search',\n        'srsearch' => $rank_name,\n        'format' => 'json',\n        'srlimit' => 3\n    ]);\n    \n    $context = stream_context_create([\n        'http' => [\n            'timeout' => 5,\n            'user_agent' => 'MOOP (github.com)'\n        ]\n    ]);\n    \n    $response = @file_get_contents($search_url, false, $context);\n    \n    if ($response === false) {\n        return $result;\n    }\n    \n    $data = json_decode($response, true);\n    \n    if (empty($data['query']['search'])) {\n        return $result;\n    }\n    \n    // Try the first few results to find one with content\n    foreach ($data['query']['search'] as $search_result) {\n        $found_title = $search_result['title'];\n        \n        // Fetch details about this page\n        $fetch_url = 'https://en.wikipedia.org/w/api.php?' . http_build_query([\n            'action' => 'query',\n            'titles' => $found_title,\n            'format' => 'json',\n            'prop' => 'extracts|pageimages',\n            'exintro' => true,\n            'explaintext' => true,\n            'piprop' => 'thumbnail|original',\n            'pithumbsize' => 300,\n            'redirects' => true\n        ]);\n        \n        $response = @file_get_contents($fetch_url, false, $context);\n        \n        if ($response === false) {\n            continue;\n        }\n        \n        $data = json_decode($response, true);\n        \n        if (empty($data['query']['pages'])) {\n            continue;\n        }\n        \n        $pages = array_values($data['query']['pages']);\n        $page = $pages[0];\n        \n        // Skip if no content\n        if (empty($page['extract'])) {\n            continue;\n        }\n        \n        if (!empty($page['extract'])) {\n            $description = $page['extract'];\n            if (strlen($description) > 500) {\n                $description = substr($description, 0, 500) . '...';\n            }\n            $result['description'] = trim($description);\n        }\n        \n        if (!empty($page['thumbnail']['source'])) {\n            $result['image_url'] = $page['thumbnail']['source'];\n        } elseif (!empty($page['original']['source'])) {\n            $result['image_url'] = $page['original']['source'];\n        }\n        \n        $result['wikipedia_url'] = 'https://en.wikipedia.org/wiki/' . str_replace(' ', '_', $page['title']);\n        \n        // Found a good result, return it\n        return $result;\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "rank_name",
                            "type": "string",
                            "description": "Name of taxonomic rank"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with description, image, and Wikipedia URL",
                    "internalCalls": [
                        "getWikipediaTaxonomyDataFromSearch"
                    ],
                    "category": "search",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 956,
                            "context": "return getWikipediaTaxonomyDataFromSearch($rank_name);"
                        }
                    ]
                },
                {
                    "name": "getWikipediaOrganismData",
                    "line": 1096,
                    "comment": "/**\n* Fetch Wikipedia data for an organism (species)\n* Gets description and image from Wikipedia using scientific name or common name\n*\n* @param string $organism_name Common name or scientific name (e.g., 'Human', 'Homo sapiens')\n* @param string $scientific_name Scientific name to try first (optional)\n* @return array Array with 'description', 'image_url', 'wikipedia_url', 'source'\n*/",
                    "code": "function getWikipediaOrganismData($organism_name, $scientific_name = '') {\n    $result = [\n        'description' => '',\n        'image_url' => '',\n        'wikipedia_url' => '',\n        'source' => 'Wikipedia'\n    ];\n    \n    if (empty($organism_name) && empty($scientific_name)) {\n        return $result;\n    }\n    \n    // Try scientific name first, then common name\n    $names_to_try = array_filter([\n        $scientific_name,\n        $organism_name,\n        // Also try common name without underscores\n        str_replace('_', ' ', $organism_name)\n    ]);\n    \n    foreach ($names_to_try as $search_name) {\n        $wiki_search_url = 'https://en.wikipedia.org/w/api.php?' . http_build_query([\n            'action' => 'query',\n            'titles' => $search_name,\n            'format' => 'json',\n            'prop' => 'extracts|pageimages|info',\n            'exlimit' => 1,\n            'exintro' => true,\n            'explaintext' => true,\n            'piprop' => 'thumbnail|original',\n            'pithumbsize' => 400,\n            'redirects' => true\n        ]);\n        \n        $context = stream_context_create([\n            'http' => [\n                'timeout' => 5,\n                'user_agent' => 'MOOP (github.com)'\n            ]\n        ]);\n        \n        $response = @file_get_contents($wiki_search_url, false, $context);\n        \n        if ($response === false) {\n            continue;\n        }\n        \n        $data = json_decode($response, true);\n        \n        if (empty($data['query']['pages'])) {\n            continue;\n        }\n        \n        $pages = array_values($data['query']['pages']);\n        $page = $pages[0];\n        \n        if (!isset($page['pageid']) || empty($page['extract'])) {\n            continue;\n        }\n        \n        // Found good data, return it\n        $actual_title = $page['title'] ?? $search_name;\n        $result['wikipedia_url'] = 'https://en.wikipedia.org/wiki/' . str_replace(' ', '_', $actual_title);\n        \n        if (!empty($page['extract'])) {\n            $description = $page['extract'];\n            if (strlen($description) > 500) {\n                $description = substr($description, 0, 500) . '...';\n            }\n            $result['description'] = trim($description);\n        }\n        \n        if (!empty($page['thumbnail']['source'])) {\n            $result['image_url'] = $page['thumbnail']['source'];\n        } elseif (!empty($page['original']['source'])) {\n            $result['image_url'] = $page['original']['source'];\n        }\n        \n        return $result;\n    }\n    \n    // If direct search failed, try Wikipedia search API as fallback\n    return getWikipediaOrganismDataFromSearch($organism_name);\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Common name or scientific name (e.g., 'Human', 'Homo sapiens')"
                        },
                        {
                            "name": "scientific_name",
                            "type": "string",
                            "description": "Scientific name to try first (optional)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with 'description', 'image_url', 'wikipedia_url', 'source'",
                    "internalCalls": [
                        "getWikipediaOrganismData",
                        "getWikipediaOrganismDataFromSearch"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/organism.php",
                            "line": 64,
                            "context": "$wiki_data = getWikipediaOrganismData($organism_name, $scientific_name);"
                        },
                        {
                            "file": "/data/moop/tools/organism.php",
                            "line": 80,
                            "context": "$wiki_data = getWikipediaOrganismData($organism_name, $scientific_name);"
                        }
                    ]
                },
                {
                    "name": "getWikipediaOrganismDataFromSearch",
                    "line": 1178,
                    "comment": "/**\n* Search Wikipedia for organism information\n* Fallback when direct title lookup doesn't find good content\n*\n* @param string $organism_name Organism name to search for\n* @return array Array with description, image, and Wikipedia URL\n*/",
                    "code": "function getWikipediaOrganismDataFromSearch($organism_name) {\n    $result = [\n        'description' => '',\n        'image_url' => '',\n        'wikipedia_url' => '',\n        'source' => 'Wikipedia'\n    ];\n    \n    // Search for the organism\n    $search_url = 'https://en.wikipedia.org/w/api.php?' . http_build_query([\n        'action' => 'query',\n        'list' => 'search',\n        'srsearch' => str_replace('_', ' ', $organism_name) . ' species animal',\n        'format' => 'json',\n        'srlimit' => 3\n    ]);\n    \n    $context = stream_context_create([\n        'http' => [\n            'timeout' => 5,\n            'user_agent' => 'MOOP (github.com)'\n        ]\n    ]);\n    \n    $response = @file_get_contents($search_url, false, $context);\n    \n    if ($response === false) {\n        return $result;\n    }\n    \n    $data = json_decode($response, true);\n    \n    if (empty($data['query']['search'])) {\n        return $result;\n    }\n    \n    // Try the first few results\n    foreach ($data['query']['search'] as $search_result) {\n        $found_title = $search_result['title'];\n        \n        // Fetch details about this page\n        $fetch_url = 'https://en.wikipedia.org/w/api.php?' . http_build_query([\n            'action' => 'query',\n            'titles' => $found_title,\n            'format' => 'json',\n            'prop' => 'extracts|pageimages',\n            'exintro' => true,\n            'explaintext' => true,\n            'piprop' => 'thumbnail|original',\n            'pithumbsize' => 400,\n            'redirects' => true\n        ]);\n        \n        $response = @file_get_contents($fetch_url, false, $context);\n        \n        if ($response === false) {\n            continue;\n        }\n        \n        $data = json_decode($response, true);\n        \n        if (empty($data['query']['pages'])) {\n            continue;\n        }\n        \n        $pages = array_values($data['query']['pages']);\n        $page = $pages[0];\n        \n        // Skip if no extract\n        if (empty($page['extract'])) {\n            continue;\n        }\n        \n        $description = $page['extract'];\n        if (strlen($description) > 500) {\n            $description = substr($description, 0, 500) . '...';\n        }\n        $result['description'] = trim($description);\n        \n        if (!empty($page['thumbnail']['source'])) {\n            $result['image_url'] = $page['thumbnail']['source'];\n        } elseif (!empty($page['original']['source'])) {\n            $result['image_url'] = $page['original']['source'];\n        }\n        \n        $result['wikipedia_url'] = 'https://en.wikipedia.org/wiki/' . str_replace(' ', '_', $page['title']);\n        \n        // Found a good result\n        return $result;\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name to search for"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with description, image, and Wikipedia URL",
                    "internalCalls": [
                        "getWikipediaOrganismDataFromSearch"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 1178,
                            "context": "return getWikipediaOrganismDataFromSearch($organism_name);"
                        }
                    ]
                },
                {
                    "name": "fetchOrganismInfoFromNCBI",
                    "line": 1290,
                    "comment": "/**\n* Fetch organism info from NCBI using genus and species\n* Gets taxon_id and common name for a given genus/species\n*\n* @param string $genus Organism genus\n* @param string $species Organism species\n* @return array Array with 'taxon_id', 'common_name', 'scientific_name', 'error'\n*/",
                    "code": "function fetchOrganismInfoFromNCBI($genus, $species) {\n    $result = [\n        'taxon_id' => '',\n        'common_name' => '',\n        'scientific_name' => \"$genus $species\",\n        'error' => ''\n    ];\n    \n    if (empty($genus) || empty($species)) {\n        $result['error'] = 'Genus and species are required';\n        return $result;\n    }\n    \n    // Search for the organism on NCBI\n    $search_url = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?' . http_build_query([\n        'db' => 'taxonomy',\n        'term' => \"$genus $species\",\n        'retmode' => 'json'\n    ]);\n    \n    $context = stream_context_create([\n        'http' => [\n            'timeout' => 5,\n            'user_agent' => 'MOOP (github.com)'\n        ]\n    ]);\n    \n    $response = @file_get_contents($search_url, false, $context);\n    \n    if ($response === false) {\n        $result['error'] = 'Failed to connect to NCBI';\n        return $result;\n    }\n    \n    $data = json_decode($response, true);\n    \n    if (empty($data['esearchresult']['idlist'])) {\n        $result['error'] = 'Organism not found on NCBI';\n        return $result;\n    }\n    \n    $taxon_id = $data['esearchresult']['idlist'][0];\n    $result['taxon_id'] = $taxon_id;\n    \n    // Fetch full details\n    $fetch_url = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?' . http_build_query([\n        'db' => 'taxonomy',\n        'id' => $taxon_id,\n        'retmode' => 'json'\n    ]);\n    \n    $response = @file_get_contents($fetch_url, false, $context);\n    \n    if ($response === false) {\n        return $result;\n    }\n    \n    $data = json_decode($response, true);\n    \n    if (!empty($data['result'][$taxon_id]['commonname'])) {\n        $result['common_name'] = $data['result'][$taxon_id]['commonname'];\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "genus",
                            "type": "string",
                            "description": "Organism genus"
                        },
                        {
                            "name": "species",
                            "type": "string",
                            "description": "Organism species"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with 'taxon_id', 'common_name', 'scientific_name', 'error'",
                    "internalCalls": [
                        "fetchOrganismInfoFromNCBI"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/api/generate_organism_json.php",
                            "line": 49,
                            "context": "$ncbi_data = fetchOrganismInfoFromNCBI($genus, $species);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_database.php",
            "count": 10,
            "functions": [
                {
                    "name": "validateDatabaseFile",
                    "line": 13,
                    "comment": "/**\n* Validates database file is readable and accessible\n*\n* @param string $dbFile - Path to SQLite database file\n* @return array - Validation results with 'valid' and 'error' keys\n*/",
                    "code": "function validateDatabaseFile($dbFile) {\n    if (!file_exists($dbFile)) {\n        return ['valid' => false, 'error' => 'Database file not found'];\n    }\n    \n    if (!is_readable($dbFile)) {\n        return ['valid' => false, 'error' => 'Database file not readable (permission denied)'];\n    }\n    \n    try {\n        $db = new PDO('sqlite:' . $dbFile);\n        $db = null;\n        return ['valid' => true, 'error' => ''];\n    } catch (Exception $e) {\n        return ['valid' => false, 'error' => $e->getMessage()];\n    }\n}",
                    "parameters": [
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database file"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Validation results with 'valid' and 'error' keys",
                    "internalCalls": [
                        "validateDatabaseFile"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "security-related",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 75,
                            "context": "$db_validation = validateDatabaseFile($db);"
                        }
                    ]
                },
                {
                    "name": "validateDatabaseIntegrity",
                    "line": 44,
                    "comment": "/**\n* Validate database integrity and data quality\n*\n* Checks:\n* - File is readable\n* - Valid SQLite database\n* - All required tables exist\n* - Tables have data\n* - Data completeness (no orphaned records)\n*\n* @param string $dbFile - Path to SQLite database file\n* @return array - Validation results with status and details\n*/",
                    "code": "function validateDatabaseIntegrity($dbFile) {\n    $result = [\n        'valid' => false,\n        'readable' => false,\n        'database_valid' => false,\n        'tables_present' => [],\n        'tables_missing' => [],\n        'row_counts' => [],\n        'feature_counts' => [],\n        'data_issues' => [],\n        'errors' => []\n    ];\n    \n    // Check if file exists and is readable\n    if (!file_exists($dbFile)) {\n        $result['errors'][] = 'Database file not found';\n        return $result;\n    }\n    \n    if (!is_readable($dbFile)) {\n        $result['errors'][] = 'Database file not readable (permission denied)';\n        return $result;\n    }\n    \n    $result['readable'] = true;\n    \n    // Try to connect to database\n    try {\n        $dbh = new PDO(\"sqlite:\" . $dbFile);\n        $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n    } catch (PDOException $e) {\n        $result['errors'][] = 'Invalid SQLite database: ' . $e->getMessage();\n        return $result;\n    }\n    \n    $result['database_valid'] = true;\n    \n    // Required tables based on schema\n    $required_tables = [\n        'organism',\n        'genome',\n        'feature',\n        'annotation_source',\n        'annotation',\n        'feature_annotation'\n    ];\n    \n    // Check which tables exist\n    try {\n        $stmt = $dbh->query(\"SELECT name FROM sqlite_master WHERE type='table'\");\n        $existing_tables = $stmt->fetchAll(PDO::FETCH_COLUMN);\n        \n        foreach ($required_tables as $table) {\n            if (in_array($table, $existing_tables)) {\n                $result['tables_present'][] = $table;\n            } else {\n                $result['tables_missing'][] = $table;\n            }\n        }\n    } catch (PDOException $e) {\n        $result['errors'][] = 'Cannot query tables: ' . $e->getMessage();\n        $dbh = null;\n        return $result;\n    }\n    \n    // Check row counts and data quality\n    try {\n        foreach ($result['tables_present'] as $table) {\n            $stmt = $dbh->query(\"SELECT COUNT(*) FROM $table\");\n            $count = $stmt->fetchColumn();\n            $result['row_counts'][$table] = $count;\n        }\n        \n        // Get counts by feature type\n        if (in_array('feature', $result['tables_present'])) {\n            $stmt = $dbh->query(\"\n                SELECT feature_type, COUNT(*) as count\n                FROM feature\n                GROUP BY feature_type\n                ORDER BY feature_type\n            \");\n            $features = $stmt->fetchAll(PDO::FETCH_ASSOC);\n            foreach ($features as $feature) {\n                $result['feature_counts'][$feature['feature_type']] = $feature['count'];\n            }\n        }\n        \n        // Check for data quality issues\n        \n        // 1. Check for annotations without sources (orphaned)\n        if (in_array('annotation', $result['tables_present']) && in_array('annotation_source', $result['tables_present'])) {\n            $stmt = $dbh->query(\"\n                SELECT COUNT(*) FROM annotation a \n                LEFT JOIN annotation_source ans ON a.annotation_source_id = ans.annotation_source_id \n                WHERE ans.annotation_source_id IS NULL\n            \");\n            $orphaned_count = $stmt->fetchColumn();\n            if ($orphaned_count > 0) {\n                $result['data_issues'][] = \"Orphaned annotations (no source): $orphaned_count\";\n            }\n        }\n        \n        // 2. Check for incomplete annotations (missing accession or description)\n        if (in_array('annotation', $result['tables_present'])) {\n            $stmt = $dbh->query(\"\n                SELECT COUNT(*) FROM annotation \n                WHERE annotation_accession IS NULL OR annotation_accession = ''\n            \");\n            $missing_accession = $stmt->fetchColumn();\n            if ($missing_accession > 0) {\n                $result['data_issues'][] = \"Annotations with missing accession: $missing_accession\";\n            }\n        }\n        \n        // 3. Check for features without organisms\n        if (in_array('feature', $result['tables_present']) && in_array('organism', $result['tables_present'])) {\n            $stmt = $dbh->query(\"\n                SELECT COUNT(*) FROM feature f \n                LEFT JOIN organism o ON f.organism_id = o.organism_id \n                WHERE o.organism_id IS NULL\n            \");\n            $orphaned_features = $stmt->fetchColumn();\n            if ($orphaned_features > 0) {\n                $result['data_issues'][] = \"Features without organism: $orphaned_features\";\n            }\n        }\n        \n    } catch (PDOException $e) {\n        $result['errors'][] = 'Data quality check failed: ' . $e->getMessage();\n    }\n    \n    $dbh = null;\n    \n    // Determine overall validity\n    $result['valid'] = (\n        $result['readable'] && \n        $result['database_valid'] && \n        empty($result['tables_missing']) && \n        empty($result['data_issues']) &&\n        empty($result['errors'])\n    );\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database file"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Validation results with status and details",
                    "internalCalls": [
                        "validateDatabaseIntegrity"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "security-related",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 720,
                            "context": "$db_validation = validateDatabaseIntegrity($db_file);"
                        }
                    ]
                },
                {
                    "name": "getDbConnection",
                    "line": 196,
                    "comment": "/**\n* Get database connection\n*\n* @param string $dbFile - Path to SQLite database file\n* @return PDO - Database connection\n* @throws PDOException if connection fails\n*/",
                    "code": "function getDbConnection($dbFile) {\n    try {\n        $dbh = new PDO(\"sqlite:\" . $dbFile);\n        $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n        \n        // Register custom REGEXP function for word boundary matching\n        $dbh->sqliteCreateFunction('REGEXP', function($pattern, $text) {\n            return preg_match('/' . $pattern . '/i', $text) ? 1 : 0;\n        }, 2);\n        \n        return $dbh;\n    } catch (PDOException $e) {\n        die(\"Database connection failed: \" . $e->getMessage());\n    }\n}",
                    "parameters": [
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database file"
                        }
                    ],
                    "returnType": "PDO",
                    "returnDescription": "Database connection",
                    "internalCalls": [
                        "getDbConnection"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_database.php",
                            "line": 223,
                            "context": "$dbh = getDbConnection($dbFile);"
                        }
                    ]
                },
                {
                    "name": "fetchData",
                    "line": 221,
                    "comment": "/**\n* Execute SQL query with prepared statement\n*\n* @param string $sql - SQL query with ? placeholders\n* @param string $dbFile - Path to SQLite database file\n* @param array $params - Parameters to bind to query (optional)\n* @return array - Array of associative arrays (results)\n* @throws PDOException if query fails\n*/",
                    "code": "function fetchData($sql, $dbFile, $params = []) {\n    try {\n        $dbh = getDbConnection($dbFile);\n        $stmt = $dbh->prepare($sql);\n        $stmt->execute($params);\n        $result = $stmt->fetchAll(PDO::FETCH_ASSOC);\n        $dbh = null;\n        return $result;\n    } catch (PDOException $e) {\n        die(\"Query failed: \" . $e->getMessage());\n    }\n}",
                    "parameters": [
                        {
                            "name": "sql",
                            "type": "string",
                            "description": "SQL query with ? placeholders"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database file"
                        },
                        {
                            "name": "params",
                            "type": "array",
                            "description": "Parameters to bind to query (optional)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of associative arrays (results)",
                    "internalCalls": [
                        "fetchData",
                        "getDbConnection"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 17,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 249,
                            "context": "$results = fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 52,
                            "context": "$results = fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 89,
                            "context": "$results = fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 118,
                            "context": "return fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 144,
                            "context": "$results = fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 175,
                            "context": "return fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 208,
                            "context": "return fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 229,
                            "context": "return fetchData($query, $dbFile, [$feature_id]);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 246,
                            "context": "$results = fetchData($query, [$organism_name, $organism_name], $dbFile);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 268,
                            "context": "$results = fetchData($query, $dbFile, [$genome_id_param, $genome_id_param]);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 525,
                            "context": "return fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 576,
                            "context": "return fetchData($query, $dbFile, $params);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 597,
                            "context": "return fetchData($query, $dbFile, []);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 622,
                            "context": "$sources_with_types = fetchData($query, $dbFile, []);"
                        },
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 693,
                            "context": "$results = fetchData($query, $dbFile, []);"
                        },
                        {
                            "file": "/data/moop/lib/functions_database.php",
                            "line": 304,
                            "context": "$results = fetchData($query, $db_path, $params);"
                        },
                        {
                            "file": "/data/moop/lib/functions_access.php",
                            "line": 26,
                            "context": "$results = fetchData($query, $db_path, [$assembly, $assembly]);"
                        }
                    ]
                },
                {
                    "name": "buildLikeConditions",
                    "line": 256,
                    "comment": "/**\n* Build SQL LIKE conditions for multi-column search\n* Supports both quoted (phrase) and unquoted (word-by-word) searches\n*\n* Creates SQL WHERE clause fragments for searching multiple columns.\n* Supports both keyword search (AND logic) and quoted phrase search.\n*\n* Keyword search: \"ABC transporter\"\n*   - Splits into terms: [\"ABC\", \"transporter\"]\n*   - Logic: (col1 LIKE '%ABC%' OR col2 LIKE '%ABC%') AND (col1 LIKE '%transporter%' OR col2 LIKE '%transporter%')\n*   - Result: Both terms must match somewhere\n*\n* Quoted search: '\"ABC transporter\"'\n*   - Keeps as single phrase: \"ABC transporter\"\n*   - Logic: (col1 LIKE '%ABC transporter%' OR col2 LIKE '%ABC transporter%')\n*   - Result: Exact phrase must match\n*\n* @param array $columns - Column names to search\n* @param string $search - Search string (unquoted: words separated by space, quoted: single phrase)\n* @param bool $quoted - If true, treat entire $search as single phrase; if false, split on whitespace\n* @return array - [$sqlFragment, $params] for use with fetchData()\n*/",
                    "code": "function buildLikeConditions($columns, $search, $quoted = false) {\n    $conditions = [];\n    $params = [];\n\n    if ($quoted) {\n        $searchConditions = [];\n        foreach ($columns as $col) {\n            $searchConditions[] = \"$col LIKE ?\";\n            $params[] = \"%\" . $search . \"%\";\n        }\n        $conditions[] = \"(\" . implode(\" OR \", $searchConditions) . \")\";\n    } else {\n        $terms = preg_split('/\\s+/', trim($search));\n        foreach ($terms as $term) {\n            if (empty($term)) continue;\n            $termConditions = [];\n            foreach ($columns as $col) {\n                $termConditions[] = \"$col LIKE ?\";\n                $params[] = \"%\" . $term . \"%\";\n            }\n            $conditions[] = \"(\" . implode(\" OR \", $termConditions) . \")\";\n        }\n    }\n\n    $sqlFragment = implode(\" AND \", $conditions);\n    return [$sqlFragment, $params];\n}",
                    "parameters": [
                        {
                            "name": "columns",
                            "type": "array",
                            "description": "Column names to search"
                        },
                        {
                            "name": "search",
                            "type": "string",
                            "description": "Search string (unquoted: words separated by space, quoted: single phrase)"
                        },
                        {
                            "name": "quoted",
                            "type": "bool",
                            "description": "If true, treat entire $search as single phrase; if false, split on whitespace"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "[$sqlFragment, $params] for use with fetchData()",
                    "internalCalls": [
                        "buildLikeConditions"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "getAccessibleGenomeIds",
                    "line": 292,
                    "comment": "/**\n* Get accessible genome IDs from database for organism\n*\n* @param string $organism_name - Organism name\n* @param array $accessible_assemblies - List of accessible assembly names\n* @param string $db_path - Path to SQLite database file\n* @return array - Array of genome IDs\n*/",
                    "code": "function getAccessibleGenomeIds($organism_name, $accessible_assemblies, $db_path) {\n    if (empty($accessible_assemblies)) {\n        return [];\n    }\n    \n    $placeholders = implode(',', array_fill(0, count($accessible_assemblies), '?'));\n    $query = \"SELECT DISTINCT genome_id FROM genome \n              WHERE genome_name IN ($placeholders) \n              OR genome_accession IN ($placeholders)\";\n    \n    // Pass accessible_assemblies twice - once for names, once for accessions\n    $params = array_merge($accessible_assemblies, $accessible_assemblies);\n    $results = fetchData($query, $db_path, $params);\n    \n    return array_column($results, 'genome_id');\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "accessible_assemblies",
                            "type": "array",
                            "description": "List of accessible assembly names"
                        },
                        {
                            "name": "db_path",
                            "type": "string",
                            "description": "Path to SQLite database file"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of genome IDs",
                    "internalCalls": [
                        "getAccessibleGenomeIds",
                        "fetchData"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 805,
                            "context": "$genome_ids = getAccessibleGenomeIds($organism_name, $user);"
                        },
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 84,
                            "context": "$accessible_genome_ids = getAccessibleGenomeIds($organism_name, $accessible_assemblies, $db);"
                        }
                    ]
                },
                {
                    "name": "loadOrganismInfo",
                    "line": 316,
                    "comment": "/**\n* Load organism info from organism.json file\n*\n* @param string $organism_name - Organism name\n* @param string $organism_data_dir - Path to organism data directory\n* @return array|null - Organism info array or null if not found\n*/",
                    "code": "function loadOrganismInfo($organism_name, $organism_data_dir) {\n    $organism_json_path = \"$organism_data_dir/$organism_name/organism.json\";\n    $organism_info = loadJsonFile($organism_json_path);\n    \n    if (!$organism_info) {\n        return null;\n    }\n    \n    // Handle improperly wrapped JSON (extra outer braces)\n    if (!isset($organism_info['genus']) && !isset($organism_info['common_name'])) {\n        $keys = array_keys($organism_info);\n        if (count($keys) > 0 && is_array($organism_info[$keys[0]]) && isset($organism_info[$keys[0]]['genus'])) {\n            $organism_info = $organism_info[$keys[0]];\n        }\n    }\n    \n    // Validate required fields\n    if (!isset($organism_info['common_name']) && !isset($organism_info['genus'])) {\n        return null;\n    }\n    \n    return $organism_info;\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "organism_data_dir",
                            "type": "string",
                            "description": "Path to organism data directory"
                        }
                    ],
                    "returnType": "array|null",
                    "returnDescription": "Organism info array or null if not found",
                    "internalCalls": [
                        "loadOrganismInfo",
                        "loadJsonFile"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 28,
                            "context": "$organism_info = loadOrganismInfo($organism_name, $organism_data);"
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 271,
                            "context": "$organism_info = loadOrganismInfo($organism_name, $organism_data_dir);"
                        }
                    ]
                },
                {
                    "name": "getOrganismDatabase",
                    "line": 348,
                    "comment": "/**\n* Get organism database path if it exists\n* Returns null if database doesn't exist (doesn't die like verifyOrganismDatabase)\n*\n* @param string $organism_name - Organism name\n* @param string $organism_data_dir - Path to organism data directory\n* @return string|null - Database path if exists, null if not\n*/",
                    "code": "function getOrganismDatabase($organism_name, $organism_data_dir) {\n    $db_path = \"$organism_data_dir/$organism_name/organism.sqlite\";\n    \n    if (!file_exists($db_path)) {\n        return null;\n    }\n    \n    return $db_path;\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "organism_data_dir",
                            "type": "string",
                            "description": "Path to organism data directory"
                        }
                    ],
                    "returnType": "string|null",
                    "returnDescription": "Database path if exists, null if not",
                    "internalCalls": [
                        "getOrganismDatabase"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_database.php",
                            "line": 385,
                            "context": "$db_path = getOrganismDatabase($organism_name, $organism_data_dir);"
                        },
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 258,
                            "context": "$db_path = getOrganismDatabase($organism_name, $organism_data);"
                        }
                    ]
                },
                {
                    "name": "verifyOrganismDatabase",
                    "line": 342,
                    "comment": "/**\n* Verify organism database file exists\n*\n* @param string $organism_name - Organism name\n* @param string $organism_data_dir - Path to organism data directory\n* @return string - Database path if exists, exits with error if not\n*/",
                    "code": "function verifyOrganismDatabase($organism_name, $organism_data_dir) {\n    $db_path = \"$organism_data_dir/$organism_name/organism.sqlite\";\n    \n    if (!file_exists($db_path)) {\n        header(\"HTTP/1.1 500 Internal Server Error\");\n        die(\"Error: Database not found for organism '$organism_name'. Please ensure the organism is properly configured.\");\n    }\n    \n    return $db_path;\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "organism_data_dir",
                            "type": "string",
                            "description": "Path to organism data directory"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Database path if exists, exits with error if not",
                    "internalCalls": [
                        "verifyOrganismDatabase"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/tools/assembly.php",
                            "line": 50,
                            "context": "$db_path = verifyOrganismDatabase($organism_name, $organism_data);"
                        },
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 74,
                            "context": "$db = verifyOrganismDatabase($organism_name, $organism_data);"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 142,
                            "context": "$db = verifyOrganismDatabase($selected_organism, $organism_data);"
                        }
                    ]
                },
                {
                    "name": "getOrganismAssemblies",
                    "line": 384,
                    "comment": "/**\n* Get all assemblies (genomes) for an organism from its database\n* Filters by user access permissions\n*\n* @param string $organism_name - Organism name\n* @param string $organism_data_dir - Path to organism data directory\n* @return array - Array of assembly accessions accessible to current user, or empty array if none\n*/",
                    "code": "function getOrganismAssemblies($organism_name, $organism_data_dir) {\n    $db_path = getOrganismDatabase($organism_name, $organism_data_dir);\n    \n    if (empty($db_path)) {\n        return [];\n    }\n    \n    try {\n        $dbh = new PDO(\"sqlite:\" . $db_path);\n        $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n        \n        $stmt = $dbh->query(\"SELECT genome_accession FROM genome ORDER BY genome_name ASC\");\n        $genomes = $stmt->fetchAll(PDO::FETCH_COLUMN);\n        \n        // Filter by user access\n        $accessible = [];\n        foreach ($genomes as $assembly) {\n            if (has_assembly_access($organism_name, $assembly)) {\n                $accessible[] = $assembly;\n            }\n        }\n        \n        return $accessible;\n    } catch (PDOException $e) {\n        return [];\n    }\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name"
                        },
                        {
                            "name": "organism_data_dir",
                            "type": "string",
                            "description": "Path to organism data directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of assembly accessions accessible to current user, or empty array if none",
                    "internalCalls": [
                        "getOrganismAssemblies",
                        "getOrganismDatabase"
                    ],
                    "category": "database",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/organism.php",
                            "line": 210,
                            "context": "$accessible_assemblies = getOrganismAssemblies($organism_name, $organism_data);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_display.php",
            "count": 12,
            "functions": [
                {
                    "name": "loadOrganismAndGetImagePath",
                    "line": 18,
                    "comment": "/**\n* Load organism info and get image path\n*\n* Combines organism.json loading with image path resolution.\n* Uses loadOrganismInfo() for JSON loading and getOrganismImagePath() for image logic.\n*\n* @param string $organism_name The organism name\n* @param string $images_path URL path to images directory (e.g., 'moop/images')\n* @param string $absolute_images_path Absolute file system path to images directory\n* @return array ['organism_info' => array, 'image_path' => string]\n*/",
                    "code": "function loadOrganismAndGetImagePath($organism_name, $images_path = 'moop/images', $absolute_images_path = '') {\n    $config = ConfigManager::getInstance();\n    $organism_data = $config->getPath('organism_data');\n    \n    $result = [\n        'organism_info' => [],\n        'image_path' => ''\n    ];\n    \n    // Use consolidated loadOrganismInfo() instead of manual JSON loading\n    $organism_info = loadOrganismInfo($organism_name, $organism_data);\n    if ($organism_info) {\n        $result['organism_info'] = $organism_info;\n        $result['image_path'] = getOrganismImagePath($organism_info, $images_path, $absolute_images_path);\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "The organism name"
                        },
                        {
                            "name": "images_path",
                            "type": "string",
                            "description": "URL path to images directory (e.g., 'moop/images')"
                        },
                        {
                            "name": "absolute_images_path",
                            "type": "string",
                            "description": "Absolute file system path to images directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['organism_info' => array, 'image_path' => string]",
                    "internalCalls": [
                        "loadOrganismAndGetImagePath",
                        "loadOrganismInfo",
                        "getOrganismImagePath"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/multi_organism.php",
                            "line": 80,
                            "context": "$organism_data_result = loadOrganismAndGetImagePath($organism, $images_path, $absolute_images_path);"
                        },
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 87,
                            "context": "$organism_data_result = loadOrganismAndGetImagePath($organism, $images_path, $absolute_images_path);"
                        }
                    ]
                },
                {
                    "name": "getOrganismImagePath",
                    "line": 11,
                    "comment": "/**\n* Get organism image file path\n*\n* Returns the URL path to an organism's image with fallback logic:\n* 1. Custom image from organism.json if defined\n* 2. NCBI taxonomy image if taxon_id exists and image file found\n* 3. Empty string if no image available\n*\n* @param array $organism_info Array from organism.json with keys: images, taxon_id\n* @param string $images_path URL path to images directory (e.g., 'moop/images')\n* @param string $absolute_images_path Absolute file system path to images directory\n* @return string URL path to image file or empty string if no image\n*/",
                    "code": "function getOrganismImagePath($organism_info, $images_path = 'moop/images', $absolute_images_path = '') {\n    // Validate input\n    if (empty($organism_info) || !is_array($organism_info)) {\n        logError('getOrganismImagePath received invalid organism_info', 'organism_image', [\n            'organism_info_type' => gettype($organism_info),\n            'organism_info_empty' => empty($organism_info)\n        ]);\n        return '';\n    }\n    \n    // Check for custom image first\n    if (!empty($organism_info['images']) && is_array($organism_info['images'])) {\n        return \"/$images_path/\" . htmlspecialchars($organism_info['images'][0]['file']);\n    }\n    \n    // Fall back to NCBI taxonomy image if taxon_id exists\n    if (!empty($organism_info['taxon_id'])) {\n        // Construct path - use absolute_images_path if provided, otherwise fall back\n        if (!empty($absolute_images_path)) {\n            $ncbi_image_file = \"$absolute_images_path/ncbi_taxonomy/\" . $organism_info['taxon_id'] . '.jpg';\n        } else {\n            $ncbi_image_file = __DIR__ . '/../../images/ncbi_taxonomy/' . $organism_info['taxon_id'] . '.jpg';\n        }\n        \n        if (file_exists($ncbi_image_file)) {\n            return \"/moop/images/ncbi_taxonomy/\" . $organism_info['taxon_id'] . \".jpg\";\n        } else {\n            logError('NCBI taxonomy image not found', 'organism_image', [\n                'taxon_id' => $organism_info['taxon_id'],\n                'expected_path' => $ncbi_image_file\n            ]);\n        }\n    }\n    \n    return '';\n}",
                    "parameters": [
                        {
                            "name": "organism_info",
                            "type": "array",
                            "description": "Array from organism.json with keys: images, taxon_id"
                        },
                        {
                            "name": "images_path",
                            "type": "string",
                            "description": "URL path to images directory (e.g., 'moop/images')"
                        },
                        {
                            "name": "absolute_images_path",
                            "type": "string",
                            "description": "Absolute file system path to images directory"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "URL path to image file or empty string if no image",
                    "internalCalls": [
                        "getOrganismImagePath",
                        "logError"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 31,
                            "context": "$result['image_path'] = getOrganismImagePath($organism_info, $images_path, $absolute_images_path);"
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 151,
                            "context": "$image_path = getOrganismImagePath($organism_info, $images_path, $absolute_images_path);"
                        },
                        {
                            "file": "/data/moop/tools/pages/groups.php",
                            "line": 165,
                            "context": "$image_src = getOrganismImagePath($organism_info, $images_path, $absolute_images_path);"
                        }
                    ]
                },
                {
                    "name": "getOrganismImageCaption",
                    "line": 98,
                    "comment": "/**\n* Get organism image caption with optional link\n*\n* Returns display caption for organism image:\n* - Custom images: caption from organism.json or empty string\n* - NCBI taxonomy fallback: \"Image from NCBI Taxonomy\" with link to NCBI\n*\n* @param array $organism_info Array from organism.json with keys: images, taxon_id\n* @param string $absolute_images_path Absolute file system path to images directory\n* @return array ['caption' => caption text, 'link' => URL or empty string]\n*/",
                    "code": "function getOrganismImageCaption($organism_info, $absolute_images_path = '') {\n    $result = [\n        'caption' => '',\n        'link' => ''\n    ];\n    \n    // Validate input\n    if (empty($organism_info) || !is_array($organism_info)) {\n        logError('getOrganismImageCaption received invalid organism_info', 'organism_image', [\n            'organism_info_type' => gettype($organism_info),\n            'organism_info_empty' => empty($organism_info)\n        ]);\n        return $result;\n    }\n    \n    // Custom image caption\n    if (!empty($organism_info['images']) && is_array($organism_info['images'])) {\n        if (!empty($organism_info['images'][0]['caption'])) {\n            $result['caption'] = $organism_info['images'][0]['caption'];\n        }\n        return $result;\n    }\n    \n    // NCBI taxonomy caption with link\n    if (!empty($organism_info['taxon_id'])) {\n        // Construct path - use absolute_images_path if provided, otherwise fall back\n        if (!empty($absolute_images_path)) {\n            $ncbi_image_file = \"$absolute_images_path/ncbi_taxonomy/\" . $organism_info['taxon_id'] . '.jpg';\n        } else {\n            $ncbi_image_file = __DIR__ . '/../../images/ncbi_taxonomy/' . $organism_info['taxon_id'] . '.jpg';\n        }\n        \n        if (file_exists($ncbi_image_file)) {\n            $result['caption'] = 'Image from NCBI Taxonomy';\n            $result['link'] = 'https://www.ncbi.nlm.nih.gov/datasets/taxonomy/' . htmlspecialchars($organism_info['taxon_id']);\n        }\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "organism_info",
                            "type": "array",
                            "description": "Array from organism.json with keys: images, taxon_id"
                        },
                        {
                            "name": "absolute_images_path",
                            "type": "string",
                            "description": "Absolute file system path to images directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['caption' => caption text, 'link' => URL or empty string]",
                    "internalCalls": [
                        "getOrganismImageCaption",
                        "logError"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 152,
                            "context": "$image_info = getOrganismImageCaption($organism_info, $absolute_images_path);"
                        }
                    ]
                },
                {
                    "name": "getOrganismImageWithCaption",
                    "line": 150,
                    "comment": "/**\n* Get organism image with path and caption\n*\n* Convenience function combining getOrganismImagePath() and getOrganismImageCaption()\n* Used when both image URL and caption are needed (common display pattern).\n*\n* @param array $organism_info Array from organism.json with keys: images, taxon_id\n* @param string $images_path URL path to images directory (e.g., 'moop/images')\n* @param string $absolute_images_path Absolute file system path to images directory\n* @return array ['image_path' => string, 'caption' => string, 'link' => string or empty]\n*/",
                    "code": "function getOrganismImageWithCaption($organism_info, $images_path = 'moop/images', $absolute_images_path = '') {\n    $image_path = getOrganismImagePath($organism_info, $images_path, $absolute_images_path);\n    $image_info = getOrganismImageCaption($organism_info, $absolute_images_path);\n    \n    return [\n        'image_path' => $image_path,\n        'caption' => $image_info['caption'],\n        'link' => $image_info['link']\n    ];\n}",
                    "parameters": [
                        {
                            "name": "organism_info",
                            "type": "array",
                            "description": "Array from organism.json with keys: images, taxon_id"
                        },
                        {
                            "name": "images_path",
                            "type": "string",
                            "description": "URL path to images directory (e.g., 'moop/images')"
                        },
                        {
                            "name": "absolute_images_path",
                            "type": "string",
                            "description": "Absolute file system path to images directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['image_path' => string, 'caption' => string, 'link' => string or empty]",
                    "internalCalls": [
                        "getOrganismImageWithCaption",
                        "getOrganismImagePath",
                        "getOrganismImageCaption"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/assembly.php",
                            "line": 62,
                            "context": "$image_data = getOrganismImageWithCaption($organism_info, $images_path, $absolute_images_path);"
                        },
                        {
                            "file": "/data/moop/tools/pages/organism.php",
                            "line": 84,
                            "context": "$image_data = getOrganismImageWithCaption($organism_info, $images_path, $absolute_images_path);"
                        },
                        {
                            "file": "/data/moop/tools/organism.php",
                            "line": 79,
                            "context": "if (empty($organism_info['images']) && empty(getOrganismImageWithCaption($organism_info, $images_path, $absolute_images_path)['image_path'])) {"
                        }
                    ]
                },
                {
                    "name": "validateOrganismJson",
                    "line": 173,
                    "comment": "/**\n* Validate organism.json file\n*\n* Checks:\n* - File exists\n* - File is readable\n* - Valid JSON format\n* - Contains required fields (genus, species, common_name, taxon_id)\n*\n* @param string $json_path - Path to organism.json file\n* @return array - Validation results with status and details\n*/",
                    "code": "function validateOrganismJson($json_path) {\n    $validation = [\n        'exists' => false,\n        'readable' => false,\n        'writable' => false,\n        'valid_json' => false,\n        'has_required_fields' => false,\n        'required_fields' => ['genus', 'species', 'common_name', 'taxon_id'],\n        'missing_fields' => [],\n        'errors' => [],\n        'owner' => null,\n        'perms' => null,\n        'web_user' => null,\n        'web_group' => null\n    ];\n    \n    if (!file_exists($json_path)) {\n        $validation['errors'][] = 'organism.json file does not exist';\n        return $validation;\n    }\n    \n    $validation['exists'] = true;\n    \n    // Get file ownership and permissions\n    if (@is_readable($json_path) || @file_exists($json_path)) {\n        $perms = @fileperms($json_path);\n        if ($perms !== false) {\n            $validation['perms'] = substr(sprintf('%o', $perms), -3);\n        }\n        $owner = @posix_getpwuid(@fileowner($json_path));\n        if ($owner !== false) {\n            $validation['owner'] = $owner['name'] ?? 'unknown';\n        }\n    }\n    \n    // Get web server user/group\n    $webserver = getWebServerUser();\n    $validation['web_user'] = $webserver['user'];\n    $validation['web_group'] = $webserver['group'];\n    \n    if (!is_readable($json_path)) {\n        $validation['errors'][] = 'organism.json file is not readable';\n        return $validation;\n    }\n    \n    $validation['readable'] = true;\n    $validation['writable'] = is_writable($json_path);\n    \n    $content = file_get_contents($json_path);\n    $json_data = json_decode($content, true);\n    \n    if ($json_data === null) {\n        $validation['errors'][] = 'organism.json contains invalid JSON: ' . json_last_error_msg();\n        return $validation;\n    }\n    \n    $validation['valid_json'] = true;\n    \n    // Handle wrapped JSON (single-level wrapping)\n    if (!isset($json_data['genus']) && !isset($json_data['common_name'])) {\n        $keys = array_keys($json_data);\n        if (count($keys) > 0 && is_array($json_data[$keys[0]])) {\n            $json_data = $json_data[$keys[0]];\n        }\n    }\n    \n    // Check for required fields\n    foreach ($validation['required_fields'] as $field) {\n        if (!isset($json_data[$field]) || empty($json_data[$field])) {\n            $validation['missing_fields'][] = $field;\n        }\n    }\n    \n    $validation['has_required_fields'] = empty($validation['missing_fields']);\n    \n    if (!$validation['has_required_fields']) {\n        $validation['errors'][] = 'Missing required fields: ' . implode(', ', $validation['missing_fields']);\n    }\n    \n    return $validation;\n}",
                    "parameters": [
                        {
                            "name": "json_path",
                            "type": "string",
                            "description": "Path to organism.json file"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Validation results with status and details",
                    "internalCalls": [
                        "validateOrganismJson",
                        "getWebServerUser"
                    ],
                    "category": "validation",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "file-io",
                        "security-related",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 693,
                            "context": "$json_validation = validateOrganismJson($organism_json);"
                        }
                    ]
                },
                {
                    "name": "setupOrganismDisplayContext",
                    "line": 266,
                    "comment": "/**\n* Complete setup for organism display pages\n* Validates parameter, loads organism info, checks access, returns context\n* Use this to replace boilerplate in organism_display, assembly_display, parent_display\n*\n* @param string $organism_name Organism from GET/POST\n* @param string $organism_data_dir Path to organism data directory\n* @param bool $check_access Whether to check access control (default: true)\n* @param string $redirect_home Home URL for redirects (default: /moop/index.php)\n* @return array Array with 'name' and 'info' keys, or exits on error\n*/",
                    "code": "function setupOrganismDisplayContext($organism_name, $organism_data_dir, $check_access = true, $redirect_home = '/moop/index.php') {\n    // Validate organism parameter\n    $organism_name = validateOrganismParam($organism_name, $redirect_home);\n    \n    // Load and validate organism info\n    $organism_info = loadOrganismInfo($organism_name, $organism_data_dir);\n    \n    if (!$organism_info) {\n        header(\"Location: $redirect_home\");\n        exit;\n    }\n    \n    // Check access (unless it's public)\n    if ($check_access) {\n        $is_public = is_public_organism($organism_name);\n        if (!$is_public) {\n            require_access('Collaborator', $organism_name);\n        }\n    }\n    \n    return [\n        'name' => $organism_name,\n        'info' => $organism_info\n    ];\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism from GET/POST"
                        },
                        {
                            "name": "organism_data_dir",
                            "type": "string",
                            "description": "Path to organism data directory"
                        },
                        {
                            "name": "check_access",
                            "type": "bool",
                            "description": "Whether to check access control (default: true)"
                        },
                        {
                            "name": "redirect_home",
                            "type": "string",
                            "description": "Home URL for redirects (default: /moop/index.php)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with 'name' and 'info' keys, or exits on error",
                    "internalCalls": [
                        "setupOrganismDisplayContext",
                        "validateOrganismParam",
                        "loadOrganismInfo"
                    ],
                    "category": "organisms",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/tools/assembly.php",
                            "line": 46,
                            "context": "$organism_context = setupOrganismDisplayContext($organism_name, $organism_data, true);"
                        },
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 69,
                            "context": "$organism_context = setupOrganismDisplayContext($_GET['organism'], $organism_data, true);"
                        },
                        {
                            "file": "/data/moop/tools/organism.php",
                            "line": 47,
                            "context": "$organism_context = setupOrganismDisplayContext($_GET['organism'] ?? '', $organism_data);"
                        }
                    ]
                },
                {
                    "name": "fetch_organism_image",
                    "line": 303,
                    "comment": "/**\n* Fetch and cache organism image from NCBI to ncbi_taxonomy directory\n*\n* Downloads organism images from NCBI taxonomy API and caches them locally.\n* Returns the web-accessible image path or null if download fails.\n*\n* @param int $taxon_id NCBI Taxonomy ID\n* @param string|null $organism_name Optional organism name (for reference)\n* @param string $absolute_images_path Absolute filesystem path to images directory\n* @return string|null Web path to image (e.g., 'images/ncbi_taxonomy/12345.jpg'), or null if failed\n*/",
                    "code": "function fetch_organism_image($taxon_id, $organism_name = null, $absolute_images_path = null) {\n    if ($absolute_images_path === null) {\n        $config = ConfigManager::getInstance();\n        $absolute_images_path = $config->getPath('absolute_images_path');\n    }\n    \n    $ncbi_dir = $absolute_images_path . '/ncbi_taxonomy';\n    $image_path = $ncbi_dir . '/' . $taxon_id . '.jpg';\n    \n    // Check if image already cached\n    if (file_exists($image_path)) {\n        return 'images/ncbi_taxonomy/' . $taxon_id . '.jpg';\n    }\n    \n    // Ensure directory exists\n    if (!is_dir($ncbi_dir)) {\n        @mkdir($ncbi_dir, 0755, true);\n    }\n    \n    // Download from NCBI\n    $image_url = \"https://api.ncbi.nlm.nih.gov/datasets/v2/taxonomy/taxon/{$taxon_id}/image\";\n    \n    $context = stream_context_create(['http' => ['timeout' => 10, 'user_agent' => 'MOOP']]);\n    $image_data = @file_get_contents($image_url, false, $context);\n    \n    if ($image_data === false || strlen($image_data) < 100) {\n        return null;\n    }\n    \n    // Save image\n    if (file_put_contents($image_path, $image_data) !== false) {\n        return 'images/ncbi_taxonomy/' . $taxon_id . '.jpg';\n    }\n    \n    return null;\n}",
                    "parameters": [
                        {
                            "name": "taxon_id",
                            "type": "int",
                            "description": "NCBI Taxonomy ID"
                        },
                        {
                            "name": "organism_name",
                            "type": "string|null",
                            "description": "Optional organism name (for reference)"
                        },
                        {
                            "name": "absolute_images_path",
                            "type": "string",
                            "description": "Absolute filesystem path to images directory"
                        }
                    ],
                    "returnType": "string|null",
                    "returnDescription": "Web path to image (e.g., 'images/ncbi_taxonomy/12345.jpg'), or null if failed",
                    "internalCalls": [
                        "fetch_organism_image"
                    ],
                    "category": "database",
                    "tags": [
                        "mutation",
                        "database-dependent",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 609,
                            "context": "$image = fetch_organism_image($data['taxon_id'], $organism_name);"
                        }
                    ]
                },
                {
                    "name": "generatePermissionAlert",
                    "line": 354,
                    "comment": "/**\n* Generate a permission alert HTML for a file or directory\n*\n* Shows current status (readable, writable) and provides either:\n* 1. A \"Fix Permissions\" button if web server can fix it automatically\n* 2. Manual fix instructions with commands if web server lacks permissions\n*\n* @param string $file_path Path to file or directory\n* @param string $title Alert title (e.g., \"Metadata File Permission Issue\")\n* @param string $problem Description of the problem\n* @param string $file_type Type for AJAX call: 'file' or 'directory'\n* @param string $organism Optional organism name for targeting\n* @return string HTML for the permission alert, empty if no issues\n*/",
                    "code": "function generatePermissionAlert($file_path, $title = '', $problem = '', $file_type = 'file', $organism = '') {\n    // Check current permissions\n    $readable = is_readable($file_path);\n    $writable = is_writable($file_path);\n    \n    // If everything is fine, return empty\n    if ($readable && $writable) {\n        return '';\n    }\n    \n    // Get file/directory info\n    $exists = file_exists($file_path);\n    if (!$exists) {\n        return '';\n    }\n    \n    $is_dir = is_dir($file_path);\n    $file_size = $is_dir ? 'directory' : filesize($file_path) . ' bytes';\n    $owner = @posix_getpwuid(fileowner($file_path));\n    $owner_name = $owner !== false ? $owner['name'] : 'unknown';\n    $perms = substr(sprintf('%o', fileperms($file_path)), -3);\n    $webserver = getWebServerUser();\n    $web_user = $webserver['user'];\n    $web_group = $webserver['group'];\n    \n    // Determine if web server can fix permissions\n    $can_fix = is_writable(dirname($file_path)) || is_writable($file_path);\n    \n    // Determine what's wrong\n    $issue = '';\n    if (!$readable && !$writable) {\n        $issue = 'Cannot read or write';\n    } elseif (!$readable) {\n        $issue = 'Cannot read (permission denied)';\n    } else {\n        $issue = 'Cannot write (read-only)';\n    }\n    \n    $safe_path = htmlspecialchars($file_path);\n    $safe_title = htmlspecialchars($title ?: $issue);\n    $safe_problem = htmlspecialchars($problem);\n    $safe_organism = htmlspecialchars($organism);\n    \n    // Start building alert HTML\n    $html = '<div class=\"alert alert-warning alert-dismissible fade show mb-3\">' . \"\\n\";\n    $html .= '  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>' . \"\\n\";\n    $html .= '  <h6><i class=\"fa fa-exclamation-circle\"></i> ' . $safe_title . '</h6>' . \"\\n\";\n    \n    if ($safe_problem) {\n        $html .= '  <p class=\"mb-2\"><strong>Problem:</strong> ' . $safe_problem . '</p>' . \"\\n\";\n    }\n    \n    $html .= '  <p class=\"mb-3\"><strong>Current Status:</strong></p>' . \"\\n\";\n    $html .= '  <ul class=\"mb-3 small\">' . \"\\n\";\n    $html .= '    <li>Path: <code>' . $safe_path . '</code></li>' . \"\\n\";\n    $html .= '    <li>Type: ' . ($is_dir ? 'Directory' : 'File') . '</li>' . \"\\n\";\n    $html .= '    <li>Owner: <code>' . htmlspecialchars($owner_name) . '</code></li>' . \"\\n\";\n    $html .= '    <li>Permissions: <code>' . $perms . '</code></li>' . \"\\n\";\n    $html .= '    <li>Readable: <span class=\"badge ' . ($readable ? 'bg-success' : 'bg-danger') . '\">' . ($readable ? '\u2713 Yes' : '\u2717 No') . '</span></li>' . \"\\n\";\n    $html .= '    <li>Writable: <span class=\"badge ' . ($writable ? 'bg-success' : 'bg-danger') . '\">' . ($writable ? '\u2713 Yes' : '\u2717 No') . '</span></li>' . \"\\n\";\n    $html .= '    <li>Web server user: <code>' . htmlspecialchars($web_user) . '</code></li>' . \"\\n\";\n    $html .= '  </ul>' . \"\\n\";\n    \n    if ($can_fix) {\n        // Web server can fix it - offer button\n        $resultId = 'fixResult-' . uniqid();\n        $html .= '  <p class=\"mb-2\"><strong>Quick Fix:</strong> Click the button below to attempt automatic fix:</p>' . \"\\n\";\n        $html .= '  <button class=\"btn btn-warning btn-sm\" onclick=\\'fixFilePermissions(event, ' . json_encode($file_path) . ', ' . json_encode($file_type) . ', ' . json_encode($organism) . ', ' . json_encode($resultId) . ');\\'>' . \"\\n\";\n        $html .= '    <i class=\"fa fa-wrench\"></i> Fix Permissions' . \"\\n\";\n        $html .= '  </button>' . \"\\n\";\n        $html .= '  <div id=\"' . $resultId . '\" class=\"mt-3\"></div>' . \"\\n\";\n        \n        // Show manual instructions as alternative\n        $html .= '  <p class=\"mb-2 mt-4\"><strong>Or manually on the server:</strong></p>' . \"\\n\";\n        $html .= '  <div style=\"margin: 10px 0; background: #f0f0f0; padding: 10px; border-radius: 4px; border: 1px solid #ddd;\">' . \"\\n\";\n        $html .= '    <code style=\"word-break: break-all; display: block; font-size: 0.9em;\">' . \"\\n\";\n        if ($is_dir) {\n            $html .= '      sudo chgrp -R ' . htmlspecialchars($web_group) . ' ' . $safe_path . '<br>' . \"\\n\";\n            $html .= '      sudo chmod -R 775 ' . $safe_path . \"\\n\";\n        } else {\n            $html .= '      sudo chgrp ' . htmlspecialchars($web_group) . ' ' . $safe_path . '<br>' . \"\\n\";\n            $html .= '      sudo chmod 664 ' . $safe_path . \"\\n\";\n        }\n        $html .= '    </code>' . \"\\n\";\n        $html .= '  </div>' . \"\\n\";\n    } else {\n        // Web server cannot fix - show manual instructions\n        $html .= '  <p class=\"mb-2\"><strong>To Fix:</strong> Run this command on the server:</p>' . \"\\n\";\n        $html .= '  <div style=\"margin: 10px 0; background: #f0f0f0; padding: 10px; border-radius: 4px; border: 1px solid #ddd;\">' . \"\\n\";\n        $html .= '    <code style=\"word-break: break-all; display: block; font-size: 0.9em;\">' . \"\\n\";\n        if ($is_dir) {\n            $html .= '      sudo chgrp -R ' . htmlspecialchars($web_group) . ' ' . $safe_path . '<br>' . \"\\n\";\n            $html .= '      sudo chmod -R 775 ' . $safe_path . \"\\n\";\n        } else {\n            $html .= '      sudo chgrp ' . htmlspecialchars($web_group) . ' ' . $safe_path . '<br>' . \"\\n\";\n            $html .= '      sudo chmod 664 ' . $safe_path . \"\\n\";\n        }\n        $html .= '    </code>' . \"\\n\";\n        $html .= '  </div>' . \"\\n\";\n    }\n    \n    $html .= '  <p class=\"small text-muted mb-0\">After fixing permissions, refresh this page.</p>' . \"\\n\";\n    $html .= '</div>' . \"\\n\";\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "file_path",
                            "type": "string",
                            "description": "Path to file or directory"
                        },
                        {
                            "name": "title",
                            "type": "string",
                            "description": "Alert title (e.g., \"Metadata File Permission Issue\")"
                        },
                        {
                            "name": "problem",
                            "type": "string",
                            "description": "Description of the problem"
                        },
                        {
                            "name": "file_type",
                            "type": "string",
                            "description": "Type for AJAX call: 'file' or 'directory'"
                        },
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Optional organism name for targeting"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML for the permission alert, empty if no issues",
                    "internalCalls": [
                        "generatePermissionAlert",
                        "getWebServerUser",
                        "fixFilePermissions"
                    ],
                    "category": "validation",
                    "tags": [
                        "mutation",
                        "file-io",
                        "security-related",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 732,
                            "context": "<?php echo generatePermissionAlert("
                        },
                        {
                            "file": "/data/moop/admin/pages/manage_groups.php",
                            "line": 10,
                            "context": "echo generatePermissionAlert("
                        },
                        {
                            "file": "/data/moop/admin/pages/manage_groups.php",
                            "line": 257,
                            "context": "echo generatePermissionAlert("
                        }
                    ]
                },
                {
                    "name": "getColorClassOrStyle",
                    "line": 474,
                    "comment": "/**\n* Convert color value to class or style attribute\n*\n* Handles both Bootstrap CSS classes and custom hex colors.\n* For hex colors, returns style attribute. For Bootstrap classes, returns class name.\n*\n* TODO: Use this function in other places that display sequence type colors:\n* - search/results pages that show sequence badges\n* - any other pages using $file_info['color'] or sequence_types colors\n*\n* @param string $color Color value - either Bootstrap class (bg-info, bg-success) or hex (#FF5733)\n* @return array ['class' => string, 'style' => string] - one will be empty, other populated\n*/",
                    "code": "function getColorClassOrStyle($color) {\n    $result = [\n        'class' => '',\n        'style' => ''\n    ];\n    \n    if (empty($color)) {\n        $result['class'] = 'btn-secondary';\n        return $result;\n    }\n    \n    // Check if it's a hex color (#RGB or #RRGGBB)\n    if (preg_match('/^#([0-9a-f]{3}|[0-9a-f]{6})$/i', $color)) {\n        $result['style'] = 'background-color: ' . htmlspecialchars($color) . '; border-color: ' . htmlspecialchars($color) . ';';\n    } else {\n        // Treat as Bootstrap class\n        $result['class'] = htmlspecialchars($color);\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "color",
                            "type": "string",
                            "description": "Color value - either Bootstrap class (bg-info, bg-success) or hex (#FF5733)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['class' => string, 'style' => string] - one will be empty, other populated",
                    "internalCalls": [
                        "getColorClassOrStyle"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/assembly.php",
                            "line": 155,
                            "context": "$colorInfo = getColorClassOrStyle($file_info['color'] ?? '');"
                        },
                        {
                            "file": "/data/moop/admin/pages/manage_site_config.php",
                            "line": 180,
                            "context": "$colorInfo = getColorClassOrStyle($seq_config['color'] ?? 'bg-secondary');"
                        }
                    ]
                },
                {
                    "name": "ensureDirectoryExists",
                    "line": 499,
                    "comment": "/**\n* Ensure directory exists with proper permissions\n*/",
                    "code": "function ensureDirectoryExists($directory, $owner = 'ubuntu', $group = 'www-data') {\n    if (is_dir($directory)) {\n        return true;\n    }\n    \n    if (!@mkdir($directory, 0775, true)) {\n        logError('Failed to create directory', 'directory_creation', ['directory' => $directory]);\n        return false;\n    }\n    \n    @chown($directory, $owner);\n    @chgrp($directory, $group);\n    @chmod($directory, 0775);\n    \n    return true;\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "ensureDirectoryExists",
                        "logError"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 528,
                            "context": "if (!ensureDirectoryExists($cache_directory)) {"
                        }
                    ]
                },
                {
                    "name": "downloadWikimediaImage",
                    "line": 519,
                    "comment": "/**\n* Download image from Wikimedia and cache locally\n*/",
                    "code": "function downloadWikimediaImage($wiki_url, $cache_filename, $cache_directory = '') {\n    $config = ConfigManager::getInstance();\n    $site = $config->getString('site');\n    \n    if (empty($cache_directory)) {\n        $images_path = $config->getPath('images_path');\n        $cache_directory = $images_path . '/wikimedia';\n    }\n    \n    if (!ensureDirectoryExists($cache_directory)) {\n        logError('Could not create wikimedia cache directory', 'wikimedia_download', ['directory' => $cache_directory]);\n        return false;\n    }\n    \n    $cache_file = $cache_directory . '/' . basename($cache_filename);\n    \n    if (file_exists($cache_file)) {\n        return \"/$site/images/wikimedia/\" . basename($cache_filename);\n    }\n    \n    $context = stream_context_create([\n        'http' => ['timeout' => 10, 'user_agent' => 'MOOP/1.0'],\n        'https' => ['timeout' => 10, 'user_agent' => 'MOOP/1.0']\n    ]);\n    \n    $image_data = @file_get_contents($wiki_url, false, $context);\n    \n    if ($image_data === false) {\n        logError('Failed to download Wikimedia image', 'wikimedia_download', ['wiki_url' => $wiki_url]);\n        return false;\n    }\n    \n    if (@file_put_contents($cache_file, $image_data) === false) {\n        logError('Failed to write cached image', 'wikimedia_download', ['cache_file' => $cache_file]);\n        return false;\n    }\n    \n    @chmod($cache_file, 0664);\n    \n    return \"/$site/images/wikimedia/\" . basename($cache_filename);\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "downloadWikimediaImage",
                        "ensureDirectoryExists",
                        "logError"
                    ],
                    "category": "utility",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 609,
                            "context": "$result = downloadWikimediaImage($wiki_url, $cache_filename, $wikimedia_dir);"
                        }
                    ]
                },
                {
                    "name": "getGroupImagePath",
                    "line": 564,
                    "comment": "/**\n* Get image path for group with fallback logic\n*/",
                    "code": "function getGroupImagePath($group_info, $absolute_images_path = '') {\n    $config = ConfigManager::getInstance();\n    $site = $config->getString('site');\n    \n    if (empty($group_info) || !is_array($group_info) || empty($group_info['name'])) {\n        return '';\n    }\n    \n    $group_name = $group_info['name'];\n    $safe_group_name = basename($group_name);\n    \n    if (empty($absolute_images_path)) {\n        $absolute_images_path = $config->getPath('images_path');\n    }\n    \n    // 1. Check for custom group image\n    $extensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\n    $custom_image_dir = \"$absolute_images_path/groups/\";\n    foreach ($extensions as $ext) {\n        $custom_image = $custom_image_dir . $safe_group_name . '.' . $ext;\n        if (file_exists($custom_image)) {\n            return \"/$site/images/groups/\" . $safe_group_name . '.' . $ext;\n        }\n    }\n    \n    // 2. Check for cached Wikimedia image\n    $wikimedia_dir = \"$absolute_images_path/wikimedia/\";\n    foreach ($extensions as $ext) {\n        $wikimedia_image = $wikimedia_dir . $safe_group_name . '.' . $ext;\n        if (file_exists($wikimedia_image)) {\n            return \"/$site/images/wikimedia/\" . $safe_group_name . '.' . $ext;\n        }\n    }\n    \n    // 3. Try to download from Wikipedia if URL available\n    if (!empty($group_info['wikipedia_image'])) {\n        $wiki_url = $group_info['wikipedia_image'];\n        if (strpos($wiki_url, 'wikimedia.org') !== false || strpos($wiki_url, 'wikipedia.org') !== false) {\n            $url_path = parse_url($wiki_url, PHP_URL_PATH);\n            $ext = pathinfo($url_path, PATHINFO_EXTENSION);\n            if (empty($ext)) {\n                $ext = 'jpg';\n            }\n            \n            $cache_filename = $safe_group_name . '.' . $ext;\n            $result = downloadWikimediaImage($wiki_url, $cache_filename, $wikimedia_dir);\n            if ($result !== false) {\n                return $result;\n            }\n        }\n    }\n    \n    return '';\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "getGroupImagePath",
                        "downloadWikimediaImage"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/groups.php",
                            "line": 83,
                            "context": "<?php $cached_image = getGroupImagePath($group_info, $absolute_images_path); ?>"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_errorlog.php",
            "count": 3,
            "functions": [
                {
                    "name": "logError",
                    "line": 15,
                    "comment": "/**\n* Log an error to the error log file\n*\n* @param string $error_message The error message to log\n* @param string $context Optional context (e.g., organism name, page name)\n* @param array $additional_info Additional details to log\n* @return void\n*/",
                    "code": "function logError($error_message, $context = '', $additional_info = []) {\n    $config = ConfigManager::getInstance();\n    $log_file = $config->getPath('error_log_file');\n    \n    $error_entry = [\n        'timestamp' => date('Y-m-d H:i:s'),\n        'error' => $error_message,\n        'context' => $context,\n        'user' => $_SESSION['username'] ?? 'anonymous',\n        'page' => $_SERVER['REQUEST_URI'] ?? '',\n        'ip' => $_SERVER['REMOTE_ADDR'] ?? '',\n        'details' => $additional_info\n    ];\n    \n    $log_line = json_encode($error_entry) . \"\\n\";\n    \n    if ($log_file) {\n        error_log($log_line, 3, $log_file);\n    }\n}",
                    "parameters": [
                        {
                            "name": "error_message",
                            "type": "string",
                            "description": "The error message to log"
                        },
                        {
                            "name": "context",
                            "type": "string",
                            "description": "Optional context (e.g., organism name, page name)"
                        },
                        {
                            "name": "additional_info",
                            "type": "array",
                            "description": "Additional details to log"
                        }
                    ],
                    "returnType": "void",
                    "returnDescription": "*/",
                    "internalCalls": [
                        "logError"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "recursive"
                    ],
                    "usageCount": 12,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 53,
                            "context": "logError('getOrganismImagePath received invalid organism_info', 'organism_image', ["
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 77,
                            "context": "logError('NCBI taxonomy image not found', 'organism_image', ["
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 106,
                            "context": "logError('getOrganismImageCaption received invalid organism_info', 'organism_image', ["
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 505,
                            "context": "logError('Failed to create directory', 'directory_creation', ['directory' => $directory]);"
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 529,
                            "context": "logError('Could not create wikimedia cache directory', 'wikimedia_download', ['directory' => $cache_directory]);"
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 547,
                            "context": "logError('Failed to download Wikimedia image', 'wikimedia_download', ['wiki_url' => $wiki_url]);"
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 552,
                            "context": "logError('Failed to write cached image', 'wikimedia_download', ['cache_file' => $cache_file]);"
                        },
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 66,
                            "context": "logError('Database not found for organism', $organism, ["
                        },
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 77,
                            "context": "logError('Database file not accessible', $organism, ["
                        },
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 143,
                            "context": "logError('Incomplete annotation records found', $organism, ["
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 260,
                            "context": "logError($err, \"download_fasta\", ['user' => $_SESSION['username'] ?? 'unknown']);"
                        },
                        {
                            "file": "/data/moop/tools/sequences_display.php",
                            "line": 161,
                            "context": "logError("
                        }
                    ]
                },
                {
                    "name": "getErrorLog",
                    "line": 42,
                    "comment": "/**\n* Get error log entries\n*\n* @param int $limit Maximum number of entries to retrieve (0 = all)\n* @return array Array of error entries\n*/",
                    "code": "function getErrorLog($limit = 0) {\n    $config = ConfigManager::getInstance();\n    $log_file = $config->getPath('error_log_file');\n    \n    if (!$log_file || !file_exists($log_file)) {\n        return [];\n    }\n    \n    $lines = file($log_file, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);\n    if (!$lines) {\n        return [];\n    }\n    \n    $errors = [];\n    foreach (array_reverse($lines) as $line) {\n        $error = json_decode($line, true);\n        if ($error) {\n            $errors[] = $error;\n        }\n    }\n    \n    if ($limit > 0) {\n        $errors = array_slice($errors, 0, $limit);\n    }\n    \n    return $errors;\n}",
                    "parameters": [
                        {
                            "name": "limit",
                            "type": "int",
                            "description": "Maximum number of entries to retrieve (0 = all)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of error entries",
                    "internalCalls": [
                        "getErrorLog"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_error_log.php",
                            "line": 28,
                            "context": "$all_errors = getErrorLog(500); // Get more for filtering"
                        }
                    ]
                },
                {
                    "name": "clearErrorLog",
                    "line": 75,
                    "comment": "/**\n* Clear the error log file\n*\n* @return bool True if successful\n*/",
                    "code": "function clearErrorLog() {\n    $config = ConfigManager::getInstance();\n    $log_file = $config->getPath('error_log_file');\n    \n    if (!$log_file) {\n        return false;\n    }\n    \n    return file_put_contents($log_file, '') !== false;\n}",
                    "parameters": [],
                    "returnType": "bool",
                    "returnDescription": "True if successful",
                    "internalCalls": [
                        "clearErrorLog"
                    ],
                    "category": "utility",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_error_log.php",
                            "line": 22,
                            "context": "if (clearErrorLog()) {"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_filesystem.php",
            "count": 11,
            "functions": [
                {
                    "name": "validateDirectoryName",
                    "line": 15,
                    "comment": "/**\n* Validate directory name for security\n*\n* Prevents path traversal attacks by checking for invalid characters\n*\n* @param string $name - Directory name to validate\n* @return bool - True if valid, false if contains path separators or traversal attempts\n*/",
                    "code": "function validateDirectoryName($name) {\n    return strpos($name, '/') === false && \n           strpos($name, '..') === false &&\n           $name !== '.' && \n           $name !== '..' &&\n           $name !== 'organism.json';\n}",
                    "parameters": [
                        {
                            "name": "name",
                            "type": "string",
                            "description": "Directory name to validate"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "True if valid, false if contains path separators or traversal attempts",
                    "internalCalls": [
                        "validateDirectoryName"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 223,
                            "context": "if (!validateDirectoryName($old_name) || !validateDirectoryName($new_name)) {"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 268,
                            "context": "if (!validateDirectoryName($dir_name)) {"
                        }
                    ]
                },
                {
                    "name": "buildDirectoryResult",
                    "line": 33,
                    "comment": "/**\n* Build standardized directory operation result\n*\n* Factory function for consistent result array structure across directory operations\n*\n* @param bool $success - Operation success status\n* @param string $message - Result message\n* @param string $command - Optional manual command if operation failed (for admin execution)\n* @return array - Result array with success, message, and command\n*/",
                    "code": "function buildDirectoryResult($success, $message, $command = '') {\n    return [\n        'success' => $success,\n        'message' => $message,\n        'command' => $command\n    ];\n}",
                    "parameters": [
                        {
                            "name": "success",
                            "type": "bool",
                            "description": "Operation success status"
                        },
                        {
                            "name": "message",
                            "type": "string",
                            "description": "Result message"
                        },
                        {
                            "name": "command",
                            "type": "string",
                            "description": "Optional manual command if operation failed (for admin execution)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Result array with success, message, and command",
                    "internalCalls": [
                        "buildDirectoryResult"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 11,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 219,
                            "context": "return buildDirectoryResult(false, 'Organism directory not found');"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 224,
                            "context": "return buildDirectoryResult(false, 'Invalid directory name (contains path separators)');"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 232,
                            "context": "return buildDirectoryResult(false, \"Directory '$old_name' not found\");"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 237,
                            "context": "return buildDirectoryResult(false, \"Directory '$new_name' already exists\");"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 245,
                            "context": "return buildDirectoryResult(true, \"Successfully renamed '$old_name' to '$new_name'\", $command);"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 247,
                            "context": "return buildDirectoryResult(false, 'Web server lacks permission to rename directory.', $command);"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 264,
                            "context": "return buildDirectoryResult(false, 'Organism directory not found');"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 269,
                            "context": "return buildDirectoryResult(false, 'Invalid directory name (security check failed)');"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 276,
                            "context": "return buildDirectoryResult(false, \"Directory '$dir_name' not found\");"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 284,
                            "context": "return buildDirectoryResult(true, \"Successfully deleted directory '$dir_name'\", $command);"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 286,
                            "context": "return buildDirectoryResult(false, 'Web server lacks permission to delete directory.', $command);"
                        }
                    ]
                },
                {
                    "name": "validateAssemblyDirectories",
                    "line": 51,
                    "comment": "/**\n* Validate assembly directories match database records\n*\n* Checks that for each genome in the database, there is a corresponding directory\n* named either genome_name or genome_accession\n*\n* @param string $dbFile - Path to SQLite database file\n* @param string $organism_data_dir - Path to organism data directory\n* @return array - Validation results with genomes list and mismatches\n*/",
                    "code": "function validateAssemblyDirectories($dbFile, $organism_data_dir) {\n    $result = [\n        'valid' => true,\n        'genomes' => [],\n        'mismatches' => [],\n        'errors' => []\n    ];\n    \n    if (!file_exists($dbFile) || !is_readable($dbFile)) {\n        $result['valid'] = false;\n        $result['errors'][] = 'Database not readable';\n        return $result;\n    }\n    \n    if (!is_dir($organism_data_dir)) {\n        $result['valid'] = false;\n        $result['errors'][] = 'Organism directory not found';\n        return $result;\n    }\n    \n    try {\n        $dbh = new PDO(\"sqlite:\" . $dbFile);\n        $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n        \n        // Get all genome records\n        $stmt = $dbh->query(\"SELECT genome_id, genome_name, genome_accession FROM genome ORDER BY genome_name\");\n        $genomes = $stmt->fetchAll(PDO::FETCH_ASSOC);\n        \n        // Get list of directories in organism folder\n        $dirs = array_diff(scandir($organism_data_dir), ['.', '..']);\n        $dir_names = [];\n        foreach ($dirs as $dir) {\n            $full_path = \"$organism_data_dir/$dir\";\n            if (is_dir($full_path)) {\n                $dir_names[] = $dir;\n            }\n        }\n        \n        // Check each genome record\n        foreach ($genomes as $genome) {\n            $name = $genome['genome_name'];\n            $accession = $genome['genome_accession'];\n            $genome_id = $genome['genome_id'];\n            \n            // Check if either name or accession matches a directory\n            $found_dir = null;\n            if (in_array($name, $dir_names)) {\n                $found_dir = $name;\n            } elseif (in_array($accession, $dir_names)) {\n                $found_dir = $accession;\n            }\n            \n            $result['genomes'][] = [\n                'genome_id' => $genome_id,\n                'genome_name' => $name,\n                'genome_accession' => $accession,\n                'directory_found' => $found_dir,\n                'exists' => $found_dir !== null\n            ];\n            \n            if ($found_dir === null) {\n                $result['valid'] = false;\n                $result['mismatches'][] = [\n                    'type' => 'missing_directory',\n                    'genome_name' => $name,\n                    'genome_accession' => $accession,\n                    'message' => \"No directory found matching genome_name '$name' or genome_accession '$accession'\"\n                ];\n            } elseif ($found_dir !== $name && $found_dir !== $accession) {\n                // Directory exists but doesn't match expected names\n                $result['mismatches'][] = [\n                    'type' => 'name_mismatch',\n                    'genome_name' => $name,\n                    'genome_accession' => $accession,\n                    'found_directory' => $found_dir,\n                    'message' => \"Directory '$found_dir' found, but doesn't match genome_name '$name' or genome_accession '$accession'\"\n                ];\n            }\n        }\n        \n        $dbh = null;\n    } catch (PDOException $e) {\n        $result['valid'] = false;\n        $result['errors'][] = 'Database query failed: ' . $e->getMessage();\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database file"
                        },
                        {
                            "name": "organism_data_dir",
                            "type": "string",
                            "description": "Path to organism data directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Validation results with genomes list and mismatches",
                    "internalCalls": [
                        "validateAssemblyDirectories"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 722,
                            "context": "$assembly_validation = validateAssemblyDirectories($db_file, \"$organism_data_path/$organism\");"
                        },
                        {
                            "file": "/data/moop/lib/functions_access.php",
                            "line": 163,
                            "context": "$assembly_validation = validateAssemblyDirectories($db_path, \"$organism_data/$org\");"
                        }
                    ]
                },
                {
                    "name": "validateAssemblyFastaFiles",
                    "line": 150,
                    "comment": "/**\n* Validate assembly FASTA files exist\n*\n* Checks if each assembly directory contains the required FASTA files\n* based on sequence_types patterns from site config\n*\n* @param string $organism_dir - Path to organism directory\n* @param array $sequence_types - Sequence type patterns from site_config\n* @return array - Validation results for each assembly\n*/",
                    "code": "function validateAssemblyFastaFiles($organism_dir, $sequence_types) {\n    $result = [\n        'assemblies' => [],\n        'missing_files' => []\n    ];\n    \n    if (!is_dir($organism_dir)) {\n        return $result;\n    }\n    \n    // Get all directories in organism folder\n    $dirs = array_diff(scandir($organism_dir), ['.', '..']);\n    \n    foreach ($dirs as $dir) {\n        $full_path = \"$organism_dir/$dir\";\n        if (!is_dir($full_path)) {\n            continue;\n        }\n        \n        $assembly_info = [\n            'name' => $dir,\n            'fasta_files' => [],\n            'missing_patterns' => []\n        ];\n        \n        // Check for each sequence type pattern\n        foreach ($sequence_types as $type => $config) {\n            $pattern = $config['pattern'];\n            $files = glob(\"$full_path/*$pattern\");\n            \n            if (!empty($files)) {\n                $assembly_info['fasta_files'][$type] = [\n                    'found' => true,\n                    'pattern' => $pattern,\n                    'file' => basename($files[0])\n                ];\n            } else {\n                $assembly_info['fasta_files'][$type] = [\n                    'found' => false,\n                    'pattern' => $pattern\n                ];\n                $assembly_info['missing_patterns'][] = $pattern;\n            }\n        }\n        \n        $result['assemblies'][$dir] = $assembly_info;\n        \n        if (!empty($assembly_info['missing_patterns'])) {\n            $result['missing_files'][$dir] = $assembly_info['missing_patterns'];\n        }\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "organism_dir",
                            "type": "string",
                            "description": "Path to organism directory"
                        },
                        {
                            "name": "sequence_types",
                            "type": "array",
                            "description": "Sequence type patterns from site_config"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Validation results for each assembly",
                    "internalCalls": [
                        "validateAssemblyFastaFiles"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 725,
                            "context": "$fasta_validation = validateAssemblyFastaFiles(\"$organism_data_path/$organism\", $sequence_types);"
                        }
                    ]
                },
                {
                    "name": "renameAssemblyDirectory",
                    "line": 217,
                    "comment": "/**\n* Rename an assembly directory\n*\n* Renames a directory within an organism folder from old_name to new_name\n* Used to align directory names with genome_name or genome_accession\n* Returns manual command if automatic rename fails\n*\n* @param string $organism_dir - Path to organism directory\n* @param string $old_name - Current directory name\n* @param string $new_name - New directory name\n* @return array - ['success' => bool, 'message' => string, 'command' => string (if manual fix needed)]\n*/",
                    "code": "function renameAssemblyDirectory($organism_dir, $old_name, $new_name) {\n    if (!is_dir($organism_dir)) {\n        return buildDirectoryResult(false, 'Organism directory not found');\n    }\n    \n    // Validate both names for security\n    if (!validateDirectoryName($old_name) || !validateDirectoryName($new_name)) {\n        return buildDirectoryResult(false, 'Invalid directory name (contains path separators)');\n    }\n    \n    $old_path = \"$organism_dir/$old_name\";\n    $new_path = \"$organism_dir/$new_name\";\n    \n    // Validate old directory exists\n    if (!is_dir($old_path)) {\n        return buildDirectoryResult(false, \"Directory '$old_name' not found\");\n    }\n    \n    // Check new name doesn't already exist\n    if (is_dir($new_path) || file_exists($new_path)) {\n        return buildDirectoryResult(false, \"Directory '$new_name' already exists\");\n    }\n    \n    // Build command for admin to run if automatic rename fails\n    $command = \"cd \" . escapeshellarg($organism_dir) . \" && mv \" . escapeshellarg($old_name) . \" \" . escapeshellarg($new_name);\n    \n    // Try to rename\n    if (@rename($old_path, $new_path)) {\n        return buildDirectoryResult(true, \"Successfully renamed '$old_name' to '$new_name'\", $command);\n    } else {\n        return buildDirectoryResult(false, 'Web server lacks permission to rename directory.', $command);\n    }\n}",
                    "parameters": [
                        {
                            "name": "organism_dir",
                            "type": "string",
                            "description": "Path to organism directory"
                        },
                        {
                            "name": "old_name",
                            "type": "string",
                            "description": "Current directory name"
                        },
                        {
                            "name": "new_name",
                            "type": "string",
                            "description": "New directory name"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['success' => bool, 'message' => string, 'command' => string (if manual fix needed)]",
                    "internalCalls": [
                        "renameAssemblyDirectory",
                        "buildDirectoryResult",
                        "validateDirectoryName"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "file-io",
                        "security-related",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 1092,
                            "context": "<button class=\"btn btn-info btn-sm w-100\" onclick=\"renameAssemblyDirectory(event, '<?= htmlspecialchars($organism) ?>', '<?= htmlspecialchars($safe_asm_id) ?>')\">"
                        },
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 55,
                            "context": "$result = renameAssemblyDirectory($organism_dir, $old_name, $new_name);"
                        }
                    ]
                },
                {
                    "name": "deleteAssemblyDirectory",
                    "line": 262,
                    "comment": "/**\n* Delete an assembly directory\n*\n* Recursively deletes a directory within an organism folder\n* Used to remove incorrectly named or unused assembly directories\n* Returns manual command if automatic delete fails\n*\n* @param string $organism_dir - Path to organism directory\n* @param string $dir_name - Directory name to delete\n* @return array - ['success' => bool, 'message' => string, 'command' => string (if manual fix needed)]\n*/",
                    "code": "function deleteAssemblyDirectory($organism_dir, $dir_name) {\n    if (!is_dir($organism_dir)) {\n        return buildDirectoryResult(false, 'Organism directory not found');\n    }\n    \n    // Validate directory name for security\n    if (!validateDirectoryName($dir_name)) {\n        return buildDirectoryResult(false, 'Invalid directory name (security check failed)');\n    }\n    \n    $dir_path = \"$organism_dir/$dir_name\";\n    \n    // Validate directory exists\n    if (!is_dir($dir_path)) {\n        return buildDirectoryResult(false, \"Directory '$dir_name' not found\");\n    }\n    \n    // Build command for admin to run if automatic delete fails\n    $command = \"rm -rf \" . escapeshellarg($dir_path);\n    \n    // Try to delete recursively\n    if (rrmdir($dir_path)) {\n        return buildDirectoryResult(true, \"Successfully deleted directory '$dir_name'\", $command);\n    } else {\n        return buildDirectoryResult(false, 'Web server lacks permission to delete directory.', $command);\n    }\n}",
                    "parameters": [
                        {
                            "name": "organism_dir",
                            "type": "string",
                            "description": "Path to organism directory"
                        },
                        {
                            "name": "dir_name",
                            "type": "string",
                            "description": "Directory name to delete"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['success' => bool, 'message' => string, 'command' => string (if manual fix needed)]",
                    "internalCalls": [
                        "deleteAssemblyDirectory",
                        "buildDirectoryResult",
                        "validateDirectoryName",
                        "rrmdir"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "file-io",
                        "security-related",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 1125,
                            "context": "<button class=\"btn btn-danger btn-sm w-100\" onclick=\"deleteAssemblyDirectory(event, '<?= htmlspecialchars($organism) ?>', '<?= htmlspecialchars($safe_asm_id) ?>')\">"
                        },
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 74,
                            "context": "$result = deleteAssemblyDirectory($organism_dir, $dir_name);"
                        }
                    ]
                },
                {
                    "name": "rrmdir",
                    "line": 283,
                    "comment": "/**\n* Recursively remove directory\n*\n* Helper function to delete a directory and all its contents\n*\n* @param string $dir - Directory path\n* @return bool - True if successful\n*/",
                    "code": "function rrmdir($dir) {\n    if (!is_dir($dir)) {\n        return false;\n    }\n    \n    $items = scandir($dir);\n    foreach ($items as $item) {\n        if ($item === '.' || $item === '..') {\n            continue;\n        }\n        $path = $dir . '/' . $item;\n        if (is_dir($path)) {\n            if (!rrmdir($path)) {\n                return false;\n            }\n        } else {\n            if (!@unlink($path)) {\n                return false;\n            }\n        }\n    }\n    \n    return @rmdir($dir);\n}",
                    "parameters": [
                        {
                            "name": "dir",
                            "type": "string",
                            "description": "Directory path"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "True if successful",
                    "internalCalls": [
                        "rrmdir"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 283,
                            "context": "if (rrmdir($dir_path)) {"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 310,
                            "context": "if (!rrmdir($path)) {"
                        }
                    ]
                },
                {
                    "name": "getFileWriteError",
                    "line": 330,
                    "comment": "/**\n* Check file writeability and return error info if file is not writable\n* Uses web server group and keeps original owner\n*\n* @param string $filepath - Path to file to check\n* @return array|null - Array with error details if not writable, null if ok\n*/",
                    "code": "function getFileWriteError($filepath) {\n    if (!file_exists($filepath) || is_writable($filepath)) {\n        return null;\n    }\n    \n    $webserver = getWebServerUser();\n    $web_user = $webserver['user'];\n    $web_group = $webserver['group'];\n    \n    $current_owner = function_exists('posix_getpwuid') ? posix_getpwuid(fileowner($filepath))['name'] ?? 'unknown' : 'unknown';\n    $current_group = function_exists('posix_getgrgid') ? posix_getgrgid(filegroup($filepath))['name'] ?? 'unknown' : 'unknown';\n    $perms_full = substr(sprintf('%o', fileperms($filepath)), -4);\n    $current_perms = ltrim($perms_full, '0') ?: '0';\n    \n    // Command keeps original owner but changes group to webserver and sets perms to 664\n    $fix_command = \"sudo chgrp \" . escapeshellarg($web_group) . \" \" . escapeshellarg($filepath) . \" && sudo chmod 664 \" . escapeshellarg($filepath);\n    \n    return [\n        'owner' => $current_owner,\n        'group' => $current_group,\n        'perms' => $current_perms,\n        'web_user' => $web_user,\n        'web_group' => $web_group,\n        'command' => $fix_command,\n        'file' => $filepath\n    ];\n}",
                    "parameters": [
                        {
                            "name": "filepath",
                            "type": "string",
                            "description": "Path to file to check"
                        }
                    ],
                    "returnType": "array|null",
                    "returnDescription": "Array with error details if not writable, null if ok",
                    "internalCalls": [
                        "getFileWriteError",
                        "getWebServerUser"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 7,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_site_config.php",
                            "line": 364,
                            "context": "$file_write_error = getFileWriteError($config_file);"
                        },
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 152,
                            "context": "$write_error = getFileWriteError($organism_json_path);"
                        },
                        {
                            "file": "/data/moop/admin/manage_taxonomy_tree.php",
                            "line": 27,
                            "context": "$file_write_error = getFileWriteError($tree_config_file);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 12,
                            "context": "$file_write_error = getFileWriteError($config_file);"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 39,
                            "context": "$file_write_error = getFileWriteError($groups_file);"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 42,
                            "context": "$desc_file_write_error = getFileWriteError($descriptions_file);"
                        },
                        {
                            "file": "/data/moop/admin/manage_users.php",
                            "line": 40,
                            "context": "$file_write_error = getFileWriteError($usersFile);"
                        }
                    ]
                },
                {
                    "name": "getDirectoryError",
                    "line": 364,
                    "comment": "/**\n* Check directory existence and writeability, return error info if issues found\n* Uses owner of /moop directory and web server group\n* Automatically detects if sudo is needed for the commands\n*\n* Usage:\n*   $dir_error = getDirectoryError('/path/to/directory');\n*   if ($dir_error) {\n*       // Display error alert with fix instructions\n*   }\n*\n* Can be used in any admin page that needs to ensure a directory exists and is writable.\n* Common use cases:\n*   - Image cache directories (ncbi_taxonomy, organisms, etc)\n*   - Log directories\n*   - Upload/temp directories\n*   - Any other required filesystem paths\n*\n* @param string $dirpath - Path to directory to check\n* @return array|null - Array with error details if directory missing/not writable, null if ok\n*/",
                    "code": "function getDirectoryError($dirpath) {\n    if (is_dir($dirpath) && is_writable($dirpath)) {\n        return null;\n    }\n    \n    $webserver = getWebServerUser();\n    $web_group = $webserver['group'];\n    \n    // Get owner from /moop directory\n    $moop_owner = 'ubuntu';  // Default fallback\n    if (function_exists('posix_getpwuid')) {\n        $moop_info = @stat(__DIR__ . '/..');  // Get stat of /moop parent directory\n        if ($moop_info) {\n            $moop_pwd = posix_getpwuid($moop_info['uid']);\n            if ($moop_pwd) {\n                $moop_owner = $moop_pwd['name'];\n            }\n        }\n    }\n    \n    // Detect if sudo is needed\n    $current_uid = function_exists('posix_getuid') ? posix_getuid() : null;\n    $need_sudo = false;\n    \n    if ($current_uid !== null && $current_uid !== 0) {\n        // Not running as root, check if we're the moop owner\n        $current_user = function_exists('posix_getpwuid') ? posix_getpwuid($current_uid)['name'] ?? null : null;\n        if ($current_user !== $moop_owner) {\n            $need_sudo = true;\n        }\n    }\n    \n    // Helper function to add sudo if needed\n    $cmd_prefix = $need_sudo ? 'sudo ' : '';\n    \n    if (!is_dir($dirpath)) {\n        // Directory doesn't exist\n        return [\n            'type' => 'missing',\n            'dir' => $dirpath,\n            'owner' => $moop_owner,\n            'group' => $web_group,\n            'need_sudo' => $need_sudo,\n            'commands' => [\n                \"{$cmd_prefix}mkdir -p \" . escapeshellarg($dirpath),\n                \"{$cmd_prefix}chown {$moop_owner}:{$web_group} \" . escapeshellarg($dirpath),\n                \"{$cmd_prefix}chmod 775 \" . escapeshellarg($dirpath)\n            ]\n        ];\n    }\n    \n    // Directory exists but not writable\n    $current_owner = function_exists('posix_getpwuid') ? posix_getpwuid(fileowner($dirpath))['name'] ?? 'unknown' : 'unknown';\n    $perms_full = substr(sprintf('%o', fileperms($dirpath)), -4);\n    $current_perms = ltrim($perms_full, '0') ?: '0';\n    \n    return [\n        'type' => 'not_writable',\n        'dir' => $dirpath,\n        'owner' => $current_owner,\n        'perms' => $current_perms,\n        'target_owner' => $moop_owner,\n        'target_group' => $web_group,\n        'need_sudo' => $need_sudo,\n        'commands' => [\n            \"{$cmd_prefix}chown {$moop_owner}:{$web_group} \" . escapeshellarg($dirpath),\n            \"{$cmd_prefix}chmod 775 \" . escapeshellarg($dirpath)\n        ]\n    ];\n}",
                    "parameters": [
                        {
                            "name": "dirpath",
                            "type": "string",
                            "description": "Path to directory to check"
                        }
                    ],
                    "returnType": "array|null",
                    "returnDescription": "Array with error details if directory missing/not writable, null if ok",
                    "internalCalls": [
                        "getDirectoryError",
                        "getWebServerUser"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_taxonomy_tree.php",
                            "line": 28,
                            "context": "$dir_error = getDirectoryError($absolute_images_path . '/ncbi_taxonomy');"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 50,
                            "context": "$change_log_error = @getDirectoryError($change_log_dir);"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 53,
                            "context": "$change_log_error = @getDirectoryError($change_log_dir);"
                        }
                    ]
                },
                {
                    "name": "getRegistryLastUpdate",
                    "line": 465,
                    "comment": "/**\n* Get the last update time from registry files\n*\n* Attempts to extract \"Generated:\" timestamp from HTML file first,\n* then falls back to file modification time. Also checks if any PHP files\n* in the codebase are newer than the registry, indicating it needs updating.\n*\n* @param string $htmlFile - Path to HTML registry file\n* @param string $mdFile - Path to Markdown registry file (fallback)\n* @param string $scanDirBase - Base path for scanning PHP files (defaults to parent of lib/)\n* @return array - Array with keys:\n*                 'timestamp' => Last update timestamp in format 'Y-m-d H:i:s' or 'Never'\n*                 'isStale' => Boolean indicating if registry needs updating\n*                 'status' => String message ('Up to date' or 'You should update')\n*/",
                    "code": "function getRegistryLastUpdate($htmlFile, $mdFile, $scanDirBase = null) {\n    $lastUpdate = 'Never';\n    $lastUpdateTime = 0;\n    $isStale = false;\n    \n    // Try to get from HTML file first (has \"Generated:\" timestamp)\n    if (file_exists($htmlFile) && is_readable($htmlFile)) {\n        $content = file_get_contents($htmlFile);\n        // Look for \"Generated: YYYY-MM-DD HH:MM:SS\" in the HTML\n        if (preg_match('/Generated:\\s*(\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2})/', $content, $matches)) {\n            $lastUpdate = $matches[1];\n            $lastUpdateTime = strtotime($lastUpdate);\n        }\n    }\n    \n    // Fallback to file modification time\n    if ($lastUpdateTime === 0) {\n        if (file_exists($htmlFile)) {\n            $lastUpdateTime = filemtime($htmlFile);\n            $lastUpdate = date('Y-m-d H:i:s', $lastUpdateTime);\n        } elseif (file_exists($mdFile)) {\n            $lastUpdateTime = filemtime($mdFile);\n            $lastUpdate = date('Y-m-d H:i:s', $lastUpdateTime);\n        }\n    }\n    \n    // Check if any PHP files are newer than the registry (only if registry exists)\n    if ($lastUpdateTime > 0) {\n        if ($scanDirBase === null) {\n            // Default to parent directory of lib/\n            $scanDirBase = dirname(dirname(__FILE__));\n        }\n        \n        $scanDirs = [\n            $scanDirBase . '/lib',\n            $scanDirBase . '/tools',\n            $scanDirBase . '/admin',\n            $scanDirBase\n        ];\n        \n        foreach ($scanDirs as $dir) {\n            if (!is_dir($dir)) continue;\n            \n            try {\n                $files = new RecursiveIteratorIterator(\n                    new RecursiveDirectoryIterator($dir),\n                    RecursiveIteratorIterator::LEAVES_ONLY\n                );\n                \n                foreach ($files as $file) {\n                    if (!$file->isFile() || $file->getExtension() !== 'php') continue;\n                    \n                    $filePath = $file->getRealPath();\n                    \n                    // Skip excluded files and directories\n                    $excludePatterns = ['docs/', 'logs/', 'notes/', 'not_used/', '.git/', 'generate_registry'];\n                    $skip = false;\n                    foreach ($excludePatterns as $pattern) {\n                        if (strpos($filePath, $pattern) !== false) {\n                            $skip = true;\n                            break;\n                        }\n                    }\n                    if ($skip) continue;\n                    \n                    $fileTime = filemtime($filePath);\n                    if ($fileTime > $lastUpdateTime) {\n                        $isStale = true;\n                        break 2;\n                    }\n                }\n            } catch (Exception $e) {\n                error_log(\"Error checking PHP file timestamps: \" . $e->getMessage());\n            }\n        }\n    }\n    \n    return [\n        'timestamp' => $lastUpdate,\n        'isStale' => $isStale,\n        'status' => $isStale ? 'You should update' : 'Up to date'\n    ];\n}",
                    "parameters": [
                        {
                            "name": "htmlFile",
                            "type": "string",
                            "description": "Path to HTML registry file"
                        },
                        {
                            "name": "mdFile",
                            "type": "string",
                            "description": "Path to Markdown registry file (fallback)"
                        },
                        {
                            "name": "scanDirBase",
                            "type": "string",
                            "description": "Base path for scanning PHP files (defaults to parent of lib/)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with keys:",
                    "internalCalls": [
                        "getRegistryLastUpdate"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/admin/pages/manage_js_registry.php",
                            "line": 21,
                            "context": "$registryStatus = getRegistryLastUpdate($json_registry, $json_registry);"
                        },
                        {
                            "file": "/data/moop/admin/manage_js_registry.php",
                            "line": 30,
                            "context": "$registryStatus = getRegistryLastUpdate($json_registry, $json_registry);"
                        },
                        {
                            "file": "/data/moop/admin/manage_registry.php",
                            "line": 27,
                            "context": "$registryStatus = getRegistryLastUpdate($json_registry, $json_registry);"
                        }
                    ]
                },
                {
                    "name": "getNewestSqliteModTime",
                    "line": 559,
                    "comment": "/**\n* Get the newest SQLite database modification timestamp\n*\n* Scans all SQLite files in organism subdirectories and returns the most recent modification time\n* Each organism has a structure: organisms/OrganismName/organism.sqlite\n*\n* @param string $organisms_path - Path to organisms directory\n* @return array - Array with 'timestamp' (Y-m-d H:i:s), 'unix_time' (timestamp), and 'iso8601'\n*                 Returns null if no SQLite files found\n*/",
                    "code": "function getNewestSqliteModTime($organisms_path) {\n    if (!is_dir($organisms_path)) {\n        return null;\n    }\n    \n    $newest_time = 0;\n    $found = false;\n    \n    try {\n        // Scan organism directories one level deep\n        $organisms = scandir($organisms_path);\n        foreach ($organisms as $organism) {\n            if ($organism === '.' || $organism === '..') {\n                continue;\n            }\n            \n            $organism_dir = $organisms_path . '/' . $organism;\n            if (!is_dir($organism_dir)) {\n                continue;\n            }\n            \n            $sqlite_file = $organism_dir . '/organism.sqlite';\n            if (file_exists($sqlite_file)) {\n                $mtime = filemtime($sqlite_file);\n                if ($mtime > $newest_time) {\n                    $newest_time = $mtime;\n                    $found = true;\n                }\n            }\n        }\n    } catch (Exception $e) {\n        error_log(\"Error scanning SQLite files: \" . $e->getMessage());\n        return null;\n    }\n    \n    if (!$found) {\n        return null;\n    }\n    \n    return [\n        'unix_time' => $newest_time,\n        'timestamp' => date('Y-m-d H:i:s', $newest_time),\n        'iso8601' => date('c', $newest_time)\n    ];\n}",
                    "parameters": [
                        {
                            "name": "organisms_path",
                            "type": "string",
                            "description": "Path to organisms directory"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array with 'timestamp' (Y-m-d H:i:s), 'unix_time' (timestamp), and 'iso8601'",
                    "internalCalls": [
                        "getNewestSqliteModTime"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 76,
                            "context": "$newest_mod_info = getNewestSqliteModTime($organisms_path);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_json.php",
            "count": 10,
            "functions": [
                {
                    "name": "loadJsonFile",
                    "line": 14,
                    "comment": "/**\n* Load JSON file safely with error handling\n*\n* @param string $path Path to JSON file\n* @param mixed $default Default value if file doesn't exist (default: [])\n* @return mixed Decoded JSON data or default value\n*/",
                    "code": "function loadJsonFile($path, $default = []) {\n    if (!file_exists($path)) {\n        return $default;\n    }\n    \n    $json_content = file_get_contents($path);\n    if ($json_content === false) {\n        return $default;\n    }\n    \n    $data = json_decode($json_content, true);\n    return $data !== null ? $data : $default;\n}",
                    "parameters": [
                        {
                            "name": "path",
                            "type": "string",
                            "description": "Path to JSON file"
                        },
                        {
                            "name": "default",
                            "type": "mixed",
                            "description": "Default value if file doesn't exist (default: [])"
                        }
                    ],
                    "returnType": "mixed",
                    "returnDescription": "Decoded JSON data or default value",
                    "internalCalls": [
                        "loadJsonFile"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 12,
                    "usages": [
                        {
                            "file": "/data/moop/lib/database_queries.php",
                            "line": 643,
                            "context": "$annotation_config = loadJsonFile($config_file, []);"
                        },
                        {
                            "file": "/data/moop/lib/functions_database.php",
                            "line": 318,
                            "context": "$organism_info = loadJsonFile($organism_json_path);"
                        },
                        {
                            "file": "/data/moop/lib/functions_data.php",
                            "line": 371,
                            "context": "$organism_info = loadJsonFile($organism_json_path);"
                        },
                        {
                            "file": "/data/moop/lib/functions_json.php",
                            "line": 88,
                            "context": "$existing = loadJsonFile($file_path);"
                        },
                        {
                            "file": "/data/moop/tools/groups.php",
                            "line": 56,
                            "context": "$group_descriptions = loadJsonFile($group_descriptions_file, []);"
                        },
                        {
                            "file": "/data/moop/tools/get_annotation_sources_grouped.php",
                            "line": 43,
                            "context": "$annotation_config = loadJsonFile($config_file, []);"
                        },
                        {
                            "file": "/data/moop/admin/admin_access_check.php",
                            "line": 8,
                            "context": "$users = loadJsonFile($usersFile, []);"
                        },
                        {
                            "file": "/data/moop/admin/manage_taxonomy_tree.php",
                            "line": 88,
                            "context": "$current_tree = loadJsonFile($tree_config_file, null);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 9,
                            "context": "$annotation_config = loadJsonFile($config_file, []);"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 32,
                            "context": "$groups_data = loadJsonFile($groups_file, []);"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 36,
                            "context": "$descriptions_data = loadJsonFile($descriptions_file, []);"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 59,
                            "context": "$descriptions_data = loadJsonFile($descriptions_file, []);"
                        }
                    ]
                },
                {
                    "name": "loadJsonFileRequired",
                    "line": 36,
                    "comment": "/**\n* Load JSON file and require it to exist\n*\n* @param string $path Path to JSON file\n* @param string $errorMsg Error message to log if file missing\n* @param bool $exitOnError Whether to exit if file not found (default: true)\n* @return mixed Decoded JSON data or empty array if error\n*/",
                    "code": "function loadJsonFileRequired($path, $errorMsg = '', $exitOnError = false) {\n    if (!file_exists($path)) {\n        if ($errorMsg) {\n            error_log($errorMsg);\n        }\n        if ($exitOnError) {\n            header(\"HTTP/1.1 500 Internal Server Error\");\n            exit(\"Required data file not found\");\n        }\n        return [];\n    }\n    \n    $json_content = file_get_contents($path);\n    if ($json_content === false) {\n        $msg = $errorMsg ?: \"Failed to read file: $path\";\n        error_log($msg);\n        if ($exitOnError) {\n            header(\"HTTP/1.1 500 Internal Server Error\");\n            exit(\"Failed to read required data\");\n        }\n        return [];\n    }\n    \n    $data = json_decode($json_content, true);\n    if ($data === null) {\n        $msg = $errorMsg ?: \"Invalid JSON in file: $path\";\n        error_log($msg);\n        if ($exitOnError) {\n            header(\"HTTP/1.1 500 Internal Server Error\");\n            exit(\"Invalid data format\");\n        }\n        return [];\n    }\n    \n    return $data;\n}",
                    "parameters": [
                        {
                            "name": "path",
                            "type": "string",
                            "description": "Path to JSON file"
                        },
                        {
                            "name": "errorMsg",
                            "type": "string",
                            "description": "Error message to log if file missing"
                        },
                        {
                            "name": "exitOnError",
                            "type": "bool",
                            "description": "Whether to exit if file not found (default: true)"
                        }
                    ],
                    "returnType": "mixed",
                    "returnDescription": "Decoded JSON data or empty array if error",
                    "internalCalls": [
                        "loadJsonFileRequired"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 93,
                            "context": "$annotation_config = loadJsonFileRequired($annotation_config_file, \"Missing annotation_config.json\");"
                        }
                    ]
                },
                {
                    "name": "loadAndMergeJson",
                    "line": 81,
                    "comment": "/**\n* Load existing JSON file and merge with new data\n* Handles wrapped JSON automatically, preserves existing fields not in merge data\n*\n* @param string $file_path Path to JSON file to load\n* @param array $new_data New data to merge in (overwrites matching keys)\n* @return array Merged data (or just new_data if file doesn't exist)\n*/",
                    "code": "function loadAndMergeJson($file_path, $new_data = []) {\n    // If file doesn't exist, just return new data\n    if (!file_exists($file_path)) {\n        return $new_data;\n    }\n    \n    // Load existing data\n    $existing = loadJsonFile($file_path);\n    \n    if (!is_array($existing)) {\n        return $new_data;\n    }\n    \n    // Handle wrapped JSON (extra outer braces)\n    if (!isset($existing['genus']) && !isset($existing['common_name'])) {\n        $keys = array_keys($existing);\n        if (count($keys) > 0 && is_array($existing[$keys[0]])) {\n            $existing = $existing[$keys[0]];\n        }\n    }\n    \n    // Merge: existing fields are preserved, new data overwrites matching keys\n    return array_merge($existing, $new_data);\n}",
                    "parameters": [
                        {
                            "name": "file_path",
                            "type": "string",
                            "description": "Path to JSON file to load"
                        },
                        {
                            "name": "new_data",
                            "type": "array",
                            "description": "New data to merge in (overwrites matching keys)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Merged data (or just new_data if file doesn't exist)",
                    "internalCalls": [
                        "loadAndMergeJson",
                        "loadJsonFile"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 141,
                            "context": "$metadata = loadAndMergeJson($organism_json_path, $metadata);"
                        }
                    ]
                },
                {
                    "name": "decodeJsonString",
                    "line": 113,
                    "comment": "/**\n* Decode JSON string safely with type checking\n*\n* @param string $json_string JSON string to decode\n* @param bool $as_array Return as array (default: true)\n* @return array|null Decoded data or null if invalid\n*/",
                    "code": "function decodeJsonString($json_string, $as_array = true) {\n    if (empty($json_string)) {\n        return $as_array ? [] : null;\n    }\n    \n    $decoded = json_decode($json_string, $as_array);\n    \n    // Validate it decoded properly\n    if ($decoded === null && json_last_error() !== JSON_ERROR_NONE) {\n        error_log(\"JSON decode error: \" . json_last_error_msg());\n        return $as_array ? [] : null;\n    }\n    \n    return $decoded;\n}",
                    "parameters": [
                        {
                            "name": "json_string",
                            "type": "string",
                            "description": "JSON string to decode"
                        },
                        {
                            "name": "as_array",
                            "type": "bool",
                            "description": "Return as array (default: true)"
                        }
                    ],
                    "returnType": "array|null",
                    "returnDescription": "Decoded data or null if invalid",
                    "internalCalls": [
                        "decodeJsonString"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "recursive"
                    ],
                    "usageCount": 4,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 109,
                            "context": "$images = decodeJsonString($images_json);"
                        },
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 110,
                            "context": "$html_p = decodeJsonString($html_p_json);"
                        },
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 111,
                            "context": "$parents = decodeJsonString($parents_json);"
                        },
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 112,
                            "context": "$children = decodeJsonString($children_json);"
                        }
                    ]
                },
                {
                    "name": "saveJsonFile",
                    "line": 137,
                    "comment": "/**\n* Save data to JSON file with pretty printing\n* Writes JSON data with readable formatting\n*\n* @param string $path Path to JSON file to save\n* @param array $data Data to encode and save\n* @return int|false Number of bytes written, or false on failure\n*/",
                    "code": "function saveJsonFile($path, $data) {\n    return file_put_contents($path, json_encode($data, JSON_PRETTY_PRINT));\n}",
                    "parameters": [
                        {
                            "name": "path",
                            "type": "string",
                            "description": "Path to JSON file to save"
                        },
                        {
                            "name": "data",
                            "type": "array",
                            "description": "Data to encode and save"
                        }
                    ],
                    "returnType": "int|false",
                    "returnDescription": "Number of bytes written, or false on failure",
                    "internalCalls": [
                        "saveJsonFile"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 14,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 125,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 158,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 183,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 197,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 209,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 229,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 249,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 275,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 284,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 304,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 318,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 333,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 345,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        },
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 360,
                            "context": "saveJsonFile($config_file, $annotation_config);"
                        }
                    ]
                },
                {
                    "name": "getAnnotationTypeMapping",
                    "line": 148,
                    "comment": "/**\n* Build mapping from DB types to canonical config names\n* Uses synonyms to map all aliases to their canonical entry\n*\n* @param array $annotation_config - Loaded annotation_config.json\n* @return array - [db_type => canonical_name] mapping\n*/",
                    "code": "function getAnnotationTypeMapping($annotation_config) {\n    $mapping = [];\n    \n    if (!isset($annotation_config['annotation_types'])) {\n        return $mapping;\n    }\n    \n    foreach ($annotation_config['annotation_types'] as $canonical_name => $config) {\n        // Map the canonical name to itself\n        $mapping[$canonical_name] = $canonical_name;\n        \n        // Map each synonym to this canonical name\n        if (isset($config['synonyms']) && is_array($config['synonyms'])) {\n            foreach ($config['synonyms'] as $synonym) {\n                $mapping[$synonym] = $canonical_name;\n            }\n        }\n    }\n    \n    return $mapping;\n}",
                    "parameters": [
                        {
                            "name": "annotation_config",
                            "type": "array",
                            "description": "Loaded annotation_config.json"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "[db_type => canonical_name] mapping",
                    "internalCalls": [
                        "getAnnotationTypeMapping"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_json.php",
                            "line": 185,
                            "context": "$mapping = getAnnotationTypeMapping($annotation_config);"
                        },
                        {
                            "file": "/data/moop/lib/functions_json.php",
                            "line": 305,
                            "context": "$mapping = getAnnotationTypeMapping($annotation_config);"
                        }
                    ]
                },
                {
                    "name": "syncAnnotationTypes",
                    "line": 179,
                    "comment": "/**\n* Synchronize annotation types between config and database\n* Creates entries for unmapped DB types, marks unused entries\n* Populates annotation_count and feature_count for each type\n*\n* @param array $annotation_config - Current annotation_config.json\n* @param array $db_types - [annotation_type => ['annotation_count' => N, 'feature_count' => M]]\n* @return array - Updated config with sync metadata\n*/",
                    "code": "function syncAnnotationTypes($annotation_config, $db_types) {\n    if (!isset($annotation_config['annotation_types'])) {\n        $annotation_config['annotation_types'] = [];\n    }\n    \n    // Get current mapping (canonical + synonyms)\n    $mapping = getAnnotationTypeMapping($annotation_config);\n    \n    // Mark all existing entries as not in database initially\n    foreach ($annotation_config['annotation_types'] as &$config) {\n        $config['in_database'] = false;\n        $config['annotation_count'] = 0;\n        $config['feature_count'] = 0;\n    }\n    unset($config);\n    \n    // Check which DB types are covered by existing config\n    $mapped_db_types = [];\n    foreach ($db_types as $db_type => $counts) {\n        if (isset($mapping[$db_type])) {\n            // This DB type maps to an existing config entry\n            $canonical = $mapping[$db_type];\n            $annotation_config['annotation_types'][$canonical]['in_database'] = true;\n            $annotation_config['annotation_types'][$canonical]['annotation_count'] += $counts['annotation_count'];\n            $annotation_config['annotation_types'][$canonical]['feature_count'] += $counts['feature_count'];\n            $mapped_db_types[$db_type] = true;\n        }\n    }\n    \n    // Add unmapped DB types as new entries\n    $next_order = 1;\n    if (!empty($annotation_config['annotation_types'])) {\n        $orders = array_map(function($c) { return $c['order'] ?? 0; }, \n                          $annotation_config['annotation_types']);\n        $next_order = max($orders) + 1;\n    }\n    \n    foreach ($db_types as $db_type => $counts) {\n        if (!isset($mapped_db_types[$db_type])) {\n            // New type not in config - add it\n            $annotation_config['annotation_types'][$db_type] = [\n                'display_name' => $db_type,\n                'display_label' => $db_type,\n                'color' => 'secondary',\n                'order' => $next_order,\n                'description' => '',\n                'enabled' => true,\n                'synonyms' => [],\n                'in_database' => true,\n                'annotation_count' => $counts['annotation_count'],\n                'feature_count' => $counts['feature_count'],\n                'new' => true\n            ];\n            $next_order++;\n        }\n    }\n    \n    return $annotation_config;\n}",
                    "parameters": [
                        {
                            "name": "annotation_config",
                            "type": "array",
                            "description": "Current annotation_config.json"
                        },
                        {
                            "name": "db_types",
                            "type": "array",
                            "description": "[annotation_type => ['annotation_count' => N, 'feature_count' => M]]"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Updated config with sync metadata",
                    "internalCalls": [
                        "syncAnnotationTypes",
                        "getAnnotationTypeMapping"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 104,
                            "context": "$annotation_config = syncAnnotationTypes($annotation_config, $all_db_annotation_types);"
                        }
                    ]
                },
                {
                    "name": "consolidateSynonym",
                    "line": 248,
                    "comment": "/**\n* Consolidate a synonym entry into the canonical entry\n* Removes the synonym as separate entry, adds to synonyms array\n*\n* @param array &$annotation_config - Reference to config (modified in place)\n* @param string $canonical_name - Target canonical entry\n* @param string $synonym_name - Synonym entry to consolidate\n* @return bool - Success status\n*/",
                    "code": "function consolidateSynonym(&$annotation_config, $canonical_name, $synonym_name) {\n    if (!isset($annotation_config['annotation_types'][$canonical_name])) {\n        return false;\n    }\n    \n    if (!isset($annotation_config['annotation_types'][$synonym_name])) {\n        return false;\n    }\n    \n    // Add synonym entry to synonyms array\n    if (!isset($annotation_config['annotation_types'][$canonical_name]['synonyms'])) {\n        $annotation_config['annotation_types'][$canonical_name]['synonyms'] = [];\n    }\n    \n    if (!in_array($synonym_name, $annotation_config['annotation_types'][$canonical_name]['synonyms'])) {\n        $annotation_config['annotation_types'][$canonical_name]['synonyms'][] = $synonym_name;\n    }\n    \n    // Combine counts\n    $synonym_annotation_count = $annotation_config['annotation_types'][$synonym_name]['annotation_count'] ?? 0;\n    $synonym_feature_count = $annotation_config['annotation_types'][$synonym_name]['feature_count'] ?? 0;\n    \n    if ($synonym_annotation_count > 0) {\n        $annotation_config['annotation_types'][$canonical_name]['annotation_count'] = \n            ($annotation_config['annotation_types'][$canonical_name]['annotation_count'] ?? 0) + $synonym_annotation_count;\n    }\n    \n    if ($synonym_feature_count > 0) {\n        $annotation_config['annotation_types'][$canonical_name]['feature_count'] = \n            ($annotation_config['annotation_types'][$canonical_name]['feature_count'] ?? 0) + $synonym_feature_count;\n    }\n    \n    // Mark canonical as in database if synonym was\n    if ($annotation_config['annotation_types'][$synonym_name]['in_database'] ?? false) {\n        $annotation_config['annotation_types'][$canonical_name]['in_database'] = true;\n    }\n    \n    // Remove the synonym entry\n    unset($annotation_config['annotation_types'][$synonym_name]);\n    \n    return true;\n}",
                    "parameters": [
                        {
                            "name": "canonical_name",
                            "type": "string",
                            "description": "Target canonical entry"
                        },
                        {
                            "name": "synonym_name",
                            "type": "string",
                            "description": "Synonym entry to consolidate"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "Success status",
                    "internalCalls": [
                        "consolidateSynonym"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "getAnnotationDisplayLabel",
                    "line": 299,
                    "comment": "/**\n* Get display label for an annotation type from database\n* Resolves through synonym mapping and returns configured display_label\n*\n* @param string $db_annotation_type - Type from annotation_source table\n* @param array $annotation_config - Loaded annotation_config.json\n* @return string - Display label to use in UI\n*/",
                    "code": "function getAnnotationDisplayLabel($db_annotation_type, $annotation_config) {\n    if (!isset($annotation_config['annotation_types'])) {\n        return $db_annotation_type;\n    }\n    \n    // Get mapping\n    $mapping = getAnnotationTypeMapping($annotation_config);\n    \n    // Find canonical name\n    if (isset($mapping[$db_annotation_type])) {\n        $canonical = $mapping[$db_annotation_type];\n        \n        // Get the configured display label for this canonical entry\n        if (isset($annotation_config['annotation_types'][$canonical]['display_label'])) {\n            return $annotation_config['annotation_types'][$canonical]['display_label'];\n        }\n        \n        // Fallback to display_name\n        if (isset($annotation_config['annotation_types'][$canonical]['display_name'])) {\n            return $annotation_config['annotation_types'][$canonical]['display_name'];\n        }\n        \n        return $canonical;\n    }\n    \n    return $db_annotation_type;\n}",
                    "parameters": [
                        {
                            "name": "db_annotation_type",
                            "type": "string",
                            "description": "Type from annotation_source table"
                        },
                        {
                            "name": "annotation_config",
                            "type": "array",
                            "description": "Loaded annotation_config.json"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Display label to use in UI",
                    "internalCalls": [
                        "getAnnotationDisplayLabel",
                        "getAnnotationTypeMapping"
                    ],
                    "category": "ui",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "shouldUpdateAnnotationCounts",
                    "line": 337,
                    "comment": "/**\n* Check if annotation counts need to be updated\n*\n* Compares the stored SQLite modification time with the current newest modification time.\n* If they differ or if counts are empty, returns true to indicate update is needed.\n*\n* @param array $annotation_config - Current annotation config from JSON\n* @param array $newest_mod_info - Result from getNewestSqliteModTime()\n* @return bool - True if counts need to be updated\n*/",
                    "code": "function shouldUpdateAnnotationCounts($annotation_config, $newest_mod_info) {\n    // If no SQLite files found, no need to update\n    if ($newest_mod_info === null) {\n        return false;\n    }\n    \n    // If no stored modification time, update is needed\n    if (!isset($annotation_config['sqlite_mod_time'])) {\n        return true;\n    }\n    \n    // If modification time changed, update is needed\n    if ($annotation_config['sqlite_mod_time'] !== $newest_mod_info['unix_time']) {\n        return true;\n    }\n    \n    // Check if any annotation types are missing counts or have empty/zero values\n    if (isset($annotation_config['annotation_types'])) {\n        foreach ($annotation_config['annotation_types'] as $type_config) {\n            // Check if counts don't exist or are empty/zero\n            if (!isset($type_config['annotation_count']) || $type_config['annotation_count'] === '' || $type_config['annotation_count'] === null) {\n                return true;\n            }\n            if (!isset($type_config['feature_count']) || $type_config['feature_count'] === '' || $type_config['feature_count'] === null) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}",
                    "parameters": [
                        {
                            "name": "annotation_config",
                            "type": "array",
                            "description": "Current annotation config from JSON"
                        },
                        {
                            "name": "newest_mod_info",
                            "type": "array",
                            "description": "Result from getNewestSqliteModTime()"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "True if counts need to be updated",
                    "internalCalls": [
                        "shouldUpdateAnnotationCounts"
                    ],
                    "category": "utility",
                    "tags": [
                        "mutation",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_annotations.php",
                            "line": 79,
                            "context": "$need_update = shouldUpdateAnnotationCounts($annotation_config, $newest_mod_info);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_system.php",
            "count": 5,
            "functions": [
                {
                    "name": "getWebServerUser",
                    "line": 14,
                    "comment": "/**\n* Get the web server user and group\n*\n* Detects the user running the current PHP process (web server)\n*\n* @return array - ['user' => string, 'group' => string]\n*/",
                    "code": "function getWebServerUser() {\n    $user = 'www-data';\n    $group = 'www-data';\n    \n    // Try to get the actual user running this process\n    if (function_exists('posix_getuid')) {\n        $uid = posix_getuid();\n        $pwinfo = posix_getpwuid($uid);\n        if ($pwinfo !== false) {\n            $user = $pwinfo['name'];\n        }\n    }\n    \n    // Try to get the actual group\n    if (function_exists('posix_getgid')) {\n        $gid = posix_getgid();\n        $grinfo = posix_getgrgid($gid);\n        if ($grinfo !== false) {\n            $group = $grinfo['name'];\n        }\n    }\n    \n    return ['user' => $user, 'group' => $group];\n}",
                    "parameters": [],
                    "returnType": "array",
                    "returnDescription": "['user' => string, 'group' => string]",
                    "internalCalls": [
                        "getWebServerUser"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 7,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 335,
                            "context": "$webserver = getWebServerUser();"
                        },
                        {
                            "file": "/data/moop/lib/functions_filesystem.php",
                            "line": 384,
                            "context": "$webserver = getWebServerUser();"
                        },
                        {
                            "file": "/data/moop/lib/functions_system.php",
                            "line": 66,
                            "context": "$webserver = getWebServerUser();"
                        },
                        {
                            "file": "/data/moop/lib/functions_system.php",
                            "line": 133,
                            "context": "$webserver = getWebServerUser();"
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 209,
                            "context": "$webserver = getWebServerUser();"
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 375,
                            "context": "$webserver = getWebServerUser();"
                        },
                        {
                            "file": "/data/moop/admin/manage_filesystem_permissions.php",
                            "line": 22,
                            "context": "$webserver = getWebServerUser();"
                        }
                    ]
                },
                {
                    "name": "fixDatabasePermissions",
                    "line": 48,
                    "comment": "/**\n* Attempt to fix database file permissions\n*\n* Tries to make database readable by web server user.\n* Returns instructions if automatic fix fails.\n*\n* @param string $dbFile - Path to database file\n* @return array - ['success' => bool, 'message' => string, 'command' => string (if manual fix needed)]\n*/",
                    "code": "function fixDatabasePermissions($dbFile) {\n    $result = [\n        'success' => false,\n        'message' => '',\n        'command' => ''\n    ];\n    \n    if (!file_exists($dbFile)) {\n        $result['message'] = 'Database file not found';\n        return $result;\n    }\n    \n    if (!is_file($dbFile)) {\n        $result['message'] = 'Path is not a file';\n        return $result;\n    }\n    \n    // Get web server user\n    $webserver = getWebServerUser();\n    $web_user = $webserver['user'];\n    $web_group = $webserver['group'];\n    \n    // Get file info for reporting\n    $file_owner = function_exists('posix_getpwuid') ? posix_getpwuid(fileowner($dbFile))['name'] : 'unknown';\n    $file_group = function_exists('posix_getgrgid') ? posix_getgrgid(filegroup($dbFile))['name'] : 'unknown';\n    $current_perms = substr(sprintf('%o', fileperms($dbFile)), -4);\n    \n    // Build command for admin to run if automatic fix fails\n    $result['command'] = \"sudo chmod 644 \" . escapeshellarg($dbFile) . \" && sudo chown \" . escapeshellarg(\"$web_user:$web_group\") . \" \" . escapeshellarg($dbFile);\n    \n    // Try to fix permissions\n    try {\n        // Try chmod to make readable (644 = rw-r--r--)\n        $chmod_result = @chmod($dbFile, 0644);\n        \n        if (!$chmod_result) {\n            $result['message'] = 'Web server lacks permission to change file permissions.';\n            return $result;\n        }\n        \n        // Try to change ownership to web server user (may fail if not root)\n        @chown($dbFile, $web_user);\n        @chgrp($dbFile, $web_group);\n        \n        // Verify it worked\n        if (is_readable($dbFile)) {\n            $result['success'] = true;\n            $result['message'] = 'Permissions fixed successfully! Database is now readable.';\n        } else {\n            $result['message'] = 'Permissions were modified but file still not readable.';\n        }\n        \n    } catch (Exception $e) {\n        $result['message'] = 'Error: ' . $e->getMessage();\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to database file"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "['success' => bool, 'message' => string, 'command' => string (if manual fix needed)]",
                    "internalCalls": [
                        "fixDatabasePermissions",
                        "getWebServerUser"
                    ],
                    "category": "validation",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "security-related",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/admin/pages/manage_organisms.php",
                            "line": 647,
                            "context": "<button class=\"btn btn-warning btn-sm\" onclick=\"fixDatabasePermissions(event, '<?= $org_safe ?>')\">"
                        },
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 35,
                            "context": "$result = fixDatabasePermissions($db_file);"
                        }
                    ]
                },
                {
                    "name": "fixFilePermissions",
                    "line": 117,
                    "comment": "/**\n* Fix file or directory permissions (AJAX handler)\n*\n* Called via AJAX when user clicks \"Fix Permissions\" button.\n* Only works if web server has sufficient permissions to chmod/chown.\n*\n* @param string $file_path Path to file or directory\n* @param string $file_type 'file' or 'directory'\n* @return array Result array with 'success', 'message' keys\n*/",
                    "code": "function fixFilePermissions($file_path, $file_type = 'file') {\n    $result = [\n        'success' => false,\n        'message' => '',\n        'command' => ''\n    ];\n    \n    // Validate input\n    if (empty($file_path) || !file_exists($file_path)) {\n        $result['message'] = 'File or directory not found';\n        return $result;\n    }\n    \n    $is_dir = is_dir($file_path);\n    \n    // Get web server user info\n    $webserver = getWebServerUser();\n    $web_user = $webserver['user'];\n    $web_group = $webserver['group'];\n    \n    try {\n        if ($is_dir) {\n            // For directories: chmod 755 (rwxr-xr-x)\n            $chmod_result = @chmod($file_path, 0755);\n            \n            if (!$chmod_result) {\n                $result['message'] = 'Web server lacks permission to change directory permissions.';\n                return $result;\n            }\n            \n            // Verify it worked\n            if (is_readable($file_path) && is_writable($file_path)) {\n                $result['success'] = true;\n                $result['message'] = 'Directory permissions fixed successfully!';\n            } else {\n                $result['message'] = 'Permissions were modified but directory still has issues.';\n            }\n        } else {\n            // For files: chmod 664 (rw-rw-r--)\n            $chmod_result = @chmod($file_path, 0664);\n            \n            if ($chmod_result) {\n                // chmod worked\n                if (is_readable($file_path) && is_writable($file_path)) {\n                    $result['success'] = true;\n                    $result['message'] = 'File permissions fixed successfully!';\n                } else {\n                    $result['message'] = 'Permissions were modified but file still has issues.';\n                }\n            } else {\n                // chmod failed - try to recreate the file if parent is writable\n                $parent_dir = dirname($file_path);\n                if (is_writable($parent_dir)) {\n                    // Read current content\n                    $content = @file_get_contents($file_path);\n                    if ($content === false) {\n                        $result['message'] = 'Cannot read file content for recreation.';\n                        return $result;\n                    }\n                    \n                    // Delete and recreate with new permissions\n                    @unlink($file_path);\n                    $write_result = @file_put_contents($file_path, $content);\n                    \n                    if ($write_result === false) {\n                        $result['message'] = 'Failed to recreate file with new permissions.';\n                        return $result;\n                    }\n                    \n                    // chmod the newly created file\n                    @chmod($file_path, 0664);\n                    \n                    if (is_readable($file_path) && is_writable($file_path)) {\n                        $result['success'] = true;\n                        $result['message'] = 'File permissions fixed successfully!';\n                    } else {\n                        $result['message'] = 'File recreated but permissions still have issues.';\n                    }\n                } else {\n                    $result['message'] = 'Web server lacks permission to change file permissions.';\n                }\n            }\n        }\n    } catch (Exception $e) {\n        $result['message'] = 'Error: ' . $e->getMessage();\n    }\n    \n    return $result;\n}",
                    "parameters": [
                        {
                            "name": "file_path",
                            "type": "string",
                            "description": "Path to file or directory"
                        },
                        {
                            "name": "file_type",
                            "type": "string",
                            "description": "'file' or 'directory'"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Result array with 'success', 'message' keys",
                    "internalCalls": [
                        "fixFilePermissions",
                        "getWebServerUser"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "file-io",
                        "security-related",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_system.php",
                            "line": 234,
                            "context": "return fixFilePermissions($file_path, $file_type);"
                        },
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 421,
                            "context": "$html .= '  <button class=\"btn btn-warning btn-sm\" onclick=\\'fixFilePermissions(event, ' . json_encode($file_path) . ', ' . json_encode($file_type) . ', ' . json_encode($organism) . ', ' . json_encode($resultId) . ');\\'>' . \"\\n\";"
                        }
                    ]
                },
                {
                    "name": "handleFixFilePermissionsAjax",
                    "line": 213,
                    "comment": "/**\n* Handle file permission fix AJAX request\n*\n* Call this in your admin script's POST handler:\n* if (isset($_POST['action']) && $_POST['action'] === 'fix_file_permissions') {\n*     header('Content-Type: application/json');\n*     echo json_encode(handleFixFilePermissionsAjax());\n*     exit;\n* }\n*\n* @return array JSON-serializable result array\n*/",
                    "code": "function handleFixFilePermissionsAjax() {\n    if (empty($_POST['file_path'])) {\n        return ['success' => false, 'message' => 'File path not provided'];\n    }\n    \n    $file_path = $_POST['file_path'];\n    $file_type = $_POST['file_type'] ?? 'file';\n    \n    // Basic security: prevent directory traversal\n    $file_path = realpath($file_path);\n    \n    if (!$file_path || !file_exists($file_path)) {\n        return ['success' => false, 'message' => 'File or directory not found'];\n    }\n    \n    return fixFilePermissions($file_path, $file_type);\n}",
                    "parameters": [],
                    "returnType": "array",
                    "returnDescription": "JSON-serializable result array",
                    "internalCalls": [
                        "handleFixFilePermissionsAjax",
                        "fixFilePermissions"
                    ],
                    "category": "filesystem",
                    "tags": [
                        "readonly",
                        "file-io",
                        "security-related",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_system.php",
                            "line": 273,
                            "context": "echo json_encode(handleFixFilePermissionsAjax());"
                        }
                    ]
                },
                {
                    "name": "handleAdminAjax",
                    "line": 251,
                    "comment": "/**\n* Handle AJAX requests at page start\n*\n* Consolidates common AJAX request handling for admin pages.\n* Handles JSON response headers and early exit for AJAX requests.\n*\n* Supported actions:\n* - 'fix_file_permissions': Calls handleFixFilePermissionsAjax()\n* - Custom actions: Pass callback function to handle additional actions\n*\n* @param callable|null $customHandler - Optional callback for custom actions\n*                                       Receives $_POST['action'] and should return true if handled\n* @return void - Exits after sending response\n*/",
                    "code": "function handleAdminAjax($customHandler = null) {\n    if (!isset($_POST['action'])) {\n        return; // Not a POST request with action\n    }\n    \n    $action = $_POST['action'];\n    $isStandardAction = ($action === 'fix_file_permissions');\n    $hasCustomHandler = ($customHandler && is_callable($customHandler));\n    \n    // Only process AJAX requests if we have a handler for them\n    if (!$isStandardAction && !$hasCustomHandler) {\n        return; // No handler for this action, let page process normally\n    }\n    \n    // Only clear buffer for AJAX handlers\n    while (ob_get_level()) {\n        ob_end_clean();\n    }\n    header('Content-Type: application/json');\n    \n    // Handle standard fix_file_permissions action\n    if ($isStandardAction) {\n        echo json_encode(handleFixFilePermissionsAjax());\n        exit;\n    }\n    \n    // Pass to custom handler if provided\n    if ($hasCustomHandler) {\n        $handled = call_user_func($customHandler, $action);\n        if ($handled) {\n            exit;\n        }\n    }\n}",
                    "parameters": [
                        {
                            "name": "customHandler",
                            "type": "callable|null",
                            "description": "Optional callback for custom actions"
                        }
                    ],
                    "returnType": "void",
                    "returnDescription": "Exits after sending response",
                    "internalCalls": [
                        "handleAdminAjax",
                        "handleFixFilePermissionsAjax"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "security-related",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 4,
                    "usages": [
                        {
                            "file": "/data/moop/admin/manage_organisms.php",
                            "line": 23,
                            "context": "handleAdminAjax(function($action) use ($organisms) {"
                        },
                        {
                            "file": "/data/moop/admin/manage_taxonomy_tree.php",
                            "line": 21,
                            "context": "handleAdminAjax();"
                        },
                        {
                            "file": "/data/moop/admin/manage_groups.php",
                            "line": 18,
                            "context": "handleAdminAjax();"
                        },
                        {
                            "file": "/data/moop/admin/manage_users.php",
                            "line": 24,
                            "context": "handleAdminAjax();"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_tools.php",
            "count": 2,
            "functions": [
                {
                    "name": "getAvailableTools",
                    "line": 14,
                    "comment": "/**\n* Get available tools filtered by context\n* Returns only tools that have the required context parameters available\n*\n* @param array $context - Context array with optional keys: organism, assembly, group, display_name\n* @return array - Array of available tools with built URLs\n*/",
                    "code": "function getAvailableTools($context = []) {\n    global $site, $available_tools;\n    \n    // Include tool configuration\n    include_once __DIR__ . '/tool_config.php';\n    \n    // If $available_tools not set by include, return empty array\n    if (!isset($available_tools) || !is_array($available_tools)) {\n        return [];\n    }\n    \n    // Get current page from context (optional)\n    $current_page = $context['page'] ?? null;\n    \n    $tools = [];\n    foreach ($available_tools as $tool_id => $tool) {\n        // Check page visibility - skip if tool doesn't show on this page\n        if ($current_page && !isToolVisibleOnPage($tool, $current_page)) {\n            continue;\n        }\n        \n        $url = buildToolUrl($tool_id, $context, $site);\n        if ($url) {\n            $tools[$tool_id] = array_merge($tool, ['url' => $url]);\n        }\n    }\n    \n    return $tools;\n}",
                    "parameters": [
                        {
                            "name": "context",
                            "type": "array",
                            "description": "Context array with optional keys: organism, assembly, group, display_name"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of available tools with built URLs",
                    "internalCalls": [
                        "getAvailableTools",
                        "isToolVisibleOnPage",
                        "buildToolUrl"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/tool_section.php",
                            "line": 62,
                            "context": "$tools = getAvailableTools($context ?? []);"
                        }
                    ]
                },
                {
                    "name": "createToolContext",
                    "line": 55,
                    "comment": "/**\n* Create a tool context for tool_section.php\n*\n* Builds a context array with page type and available entity parameters.\n* Filters out null/empty values to keep context clean.\n*\n* @param string $page Page identifier: 'index', 'organism', 'assembly', 'group', 'parent', 'multi_organism_search'\n* @param array $params Optional entity parameters: organism, assembly, group, organisms, display_name, use_onclick_handler\n* @return array Context array for tool_section.php\n*\n* Examples:\n*   createToolContext('index', ['use_onclick_handler' => true])\n*   createToolContext('organism', ['organism' => $name, 'display_name' => $common_name])\n*   createToolContext('assembly', ['organism' => $org, 'assembly' => $acc, 'display_name' => $name])\n*   createToolContext('group', ['group' => $name])\n*   createToolContext('parent', ['organism' => $org, 'assembly' => $acc, 'display_name' => $feature])\n*   createToolContext('multi_organism_search', ['organisms' => $orgs, 'display_name' => $name])\n*/",
                    "code": "function createToolContext($page, $params = []) {\n    $context = ['page' => $page];\n    \n    // Add optional parameters if provided and not null/empty\n    $optional_keys = ['organism', 'assembly', 'group', 'organisms', 'display_name', 'use_onclick_handler'];\n    foreach ($optional_keys as $key) {\n        if (!empty($params[$key])) {\n            $context[$key] = $params[$key];\n        }\n    }\n    \n    // Set sensible defaults for display_name if not provided\n    if (empty($context['display_name'])) {\n        if (!empty($context['organism'])) {\n            $context['display_name'] = $context['organism'];\n        } elseif (!empty($context['group'])) {\n            $context['display_name'] = $context['group'];\n        } elseif ($page === 'index') {\n            $context['display_name'] = 'Multi-Organism Search';\n        } elseif ($page === 'multi_organism_search') {\n            $context['display_name'] = 'Multi-Organism Search';\n        }\n    }\n    \n    return $context;\n}",
                    "parameters": [
                        {
                            "name": "page",
                            "type": "string",
                            "description": "Page identifier: 'index', 'organism', 'assembly', 'group', 'parent', 'multi_organism_search'"
                        },
                        {
                            "name": "params",
                            "type": "array",
                            "description": "Optional entity parameters: organism, assembly, group, organisms, display_name, use_onclick_handler"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Context array for tool_section.php",
                    "internalCalls": [
                        "createToolContext"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 6,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/assembly.php",
                            "line": 35,
                            "context": "$context = createToolContext('assembly', ["
                        },
                        {
                            "file": "/data/moop/tools/pages/groups.php",
                            "line": 43,
                            "context": "$context = createToolContext('group', $tool_context_params);"
                        },
                        {
                            "file": "/data/moop/tools/pages/multi_organism.php",
                            "line": 33,
                            "context": "$context = createToolContext('multi_organism_search', ['organisms' => $organisms]);"
                        },
                        {
                            "file": "/data/moop/tools/pages/parent.php",
                            "line": 75,
                            "context": "$context = createToolContext('parent', ["
                        },
                        {
                            "file": "/data/moop/tools/pages/index.php",
                            "line": 130,
                            "context": "$context = createToolContext('index', ['use_onclick_handler' => true]);"
                        },
                        {
                            "file": "/data/moop/tools/pages/organism.php",
                            "line": 57,
                            "context": "$context = createToolContext('organism', ["
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/functions_validation.php",
            "count": 7,
            "functions": [
                {
                    "name": "test_input",
                    "line": 23,
                    "comment": "/**\n* Sanitize user input - remove dangerous characters\n*\n* DEPRECATED: Use context-specific sanitization instead:\n* - For database queries: Use prepared statements with parameter binding\n* - For HTML output: Use htmlspecialchars() at the point of output\n* - For URL parameters: Use urlencode()/urldecode() as needed\n*\n* This function is kept for backwards compatibility but combines multiple\n* concerns and is typically misused. It applies both raw character removal\n* and HTML escaping, which should be handled separately based on context.\n*\n* @param string $data - Raw user input\n* @return string - Sanitized string with < > removed and HTML entities escaped\n* @deprecated Use prepared statements and context-specific escaping\n*/",
                    "code": "function test_input($data) {\n    $data = stripslashes($data);\n    $data = preg_replace('/[\\<\\>]+/', '', $data);\n    $data = htmlspecialchars($data);\n    return $data;\n}",
                    "parameters": [
                        {
                            "name": "data",
                            "type": "string",
                            "description": "Raw user input"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Sanitized string with < > removed and HTML entities escaped",
                    "internalCalls": [
                        "test_input"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "sanitize_search_input",
                    "line": 40,
                    "comment": "/**\n* Sanitize search input specifically for use in database search queries\n*\n* This function handles search-specific sanitization that removes or escapes\n* characters that could interfere with search functionality while preserving\n* useful search characters like spaces, quotes, and basic punctuation.\n*\n* @param string $input - Raw search input from user\n* @return string - Sanitized search string safe for database queries\n*/",
                    "code": "function sanitize_search_input($input, $quoted_search = false) {\n    // Remove null bytes and control characters\n    $input = preg_replace('/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/', '', $input);\n    \n    // Trim whitespace\n    $input = trim($input);\n    \n    // Remove quotes if this is a quoted search - they will be removed before passing to database\n    if ($quoted_search) {\n        $input = trim($input, '\"');\n    }\n    \n    // Remove excessive whitespace (multiple spaces become single space)\n    $input = preg_replace('/\\s+/', ' ', $input);\n    \n    return $input;\n}",
                    "parameters": [
                        {
                            "name": "input",
                            "type": "string",
                            "description": "Raw search input from user"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Sanitized search string safe for database queries",
                    "internalCalls": [
                        "sanitize_search_input"
                    ],
                    "category": "validation",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_validation.php",
                            "line": 69,
                            "context": "$term = sanitize_search_input($term);"
                        },
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 60,
                            "context": "$search_input = sanitize_search_input($search_keywords, $quoted_search);"
                        }
                    ]
                },
                {
                    "name": "validate_search_term",
                    "line": 68,
                    "comment": "/**\n* Validate a search term for safety and usability\n*\n* Checks that a search term meets minimum requirements and doesn't contain\n* problematic patterns that could cause issues with database queries or\n* return meaningless results.\n*\n* @param string $term - Search term to validate\n* @return array - Validation result with 'valid' boolean and 'error' message\n*/",
                    "code": "function validate_search_term($term) {\n    $term = sanitize_search_input($term);\n    \n    if (empty($term)) {\n        return ['valid' => false, 'error' => 'Search term cannot be empty'];\n    }\n    \n    if (strlen($term) < 2) {\n        return ['valid' => false, 'error' => 'Search term must be at least 2 characters long'];\n    }\n    \n    if (strlen($term) > 100) {\n        return ['valid' => false, 'error' => 'Search term too long (maximum 100 characters)'];\n    }\n    \n    // Check for patterns that might cause performance issues\n    if (preg_match('/^[%_*]+$/', $term)) {\n        return ['valid' => false, 'error' => 'Search term cannot consist only of wildcards'];\n    }\n    \n    return ['valid' => true, 'term' => $term];\n}",
                    "parameters": [
                        {
                            "name": "term",
                            "type": "string",
                            "description": "Search term to validate"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Validation result with 'valid' boolean and 'error' message",
                    "internalCalls": [
                        "validate_search_term",
                        "sanitize_search_input"
                    ],
                    "category": "validation",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "is_quoted_search",
                    "line": 97,
                    "comment": "/**\n* Check if a search term is quoted (surrounded by quotes)\n*\n* @param string $term - Search term to check\n* @return bool - True if term is quoted, false otherwise\n*/",
                    "code": "function is_quoted_search($term) {\n    $term = trim($term);\n    return (strlen($term) >= 2 && \n            (($term[0] === '\"' && $term[-1] === '\"') ||\n             ($term[0] === \"'\" && $term[-1] === \"'\")));\n}",
                    "parameters": [
                        {
                            "name": "term",
                            "type": "string",
                            "description": "Search term to check"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "True if term is quoted, false otherwise",
                    "internalCalls": [
                        "is_quoted_search"
                    ],
                    "category": "search",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "validateOrganismParam",
                    "line": 112,
                    "comment": "/**\n* Validate and extract organism parameter from GET/POST\n* Redirects to home if missing/empty\n*\n* @param string $organism_name Organism name to validate\n* @param string $redirect_on_empty URL to redirect to if empty (default: /moop/index.php)\n* @return string Validated organism name\n*/",
                    "code": "function validateOrganismParam($organism_name, $redirect_on_empty = '/moop/index.php') {\n    if (empty($organism_name)) {\n        header(\"Location: $redirect_on_empty\");\n        exit;\n    }\n    return $organism_name;\n}",
                    "parameters": [
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name to validate"
                        },
                        {
                            "name": "redirect_on_empty",
                            "type": "string",
                            "description": "URL to redirect to if empty (default: /moop/index.php)"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Validated organism name",
                    "internalCalls": [
                        "validateOrganismParam"
                    ],
                    "category": "validation",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_display.php",
                            "line": 268,
                            "context": "$organism_name = validateOrganismParam($organism_name, $redirect_home);"
                        },
                        {
                            "file": "/data/moop/tools/assembly.php",
                            "line": 42,
                            "context": "$organism_name = validateOrganismParam($_GET['organism'] ?? '');"
                        }
                    ]
                },
                {
                    "name": "validateAssemblyParam",
                    "line": 128,
                    "comment": "/**\n* Validate and extract assembly parameter from GET/POST\n* Redirects to home if missing/empty\n*\n* @param string $assembly Assembly accession to validate\n* @param string $redirect_on_empty URL to redirect to if empty\n* @return string Validated assembly name\n*/",
                    "code": "function validateAssemblyParam($assembly, $redirect_on_empty = '/moop/index.php') {\n    if (empty($assembly)) {\n        header(\"Location: $redirect_on_empty\");\n        exit;\n    }\n    return $assembly;\n}",
                    "parameters": [
                        {
                            "name": "assembly",
                            "type": "string",
                            "description": "Assembly accession to validate"
                        },
                        {
                            "name": "redirect_on_empty",
                            "type": "string",
                            "description": "URL to redirect to if empty"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Validated assembly name",
                    "internalCalls": [
                        "validateAssemblyParam"
                    ],
                    "category": "validation",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/assembly.php",
                            "line": 43,
                            "context": "$assembly_param = validateAssemblyParam($_GET['assembly'] ?? '');"
                        }
                    ]
                },
                {
                    "name": "decodeAnnotationText",
                    "line": 145,
                    "comment": "/**\n* Decode URL-encoded annotation/description text for display\n* Converts %3D back to =, %3B back to ;, etc.\n*\n* Used when displaying descriptions/annotations from database that were\n* URL-encoded for GFF file storage.\n*\n* @param string $text - URL-encoded text from database\n* @return string - Decoded, readable text\n*/",
                    "code": "function decodeAnnotationText($text) {\n    if (empty($text)) {\n        return $text;\n    }\n    // Decode URL-encoded characters: %XX -> character\n    return preg_replace_callback('/%([0-9A-F]{2})/i', function($matches) {\n        return chr(hexdec($matches[1]));\n    }, $text);\n}",
                    "parameters": [
                        {
                            "name": "text",
                            "type": "string",
                            "description": "URL-encoded text from database"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "Decoded, readable text",
                    "internalCalls": [
                        "decodeAnnotationText"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/parent.php",
                            "line": 37,
                            "context": "<?= htmlspecialchars(decodeAnnotationText($description)) ?>"
                        },
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 131,
                            "context": "'feature_description' => decodeAnnotationText($row['feature_description'] ?? ''),"
                        },
                        {
                            "file": "/data/moop/tools/annotation_search_ajax.php",
                            "line": 135,
                            "context": "'annotation_description' => decodeAnnotationText($row['annotation_description'] ?? ''),"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/parent_functions.php",
            "count": 8,
            "functions": [
                {
                    "name": "getAncestors",
                    "line": 18,
                    "comment": "/**\n* Get hierarchy of features (ancestors)\n* Traverses up the feature hierarchy from a given feature to its parents/grandparents\n* Optionally filters by genome_ids for permission-based access\n*\n* @param string $feature_uniquename - The feature uniquename to start from\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results (empty = no filtering)\n* @return array - Array of features: [self, parent, grandparent, ...]\n*/",
                    "code": "function getAncestors($feature_uniquename, $dbFile, $genome_ids = []) {\n    $feature = getFeatureByUniquename($feature_uniquename, $dbFile, $genome_ids);\n    \n    if (empty($feature)) {\n        return [];\n    }\n    \n    $ancestors = [$feature];\n    \n    if ($feature['parent_feature_id']) {\n        $parent_ancestors = getAncestorsByFeatureId($feature['parent_feature_id'], $dbFile, $genome_ids);\n        $ancestors = array_merge($ancestors, $parent_ancestors);\n    }\n    \n    return $ancestors;\n}",
                    "parameters": [
                        {
                            "name": "feature_uniquename",
                            "type": "string",
                            "description": "The feature uniquename to start from"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results (empty = no filtering)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of features: [self, parent, grandparent, ...]",
                    "internalCalls": [
                        "getAncestors",
                        "getFeatureByUniquename",
                        "getAncestorsByFeatureId"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 808,
                            "context": "$parents = getAncestors($uniquename, $db, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 881,
                            "context": "<td><code>getAncestors()</code></td>"
                        },
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 127,
                            "context": "$ancestors = getAncestors($uniquename, $db, $accessible_genome_ids);"
                        }
                    ]
                },
                {
                    "name": "getAncestorsByFeatureId",
                    "line": 28,
                    "comment": "/**\n* Helper function for recursive ancestor traversal\n* Fetches ancestors by feature_id (used internally by getAncestors)\n* Optionally filters by genome_ids for permission-based access\n*\n* @param int $feature_id - The feature ID to start from\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results\n* @return array - Array of ancestor features\n*/",
                    "code": "function getAncestorsByFeatureId($feature_id, $dbFile, $genome_ids = []) {\n    $feature = getParentFeature($feature_id, $dbFile, $genome_ids);\n    \n    if (empty($feature)) {\n        return [];\n    }\n    \n    $ancestors = [$feature];\n    \n    if ($feature['parent_feature_id']) {\n        $parent_ancestors = getAncestorsByFeatureId($feature['parent_feature_id'], $dbFile, $genome_ids);\n        $ancestors = array_merge($ancestors, $parent_ancestors);\n    }\n    \n    return $ancestors;\n}",
                    "parameters": [
                        {
                            "name": "feature_id",
                            "type": "int",
                            "description": "The feature ID to start from"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of ancestor features",
                    "internalCalls": [
                        "getAncestorsByFeatureId",
                        "getParentFeature"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 28,
                            "context": "$parent_ancestors = getAncestorsByFeatureId($feature['parent_feature_id'], $dbFile, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 55,
                            "context": "$parent_ancestors = getAncestorsByFeatureId($feature['parent_feature_id'], $dbFile, $genome_ids);"
                        }
                    ]
                },
                {
                    "name": "getChildren",
                    "line": 72,
                    "comment": "/**\n* Get all children and descendants of a feature\n* Recursively fetches all child features at any depth\n* Optionally filters by genome_ids for permission-based access\n*\n* @param int $feature_id - The parent feature ID\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results (empty = no filtering)\n* @return array - Flat array of all children and descendants\n*/",
                    "code": "function getChildren($feature_id, $dbFile, $genome_ids = []) {\n    $children = [];\n    \n    $results = getChildrenByFeatureId($feature_id, $dbFile, $genome_ids);\n    \n    foreach ($results as $row) {\n        $children[] = $row;\n        $child_descendants = getChildren($row['feature_id'], $dbFile, $genome_ids);\n        $children = array_merge($children, $child_descendants);\n    }\n    return $children;\n}",
                    "parameters": [
                        {
                            "name": "feature_id",
                            "type": "int",
                            "description": "The parent feature ID"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results (empty = no filtering)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Flat array of all children and descendants",
                    "internalCalls": [
                        "getChildren",
                        "getChildrenByFeatureId"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 5,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 79,
                            "context": "$child_descendants = getChildren($row['feature_id'], $dbFile, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 809,
                            "context": "$children = getChildren($feature_id, $db, $genome_ids);</code></pre>"
                        },
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 885,
                            "context": "<td><code>getChildren()</code></td>"
                        },
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 181,
                            "context": "$children = getChildren($feature_id, $db, $accessible_genome_ids);"
                        },
                        {
                            "file": "/data/moop/tools/retrieve_sequences.php",
                            "line": 169,
                            "context": "$children = getChildren($feature_id, $db);"
                        }
                    ]
                },
                {
                    "name": "getChildrenHierarchical",
                    "line": 96,
                    "comment": "/**\n* Get children with hierarchical structure (preserves parent-child relationships)\n* Unlike getChildren() which returns flat array, this preserves nesting\n* Each child has a 'grandchildren' key containing its own children\n* Enables proper display of parent -> child -> grandchild hierarchies\n*\n* @param int $feature_id - The parent feature ID\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results\n* @return array - Array of children, each with 'grandchildren' key\n*/",
                    "code": "function getChildrenHierarchical($feature_id, $dbFile, $genome_ids = []) {\n    $results = getChildrenByFeatureId($feature_id, $dbFile, $genome_ids);\n    \n    foreach ($results as &$child) {\n        $child['grandchildren'] = getChildrenHierarchical($child['feature_id'], $dbFile, $genome_ids);\n    }\n    \n    return $results;\n}",
                    "parameters": [
                        {
                            "name": "feature_id",
                            "type": "int",
                            "description": "The parent feature ID"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Array of children, each with 'grandchildren' key",
                    "internalCalls": [
                        "getChildrenHierarchical",
                        "getChildrenByFeatureId"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 100,
                            "context": "$child['grandchildren'] = getChildrenHierarchical($child['feature_id'], $dbFile, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 889,
                            "context": "<td><code>getChildrenHierarchical()</code></td>"
                        },
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 178,
                            "context": "$children_hierarchical = getChildrenHierarchical($feature_id, $db, $accessible_genome_ids);"
                        }
                    ]
                },
                {
                    "name": "generateAnnotationTableHTML",
                    "line": 121,
                    "comment": "/**\n* Generate annotation table with export buttons\n* Creates a responsive HTML table displaying annotations with sorting/filtering\n*\n* @param array $results - Annotation results from database\n* @param string $uniquename - Feature uniquename (for export)\n* @param string $type - Feature type (for export)\n* @param int $count - Table counter (ensures unique IDs)\n* @param string $annotation_type - Type of annotation (e.g., \"InterPro\")\n* @param string $desc - Description/definition of annotation type\n* @param string $color - Bootstrap color class for badge\n* @param string $organism - Organism name (for export)\n* @param string $annotation_type_key - Database key for annotation type (used for anchor ID)\n* @return string - HTML for the annotation table section\n*/",
                    "code": "function generateAnnotationTableHTML($results, $uniquename, $type, $count, $annotation_type, $desc, $color = 'warning', $organism = '', $annotation_type_key = '') {\n    if (empty($results)) {\n        return '';\n    }\n    \n    $table_id = \"annotTable_$count\";\n    $result_count = count($results);\n    $desc_id = \"annotDesc_$count\";\n    \n    // Determine text color based on background color\n    $text_color = in_array($color, ['warning', 'info', 'secondary']) ? 'text-dark' : 'text-white';\n    \n    // Border color matches badge color\n    $border_class = \"border-$color\";\n    \n    // Create unique ID for this annotation section\n    // Use annotation_type_key if provided, otherwise fall back to annotation_type\n    $key_for_anchor = $annotation_type_key ?: $annotation_type;\n    $section_id = \"annot_section_\" . preg_replace('/[^a-zA-Z0-9_]/', '_', $uniquename . '_' . $key_for_anchor);\n    \n    $html = '<div class=\"annotation-section mb-3 ' . htmlspecialchars($border_class) . '\" id=\"' . htmlspecialchars($section_id) . '\">';\n    $html .= '<div class=\"d-flex justify-content-between align-items-center mb-2\">';\n    $html .= \"<h5 class=\\\"mb-0\\\"><span class=\\\"badge bg-\" . htmlspecialchars($color) . \" $text_color badge-lg\\\">\" . htmlspecialchars($annotation_type) . \"</span>\";\n    $html .= \" <span class=\\\"badge bg-secondary badge-lg\\\">\" . htmlspecialchars($result_count) . \" result\" . ($result_count > 1 ? 's' : '') . \"</span>\";\n    \n    if ($desc) {\n        $html .= \"&nbsp;<button class=\\\"btn btn-sm btn-link p-0 annotation-info-btn\\\" type=\\\"button\\\" data-bs-toggle=\\\"collapse\\\" data-bs-target=\\\"#\" . htmlspecialchars($desc_id) . \"\\\" aria-expanded=\\\"false\\\">\";\n        $html .= \"<i class=\\\"fas fa-info-circle\\\"></i>\";\n        $html .= \"</button>\";\n    }\n    \n    $html .= \"</h5>\";\n    $html .= '<div class=\"d-flex gap-2 align-items-center\">';\n    $html .= '<div id=\"' . htmlspecialchars($table_id) . '_filter\" class=\"dataTables_filter\"></div>';\n    $html .= '<a href=\"#sequencesSection\" class=\"btn btn-sm btn-info\" title=\"Jump to sequences section\"><i class=\"fas fa-dna\"></i> Jump to Sequences</a>';\n    $html .= '</div>';\n    $html .= '</div>';\n    \n    if ($desc) {\n        $html .= '<div class=\"collapse mb-3\" id=\"' . htmlspecialchars($desc_id) . '\">';\n        $html .= '<div class=\"alert alert-info mb-0 font-size-xsmall\">';\n        $html .= $desc;\n        $html .= '</div>';\n        $html .= '</div>';\n    }\n    \n    // Table with DataTables\n    $html .= \"<div class=\\\"table-responsive\\\">\";\n    $html .= \"<table id=\\\"\" . htmlspecialchars($table_id) . \"\\\" class=\\\"table table-sm table-striped table-hover substring-search\\\" style=\\\"width:100%;\\\">\";\n    $html .= \"<thead><tr>\";\n    $html .= \"<th class=\\\"export-only\\\">Organism</th>\";\n    $html .= \"<th class=\\\"export-only\\\">Feature ID</th>\";\n    $html .= \"<th class=\\\"export-only\\\">Feature Type</th>\";\n    $html .= \"<th class=\\\"export-only\\\">Annotation Type</th>\";\n    $html .= \"<th>Annotation ID</th>\";\n    $html .= \"<th>Description</th>\";\n    $html .= \"<th>Score</th>\";\n    $html .= \"<th>Source</th>\";\n    $html .= \"</tr></thead>\";\n    $html .= \"<tbody>\";\n    \n    foreach ($results as $row) {\n        $hit_id = htmlspecialchars($row['annotation_accession']);\n        $hit_description = htmlspecialchars($row['annotation_description']);\n        $hit_score = htmlspecialchars($row['score']);\n        $annotation_source = htmlspecialchars($row['annotation_source_name']);\n        $annotation_accession_url = htmlspecialchars($row['annotation_accession_url']);\n        $hit_id_link = $annotation_accession_url . urlencode($row['annotation_accession']);\n        \n        $html .= \"<tr>\";\n        $html .= \"<td class=\\\"export-only\\\">\" . htmlspecialchars($organism) . \"</td>\";\n        $html .= \"<td class=\\\"export-only\\\">\" . htmlspecialchars($uniquename) . \"</td>\";\n        $html .= \"<td class=\\\"export-only\\\">\" . htmlspecialchars($type) . \"</td>\";\n        $html .= \"<td class=\\\"export-only\\\">\" . htmlspecialchars($annotation_type) . \"</td>\";\n        $html .= \"<td><a href=\\\"\" . htmlspecialchars($hit_id_link) . \"\\\" target=\\\"_blank\\\">\" . $hit_id . \"</a></td>\";\n        $html .= \"<td>\" . $hit_description . \"</td>\";\n        $html .= \"<td>\" . $hit_score . \"</td>\";\n        $html .= \"<td>\" . $annotation_source . \"</td>\";\n        $html .= \"</tr>\";\n    }\n    \n    $html .= \"</tbody></table>\";\n    $html .= \"</div>\";\n    $html .= \"</div>\";\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "results",
                            "type": "array",
                            "description": "Annotation results from database"
                        },
                        {
                            "name": "uniquename",
                            "type": "string",
                            "description": "Feature uniquename (for export)"
                        },
                        {
                            "name": "type",
                            "type": "string",
                            "description": "Feature type (for export)"
                        },
                        {
                            "name": "count",
                            "type": "int",
                            "description": "Table counter (ensures unique IDs)"
                        },
                        {
                            "name": "annotation_type",
                            "type": "string",
                            "description": "Type of annotation (e.g., \"InterPro\")"
                        },
                        {
                            "name": "desc",
                            "type": "string",
                            "description": "Description/definition of annotation type"
                        },
                        {
                            "name": "color",
                            "type": "string",
                            "description": "Bootstrap color class for badge"
                        },
                        {
                            "name": "organism",
                            "type": "string",
                            "description": "Organism name (for export)"
                        },
                        {
                            "name": "annotation_type_key",
                            "type": "string",
                            "description": "Database key for annotation type (used for anchor ID)"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML for the annotation table section",
                    "internalCalls": [
                        "generateAnnotationTableHTML"
                    ],
                    "category": "ui",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 428,
                            "context": "$html .= generateAnnotationTableHTML($annot_results, $child_uniquename, $child_type, $count, $display_label, $analysis_desc[$annotation_type] ?? '', $color, $organism_name, $annotation_type);"
                        },
                        {
                            "file": "/data/moop/tools/pages/parent.php",
                            "line": 166,
                            "context": "echo generateAnnotationTableHTML($annot_results, $feature_uniquename, $type, $count, $display_label, $analysis_desc[$annotation_type] ?? '', $color, $organism_name, $annotation_type);"
                        },
                        {
                            "file": "/data/moop/tools/pages/help/organism-setup-and-searches.php",
                            "line": 897,
                            "context": "<td><code>generateAnnotationTableHTML()</code></td>"
                        }
                    ]
                },
                {
                    "name": "getAllAnnotationsForFeatures",
                    "line": 219,
                    "comment": "/**\n* Get all annotations for multiple features at once (optimized)\n* Fetches annotations for multiple features in a single query\n* Optionally filters by genome_ids for permission-based access\n*\n* @param array $feature_ids - Array of feature IDs to fetch annotations for\n* @param string $dbFile - Path to SQLite database\n* @param array $genome_ids - Optional: Array of genome IDs to filter results (empty = no filtering)\n* @return array - Organized as [$feature_id => [$annotation_type => [results]]]\n*/",
                    "code": "function getAllAnnotationsForFeatures($feature_ids, $dbFile, $genome_ids = []) {\n    if (empty($feature_ids)) {\n        return [];\n    }\n    \n    $placeholders = implode(',', array_fill(0, count($feature_ids), '?'));\n    \n    // Build WHERE clause with optional genome filtering\n    $where_clause = \"f.feature_id IN ($placeholders)\";\n    $params = $feature_ids;\n    \n    if (!empty($genome_ids)) {\n        $genome_placeholders = implode(',', array_fill(0, count($genome_ids), '?'));\n        $where_clause .= \" AND f.genome_id IN ($genome_placeholders)\";\n        $params = array_merge($params, $genome_ids);\n    }\n    \n    $query = \"SELECT f.feature_id, f.feature_uniquename, f.feature_type, \n              a.annotation_accession, a.annotation_description, \n              fa.score, fa.date, \n              ans.annotation_source_name, ans.annotation_accession_url, ans.annotation_type\n        FROM annotation a, feature f, feature_annotation fa, annotation_source ans, genome g, organism o\n        WHERE f.organism_id = o.organism_id\n          AND f.genome_id = g.genome_id\n          AND ans.annotation_source_id = a.annotation_source_id\n          AND f.feature_id = fa.feature_id\n          AND fa.annotation_id = a.annotation_id\n          AND $where_clause\n        ORDER BY f.feature_id, ans.annotation_type\";\n    \n    $results = fetchData($query, $dbFile, $params);\n    \n    // Organize by feature_id and annotation_type\n    $organized = [];\n    foreach ($results as $row) {\n        $feature_id = $row['feature_id'];\n        $annotation_type = $row['annotation_type'];\n        \n        if (!isset($organized[$feature_id])) {\n            $organized[$feature_id] = [];\n        }\n        if (!isset($organized[$feature_id][$annotation_type])) {\n            $organized[$feature_id][$annotation_type] = [];\n        }\n        \n        $organized[$feature_id][$annotation_type][] = $row;\n    }\n    \n    return $organized;\n}",
                    "parameters": [
                        {
                            "name": "feature_ids",
                            "type": "array",
                            "description": "Array of feature IDs to fetch annotations for"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "genome_ids",
                            "type": "array",
                            "description": "Optional: Array of genome IDs to filter results (empty = no filtering)"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Organized as [$feature_id => [$annotation_type => [results]]]",
                    "internalCalls": [
                        "getAllAnnotationsForFeatures",
                        "fetchData"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/parent.php",
                            "line": 188,
                            "context": "$all_annotations = getAllAnnotationsForFeatures($all_feature_ids, $db);"
                        }
                    ]
                },
                {
                    "name": "generateTreeHTML",
                    "line": 280,
                    "comment": "/**\n* Generate tree-style HTML for feature hierarchy\n* Creates a hierarchical list with box-drawing characters (like Unix 'tree' command)\n*\n* @param int $feature_id - The parent feature ID\n* @param string $dbFile - Path to SQLite database\n* @param string $prefix - Internal use for recursion\n* @param bool $is_last - Internal use for recursion\n* @return string - HTML string with nested ul/li tree structure\n*/",
                    "code": "function generateTreeHTML($feature_id, $dbFile, $all_annotations = [], $analysis_order = [], $prefix = '', $is_last = true, $genome_ids = []) {\n    $results = getChildrenByFeatureId($feature_id, $dbFile, $genome_ids);\n\n    if (empty($results)) {\n        return '';\n    }\n    \n    $html = \"<ul>\";\n    $total = count($results);\n    \n    foreach ($results as $index => $row) {\n        $is_last_child = ($index === $total - 1);\n        \n        $feature_type = htmlspecialchars($row['feature_type']);\n        $feature_name = htmlspecialchars($row['feature_uniquename']);\n        $child_feature_id = $row['feature_id'];\n        \n        // Color code badges by feature type\n        $badge_class = 'bg-secondary';\n        $text_color = 'text-white';\n        \n        if ($feature_type == 'mRNA') {\n            $badge_class = 'bg-feature-mrna';\n            $text_color = 'text-white';\n        } elseif ($feature_type == 'CDS') {\n            $badge_class = 'bg-info';\n            $text_color = 'text-white';\n        } elseif ($feature_type == 'exon') {\n            $badge_class = 'bg-warning';\n            $text_color = 'text-dark';\n        } elseif ($feature_type == 'gene') {\n            $badge_class = 'bg-feature-gene';\n            $text_color = 'text-white';\n        } elseif ($feature_type == 'protein' || $feature_type == 'polypeptide') {\n            $badge_class = 'bg-feature-protein';\n            $text_color = 'text-white';\n        }\n        \n        // Calculate annotation count for this child\n        $child_annot_count = 0;\n        if (isset($all_annotations[$child_feature_id])) {\n            foreach ($all_annotations[$child_feature_id] as $annotation_type => $annots) {\n                $child_annot_count += count($annots);\n            }\n        }\n        \n        // Generate anchor for first annotation type (or use first one available)\n        $child_annot_anchor = preg_replace('/[^a-zA-Z0-9_]/', '_', $row['feature_uniquename'] . '_' . ($analysis_order[0] ?? 'annotation'));\n        \n        // Tree character - \u2514\u2500\u2500 for last child, \u251c\u2500\u2500 for others\n        $tree_char = $is_last_child ? '\u2514\u2500\u2500 ' : '\u251c\u2500\u2500 ';\n        \n        $html .= \"<li>\";\n        $html .= \"<span class=\\\"tree-char\\\">$tree_char</span>\";\n        $html .= \"<a href=\\\"#annot_section_$child_annot_anchor\\\" class=\\\"link-light-bordered text-decoration-none\\\"><span class=\\\"text-dark\\\">$feature_name</span></a> \";\n        $html .= \"<span class=\\\"badge $badge_class $text_color\\\">$feature_type</span>\";\n        \n        // Add annotation count badge if there are annotations\n        if ($child_annot_count > 0) {\n            $html .= \" <span class=\\\"badge bg-success text-white badge-sm\\\">$child_annot_count annotation\" . ($child_annot_count > 1 ? 's' : '') . \"</span>\";\n        }\n        \n        // Recursive call for nested children\n        $html .= generateTreeHTML($child_feature_id, $dbFile, $all_annotations, $analysis_order, $prefix, $is_last_child, $genome_ids);\n        $html .= \"</li>\";\n    }\n    $html .= \"</ul>\";\n\n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "feature_id",
                            "type": "int",
                            "description": "The parent feature ID"
                        },
                        {
                            "name": "dbFile",
                            "type": "string",
                            "description": "Path to SQLite database"
                        },
                        {
                            "name": "prefix",
                            "type": "string",
                            "description": "Internal use for recursion"
                        },
                        {
                            "name": "is_last",
                            "type": "bool",
                            "description": "Internal use for recursion"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML string with nested ul/li tree structure",
                    "internalCalls": [
                        "generateTreeHTML",
                        "getChildrenByFeatureId"
                    ],
                    "category": "ui",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 343,
                            "context": "$html .= generateTreeHTML($child_feature_id, $dbFile, $all_annotations, $analysis_order, $prefix, $is_last_child, $genome_ids);"
                        },
                        {
                            "file": "/data/moop/tools/pages/parent.php",
                            "line": 115,
                            "context": "<?= generateTreeHTML($feature_id, $db, $all_annotations, $analysis_order) ?>"
                        }
                    ]
                },
                {
                    "name": "generateChildAnnotationCards",
                    "line": 367,
                    "comment": "/**\n* Generate nested child annotation cards (recursive)\n* Renders child and grandchild features with their annotations in nested card structure\n* Each level has its own collapsible card with unique color based on feature type\n*\n* @param array $child - Child feature array from hierarchical structure\n* @param array $all_annotations - Cached annotations organized by feature_id\n* @param array $analysis_order - Annotation types in order\n* @param array $annotation_colors - Color mapping for annotation types\n* @param array $annotation_labels - Display labels for annotation types\n* @param array $analysis_desc - Descriptions for annotation types\n* @param string $organism_name - Organism name for export\n* @param int &$count - Counter for unique table IDs (passed by reference)\n* @param bool $is_grandchild - Internal flag for styling grandchild level\n* @return string - HTML for child/grandchild annotation cards\n*/",
                    "code": "function generateChildAnnotationCards($child, $all_annotations, $analysis_order, $annotation_colors, $annotation_labels, $analysis_desc, $organism_name, &$count, $is_grandchild = false) {\n    $child_feature_id = $child['feature_id'];\n    $child_uniquename = $child['feature_uniquename'];\n    $child_type = $child['feature_type'];\n    \n    // Count annotations for this child\n    $child_annotation_count = 0;\n    $child_annotation_types = [];\n    foreach ($analysis_order as $annotation_type) {\n        $annot_results = $all_annotations[$child_feature_id][$annotation_type] ?? [];\n        if (!empty($annot_results)) {\n            $child_annotation_count += count($annot_results);\n            $child_annotation_types[$annotation_type] = count($annot_results);\n        }\n    }\n    \n    // Determine header styling based on feature type and nesting level\n    $header_class = 'child-feature-header';\n    $badge_class = 'bg-feature-mrna';\n    \n    if ($is_grandchild) {\n        $header_class = 'child-feature-header grandchild-feature-header';\n        if ($child_type == 'protein' || $child_type == 'polypeptide') {\n            $badge_class = 'bg-feature-protein';\n        } else {\n            $badge_class = 'bg-secondary';\n        }\n    }\n    \n    $html = '<div class=\"card annotation-card border-info\">';\n    $html .= \"  <div class=\\\"card-header d-flex align-items-center $header_class\\\">\";\n    $html .= \"    <span class=\\\"collapse-section\\\" data-bs-toggle=\\\"collapse\\\" data-bs-target=\\\"#child_$child_feature_id\\\" aria-expanded=\\\"true\\\" role=\\\"button\\\">\";\n    $html .= \"      <i class=\\\"fas fa-minus toggle-icon text-info\\\"></i>\";\n    $html .= \"    </span>\";\n    $html .= \"    <strong class=\\\"ms-2 text-dark\\\"><span class=\\\"text-white px-2 py-1 rounded child-feature-badge $badge_class badge-xlg\\\">$child_uniquename ($child_type)</span></strong>\";\n    \n    // Show colored annotation type badges\n    if ($child_annotation_count > 0) {\n        foreach ($child_annotation_types as $type_name => $type_count) {\n            $badge_color = $annotation_colors[$type_name] ?? 'warning';\n            $text_color = in_array($badge_color, ['warning', 'info', 'secondary']) ? 'text-dark' : 'text-white';\n            $display_label = $annotation_labels[$type_name] ?? $type_name;\n            $section_id = \"annot_section_\" . preg_replace('/[^a-zA-Z0-9_]/', '_', $child_uniquename . '_' . $type_name);\n            $html .= \" <a href=\\\"#$section_id\\\" class=\\\"badge bg-$badge_color $text_color ms-1 text-decoration-none badge-s\\\" style=\\\"cursor: pointer;\\\">$display_label</a>\";\n        }\n    } else {\n        $html .= \" <span class=\\\"badge bg-secondary ms-2\\\">No annotations</span>\";\n    }\n    \n    $html .= '  </div>';\n    $html .= \"  <div id=\\\"child_$child_feature_id\\\" class=\\\"collapse show\\\">\";\n    $html .= '    <div class=\"card-body\">';\n    \n    $child_has_annotations = false;\n    foreach ($analysis_order as $annotation_type) {\n        $count++;\n        $annot_results = $all_annotations[$child_feature_id][$annotation_type] ?? [];\n        if (!empty($annot_results)) {\n            $child_has_annotations = true;\n            $color = $annotation_colors[$annotation_type] ?? 'warning';\n            $display_label = $annotation_labels[$annotation_type] ?? $annotation_type;\n            $html .= generateAnnotationTableHTML($annot_results, $child_uniquename, $child_type, $count, $display_label, $analysis_desc[$annotation_type] ?? '', $color, $organism_name, $annotation_type);\n        }\n    }\n    \n    if (!$child_has_annotations) {\n        $type_label = ($child_type === 'mRNA') ? 'transcript' : strtolower($child_type);\n        $html .= \"<p class=\\\"text-muted\\\"><i class=\\\"fas fa-info-circle\\\"></i> No annotations loaded for this $type_label.</p>\";\n    }\n    \n    // Render grandchildren (recursively)\n    if (!empty($child['grandchildren'])) {\n        foreach ($child['grandchildren'] as $grandchild) {\n            $html .= generateChildAnnotationCards($grandchild, $all_annotations, $analysis_order, $annotation_colors, $annotation_labels, $analysis_desc, $organism_name, $count, true);\n        }\n    }\n    \n    $html .= '    </div>';\n    $html .= '  </div>';\n    $html .= '</div>';\n    \n    return $html;\n}",
                    "parameters": [
                        {
                            "name": "child",
                            "type": "array",
                            "description": "Child feature array from hierarchical structure"
                        },
                        {
                            "name": "all_annotations",
                            "type": "array",
                            "description": "Cached annotations organized by feature_id"
                        },
                        {
                            "name": "analysis_order",
                            "type": "array",
                            "description": "Annotation types in order"
                        },
                        {
                            "name": "annotation_colors",
                            "type": "array",
                            "description": "Color mapping for annotation types"
                        },
                        {
                            "name": "annotation_labels",
                            "type": "array",
                            "description": "Display labels for annotation types"
                        },
                        {
                            "name": "analysis_desc",
                            "type": "array",
                            "description": "Descriptions for annotation types"
                        },
                        {
                            "name": "organism_name",
                            "type": "string",
                            "description": "Organism name for export"
                        },
                        {
                            "name": "is_grandchild",
                            "type": "bool",
                            "description": "Internal flag for styling grandchild level"
                        }
                    ],
                    "returnType": "string",
                    "returnDescription": "HTML for child/grandchild annotation cards",
                    "internalCalls": [
                        "generateChildAnnotationCards",
                        "generateAnnotationTableHTML"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 2,
                    "usages": [
                        {
                            "file": "/data/moop/lib/parent_functions.php",
                            "line": 440,
                            "context": "$html .= generateChildAnnotationCards($grandchild, $all_annotations, $analysis_order, $annotation_colors, $annotation_labels, $analysis_desc, $organism_name, $count, true);"
                        },
                        {
                            "file": "/data/moop/tools/pages/parent.php",
                            "line": 186,
                            "context": "echo generateChildAnnotationCards($child, $all_annotations, $analysis_order, $annotation_colors, $annotation_labels, $analysis_desc, $organism_name, $count);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "lib/tool_config.php",
            "count": 4,
            "functions": [
                {
                    "name": "getTool",
                    "line": 52,
                    "comment": "/**\n* Get a specific tool configuration\n*\n* @param string $tool_id - The tool identifier\n* @return array|null - Tool configuration or null if not found\n*/",
                    "code": "function getTool($tool_id) {\n    global $available_tools;\n    return $available_tools[$tool_id] ?? null;\n}",
                    "parameters": [
                        {
                            "name": "tool_id",
                            "type": "string",
                            "description": "The tool identifier"
                        }
                    ],
                    "returnType": "array|null",
                    "returnDescription": "Tool configuration or null if not found",
                    "internalCalls": [
                        "getTool"
                    ],
                    "category": "configuration",
                    "tags": [
                        "readonly",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 3,
                    "usages": [
                        {
                            "file": "/data/moop/lib/tool_config.php",
                            "line": 76,
                            "context": "$tool = getTool($tool_id);"
                        },
                        {
                            "file": "/data/moop/includes/ConfigManager.php",
                            "line": 311,
                            "context": "$tool = $this->getTool($tool_id);"
                        },
                        {
                            "file": "/data/moop/includes/ConfigManager.php",
                            "line": 345,
                            "context": "$tool = $this->getTool($tool_id);"
                        }
                    ]
                },
                {
                    "name": "getAllTools",
                    "line": 62,
                    "comment": "/**\n* Get all available tools\n*\n* @return array - Array of all tool configurations\n*/",
                    "code": "function getAllTools() {\n    global $available_tools;\n    return $available_tools;\n}",
                    "parameters": [],
                    "returnType": "array",
                    "returnDescription": "Array of all tool configurations",
                    "internalCalls": [
                        "getAllTools"
                    ],
                    "category": "configuration",
                    "tags": [
                        "readonly",
                        "file-io",
                        "recursive"
                    ],
                    "usageCount": 0,
                    "usages": []
                },
                {
                    "name": "buildToolUrl",
                    "line": 75,
                    "comment": "/**\n* Build tool URL with context parameters\n*\n* @param string $tool_id - The tool identifier\n* @param array $context - Context array with organism, assembly, group, display_name\n* @param string $site - Site variable (from site_config.php)\n* @return string|null - Built URL or null if tool not found\n*/",
                    "code": "function buildToolUrl($tool_id, $context, $site) {\n    $tool = getTool($tool_id);\n    if (!$tool) {\n        return null;\n    }\n    \n    $url = \"/$site\" . $tool['url_path'];\n    $params = [];\n    $organisms = [];\n    \n    // Build query parameters from context\n    foreach ($tool['context_params'] as $param) {\n        if (!empty($context[$param])) {\n            // Separate organisms array for special handling\n            if ($param === 'organisms' && is_array($context[$param])) {\n                $organisms = $context[$param];\n            } else {\n                $params[$param] = $context[$param];\n            }\n        }\n    }\n    \n    if (empty($params) && empty($organisms)) {\n        return $url;\n    }\n    \n    // Build URL with regular params first\n    if (!empty($params)) {\n        $url .= '?' . http_build_query($params);\n        $separator = '&';\n    } else {\n        $separator = '?';\n    }\n    \n    // Append organisms with [] notation\n    if (!empty($organisms)) {\n        foreach ($organisms as $org) {\n            $url .= $separator . 'organisms[]=' . urlencode($org);\n            $separator = '&';\n        }\n    }\n    \n    return $url;\n}",
                    "parameters": [
                        {
                            "name": "tool_id",
                            "type": "string",
                            "description": "The tool identifier"
                        },
                        {
                            "name": "context",
                            "type": "array",
                            "description": "Context array with organism, assembly, group, display_name"
                        },
                        {
                            "name": "site",
                            "type": "string",
                            "description": "Site variable (from site_config.php)"
                        }
                    ],
                    "returnType": "string|null",
                    "returnDescription": "Built URL or null if tool not found",
                    "internalCalls": [
                        "buildToolUrl",
                        "getTool"
                    ],
                    "category": "configuration",
                    "tags": [
                        "readonly",
                        "database-dependent",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_tools.php",
                            "line": 35,
                            "context": "$url = buildToolUrl($tool_id, $context, $site);"
                        }
                    ]
                },
                {
                    "name": "isToolVisibleOnPage",
                    "line": 127,
                    "comment": "/**\n* Check if a tool should be visible on a specific page\n*\n* @param array $tool - Tool configuration\n* @param string $page - Page identifier (index, organism, group, assembly, parent, multi_organism_search)\n* @return bool - True if tool should be visible on this page\n*/",
                    "code": "function isToolVisibleOnPage($tool, $page) {\n    // If 'pages' key not defined, default to 'all'\n    $pages = $tool['pages'] ?? 'all';\n    \n    // 'all' means show on all pages\n    if ($pages === 'all') {\n        return true;\n    }\n    \n    // If pages is an array, check if current page is in it\n    if (is_array($pages)) {\n        return in_array($page, $pages);\n    }\n    \n    // If pages is a string (and not 'all'), treat as single page name\n    return $page === $pages;\n}",
                    "parameters": [
                        {
                            "name": "tool",
                            "type": "array",
                            "description": "Tool configuration"
                        },
                        {
                            "name": "page",
                            "type": "string",
                            "description": "Page identifier (index, organism, group, assembly, parent, multi_organism_search)"
                        }
                    ],
                    "returnType": "bool",
                    "returnDescription": "True if tool should be visible on this page",
                    "internalCalls": [
                        "isToolVisibleOnPage"
                    ],
                    "category": "configuration",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/lib/functions_tools.php",
                            "line": 31,
                            "context": "if ($current_page && !isToolVisibleOnPage($tool, $current_page)) {"
                        }
                    ]
                }
            ]
        },
        {
            "name": "tools/generate_js_registry_json.php",
            "count": 4,
            "functions": [
                {
                    "name": "parseJsDoc",
                    "line": 22,
                    "comment": "/**\n* Extract JSDoc comment to get parameter and return information\n*/",
                    "code": "function parseJsDoc($comment) {\n    $params = [];\n    $returnType = 'void';\n    $returnDescription = '';\n    \n    if (empty($comment)) {\n        return ['params' => $params, 'returnType' => $returnType, 'returnDescription' => $returnDescription];\n    }\n    \n    // Extract @param lines\n    if (preg_match_all('/@param\\s+(?:\\{([^}]+)\\}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "parseJsDoc"
                    ],
                    "category": "data-processing",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/generate_js_registry_json.php",
                            "line": 274,
                            "context": "$docInfo = parseJsDoc($jsDocComment);"
                        }
                    ]
                },
                {
                    "name": "extractJsFunctionCalls",
                    "line": 54,
                    "comment": "/**\n* Extract function calls from JS function body\n*/",
                    "code": "function extractJsFunctionCalls($code, $allFunctionNames) {\n    $calls = [];\n    \n    // Find function calls: functionName( or this.functionName(\n    if (preg_match_all('/(?:^|[\\s\\.])([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/', $code, $matches)) {\n        foreach ($matches[1] as $called) {\n            if (in_array($called, $allFunctionNames)) {\n                $calls[] = $called;\n            }\n        }\n    }\n    \n    return array_values(array_unique($calls));\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "extractJsFunctionCalls"
                    ],
                    "category": "data-processing",
                    "tags": [
                        "readonly",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/generate_js_registry_json.php",
                            "line": 277,
                            "context": "$internalCalls = extractJsFunctionCalls($functionCode, $allJsFunctionNames);"
                        }
                    ]
                },
                {
                    "name": "determineJsCategory",
                    "line": 72,
                    "comment": "/**\n* Determine category for JS function\n*/",
                    "code": "function determineJsCategory($filename, $funcName) {\n    $filename = strtolower($filename);\n    $funcName = strtolower($funcName);\n    \n    // UI/DOM manipulation\n    if (strpos($filename, 'dom') !== false || strpos($filename, 'ui') !== false ||\n        strpos($funcName, 'render') !== false || strpos($funcName, 'display') !== false ||\n        strpos($funcName, 'show') !== false || strpos($funcName, 'hide') !== false) {\n        return 'ui-dom';\n    }\n    \n    // Event handling\n    if (strpos($funcName, 'event') !== false || strpos($funcName, 'listener') !== false ||\n        strpos($funcName, 'handler') !== false || strpos($funcName, 'click') !== false) {\n        return 'event-handling';\n    }\n    \n    // Data processing\n    if (strpos($funcName, 'parse') !== false || strpos($funcName, 'extract') !== false ||\n        strpos($funcName, 'filter') !== false || strpos($funcName, 'search') !== false) {\n        return 'data-processing';\n    }\n    \n    // Search/Filter\n    if (strpos($filename, 'search') !== false || strpos($filename, 'filter') !== false ||\n        strpos($funcName, 'search') !== false || strpos($funcName, 'filter') !== false) {\n        return 'search-filter';\n    }\n    \n    // Download/Export\n    if (strpos($funcName, 'download') !== false || strpos($funcName, 'export') !== false) {\n        return 'export';\n    }\n    \n    // DataTables\n    if (strpos($filename, 'datatable') !== false || strpos($filename, 'table') !== false) {\n        return 'datatable';\n    }\n    \n    // Admin tools\n    if (strpos($filename, 'manage') !== false || strpos($filename, 'admin') !== false) {\n        return 'admin';\n    }\n    \n    // BLAST\n    if (strpos($filename, 'blast') !== false) {\n        return 'blast';\n    }\n    \n    // Utilities\n    if (strpos($funcName, 'escape') !== false || strpos($funcName, 'sanitize') !== false) {\n        return 'utilities';\n    }\n    \n    return 'general';\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "determineJsCategory"
                    ],
                    "category": "utility",
                    "tags": [
                        "readonly",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/generate_js_registry_json.php",
                            "line": 280,
                            "context": "$category = determineJsCategory($fileName, $funcName);"
                        }
                    ]
                },
                {
                    "name": "determineJsTags",
                    "line": 132,
                    "comment": "/**\n* Determine tags for JS function\n*/",
                    "code": "function determineJsTags($comment, $code, $funcName) {\n    $tags = [];\n    \n    // DOM manipulation\n    if (preg_match('/\\.innerHTML|\\.textContent|appendChild|removeChild|classList|setAttribute|getElementById|querySelector/i', $code)) {\n        $tags[] = 'dom-manipulation';\n    }\n    \n    // Asynchronous\n    if (preg_match('/async|await|\\.then|\\.catch|Promise|setTimeout/i', $code)) {\n        $tags[] = 'asynchronous';\n    }\n    \n    // AJAX/HTTP\n    if (preg_match('/fetch|XMLHttpRequest|\\.ajax|\\.get|\\.post/i', $code)) {\n        $tags[] = 'ajax';\n    }\n    \n    // Event listener\n    if (preg_match('/addEventListener|on\\w+\\s*=|\\.on\\(/i', $code)) {\n        $tags[] = 'event-listener';\n    }\n    \n    // State modification\n    if (preg_match('/\\w+\\s*=/i', $code)) {\n        $tags[] = 'state-modifying';\n    }\n    \n    // Loop operations\n    if (preg_match('/forEach|for\\s*\\(|while\\s*\\(/i', $code)) {\n        $tags[] = 'loops';\n    }\n    \n    // Error handling\n    if (preg_match('/try\\s*\\{|catch|throw|error/i', $code)) {\n        $tags[] = 'error-handling';\n    }\n    \n    // Validation\n    if (preg_match('/validate|check|verify/i', $code)) {\n        $tags[] = 'validation';\n    }\n    \n    return array_values(array_unique($tags));\n}\n\n// Scan JS files and extract functions\necho \"\ud83d\udd0d Scanning JavaScript files...\\n\";\n$files = array_merge(\n    glob($jsDir . '/*.js') ?: [],\n    glob($jsDir . '/modules/*.js') ?: []\n);\n\n// First pass: collect all function names\necho \"\ud83d\udd0d Scanning JavaScript files (pass 1: collecting function names)...\\n\";\n$allJsFunctionNames = [];\n$jsFilesContent = [];\n\nforeach ($files as $file) {\n    if (strpos($file, '.min.js') !== false || strpos($file, 'unused') !== false) continue;\n    \n    $content = file_get_contents($file);\n    $jsFilesContent[$file] = $content;\n    \n    // Match function declarations and arrow functions\n    $patterns = [\n        '/(?:^|\\s)function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/m',\n        '/(?:^|\\s)(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:function|\\()/m',\n    ];\n    \n    foreach ($patterns as $pattern) {\n        if (preg_match_all($pattern, $content, $matches)) {\n            foreach ($matches[1] as $funcName) {\n                if (!in_array($funcName, $allJsFunctionNames)) {\n                    $allJsFunctionNames[] = $funcName;\n                }\n            }\n        }\n    }\n}\n\n// Second pass: extract functions with full metadata\necho \"\ud83d\udd0d Scanning JavaScript files (pass 2: extracting metadata)...\\n\";\n\nforeach ($files as $file) {\n    if (strpos($file, '.min.js') !== false || strpos($file, 'unused') !== false) continue;\n    \n    $content = $jsFilesContent[$file];\n    $functions = [];\n    $fileName = basename($file);\n    \n    // Match function declarations and arrow functions\n    $patterns = [\n        '/(?:^|\\s)function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/m',\n        '/(?:^|\\s)(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:function|\\()/m',\n    ];\n    \n    foreach ($patterns as $pattern) {\n        if (preg_match_all($pattern, $content, $matches, PREG_OFFSET_CAPTURE)) {\n            foreach ($matches[0] as $idx => $match) {\n                $funcName = $matches[1][$idx][0];\n                $startPos = $match[1];\n                $lineNum = substr_count($content, \"\\n\", 0, $startPos) + 1;\n                \n                // Extract function code by finding matching braces\n                $braceCount = 0;\n                $functionCode = '';\n                $chars = str_split($content);\n                \n                // Find opening brace\n                $bodyStart = $startPos;\n                for ($i = $startPos; $i < strlen($content); $i++) {\n                    if ($chars[$i] === '{') {\n                        $bodyStart = $i;\n                        break;\n                    }\n                }\n                \n                // Extract until matching closing brace\n                for ($i = $bodyStart; $i < strlen($content) && $i < $bodyStart + 2000; $i++) {\n                    $char = $chars[$i];\n                    $functionCode .= $char;\n                    \n                    if ($char === '{') $braceCount++;\n                    elseif ($char === '}') {\n                        $braceCount--;\n                        if ($braceCount === 0) break;\n                    }\n                }\n                \n                // Extract JSDoc comment (look for /** ... */ immediately before function)\n                $jsDocComment = '';\n                // Get only the last 1000 chars before function to avoid matching file header\n                $startSearch = max(0, $startPos - 1000);\n                $nearFunc = substr($content, $startSearch, $startPos - $startSearch);\n                // Find the LAST occurrence of /** ... */ in this section\n                // Use non-greedy match with limited scope\n                if (preg_match('/\\/\\*\\*[^*]*(?:\\*(?!\\/)[^*]*)*\\*\\/(?:\\s|\\/\\/[^\\n]*\\n)*$/s', $nearFunc, $jsDocMatch)) {\n                    $jsDocComment = $jsDocMatch[0];\n                }\n                \n                // Parse JSDoc for parameters and return type\n                $docInfo = parseJsDoc($jsDocComment);\n                \n                // Extract internal function calls\n                $internalCalls = extractJsFunctionCalls($functionCode, $allJsFunctionNames);\n                \n                // Determine category and tags\n                $category = determineJsCategory($fileName, $funcName);\n                $tags = determineJsTags($jsDocComment, $functionCode, $funcName);\n                \n                $functions[] = [\n                    'name' => $funcName,\n                    'line' => $lineNum,\n                    'comment' => $jsDocComment,\n                    'code' => trim($functionCode),\n                    'parameters' => $docInfo['params'],\n                    'returnType' => $docInfo['returnType'],\n                    'returnDescription' => $docInfo['returnDescription'],\n                    'internalCalls' => $internalCalls,\n                    'category' => $category,\n                    'tags' => $tags,\n                    'usageCount' => 0,\n                    'usages' => [],\n                    'phpFilesCount' => 0,\n                    'phpFiles' => []\n                ];\n            }\n        }\n    }\n    \n    if (!empty($functions)) {\n        $relativePath = str_replace(__DIR__ . '/../', '', $file);\n        $registry[$relativePath] = $functions;\n    }\n}\n\n// Find which PHP files include/use each JS file\necho \"\ud83d\udd0d Scanning for PHP files using JavaScript...\\n\";\n$phpFilesByJsFile = [];\nforeach ($registry as $jsFile => $funcs) {\n    $jsFileName = basename($jsFile);\n    $phpFiles = [];\n    \n    $searchDirs = [\n        __DIR__ . '/../*.php',\n        __DIR__ . '/../admin/*.php',\n        __DIR__ . '/../admin/**/*.php',\n        __DIR__ . '/../tools/*.php',\n        __DIR__ . '/../tools/**/*.php',\n    ];\n    \n    $allPhpFiles = [];\n    foreach ($searchDirs as $pattern) {\n        $allPhpFiles = array_merge($allPhpFiles, glob($pattern));\n    }\n    \n    foreach (array_unique($allPhpFiles) as $phpFile) {\n        if (file_exists($phpFile) && strpos(file_get_contents($phpFile), $jsFileName) !== false) {\n            $phpFiles[] = str_replace(__DIR__ . '/../', '', $phpFile);\n        }\n    }\n    \n    if (!empty($phpFiles)) {\n        $phpFilesByJsFile[$jsFile] = array_unique($phpFiles);\n    }\n}\n\n// Find function usages in JS and PHP files\necho \"\ud83d\udd0d Scanning for function usages...\\n\";\n$scanDirs = [\n    __DIR__ . '/../js',\n    __DIR__ . '/../admin',\n    __DIR__ . '/../tools',\n    __DIR__ . '/..'\n];\n\nforeach ($registry as $jsFile => &$functions) {\n    foreach ($functions as &$func) {\n        $usages = [];\n        $seen = [];\n        $searchPattern = '/\\b' . preg_quote($func['name'], '/') . '\\s*\\(/';\n        \n        // Search in JS files\n        $jsFiles = array_merge(\n            glob($jsDir . '/*.js') ?: [],\n            glob($jsDir . '/modules/*.js') ?: []\n        );\n        \n        foreach ($jsFiles as $file) {\n            if (strpos($file, '.min.js') !== false || strpos($file, 'unused') !== false) continue;\n            \n            $content = file_get_contents($file);\n            \n            if (preg_match_all($searchPattern, $content, $matches, PREG_OFFSET_CAPTURE)) {\n                foreach ($matches[0] as $match) {\n                    $lineNum = substr_count($content, \"\\n\", 0, $match[1]) + 1;\n                    \n                    $lines = explode(\"\\n\", $content);\n                    $contextLine = isset($lines[$lineNum - 1]) ? trim($lines[$lineNum - 1]) : '';\n                    \n                    // Skip comments\n                    if (preg_match('/^\\s*(\\/\\/|\\/\\*|\\*|#)/', $contextLine)) continue;\n                    \n                    // Skip function definition\n                    if (preg_match('/(?:^|\\s)(?:function|const|let|var)\\s+' . preg_quote($func['name']) . '\\s*[=:\\(]/', $contextLine)) continue;\n                    \n                    $relativeFile = str_replace(__DIR__ . '/../', '', $file);\n                    $usageKey = $relativeFile . ':' . $lineNum;\n                    \n                    if (isset($seen[$usageKey])) continue;\n                    $seen[$usageKey] = true;\n                    \n                    $usages[] = [\n                        'file' => $relativeFile,\n                        'line' => $lineNum,\n                        'context' => $contextLine\n                    ];\n                }\n            }\n        }\n        \n        // Also search in PHP files for inline JS calls\n        $phpFiles = array_merge(\n            glob(__DIR__ . '/../*.php') ?: [],\n            glob(__DIR__ . '/../admin/*.php') ?: [],\n            glob(__DIR__ . '/../admin/**/*.php') ?: [],\n            glob(__DIR__ . '/../tools/*.php') ?: [],\n            glob(__DIR__ . '/../tools/**/*.php') ?: []\n        );\n        \n        foreach (array_unique($phpFiles) as $phpFile) {\n            if (!file_exists($phpFile) || strpos($phpFile, 'function_registry') !== false) continue;\n            \n            $content = file_get_contents($phpFile);\n            \n            if (preg_match_all($searchPattern, $content, $matches, PREG_OFFSET_CAPTURE)) {\n                foreach ($matches[0] as $match) {\n                    $lineNum = substr_count($content, \"\\n\", 0, $match[1]) + 1;\n                    \n                    $lines = explode(\"\\n\", $content);\n                    $contextLine = isset($lines[$lineNum - 1]) ? trim($lines[$lineNum - 1]) : '';\n                    \n                    // Skip PHP comments\n                    if (preg_match('/^\\s*(\\/\\/|\\/\\*|\\*|#)/', $contextLine)) continue;\n                    \n                    $relativeFile = str_replace(__DIR__ . '/../', '', $phpFile);\n                    $usageKey = $relativeFile . ':' . $lineNum;\n                    \n                    if (isset($seen[$usageKey])) continue;\n                    $seen[$usageKey] = true;\n                    \n                    $usages[] = [\n                        'file' => $relativeFile,\n                        'line' => $lineNum,\n                        'context' => $contextLine\n                    ];\n                }\n            }\n        }\n        \n        $func['usageCount'] = count($usages);\n        $func['usages'] = $usages;\n        \n        // Add PHP files that include this JS file\n        if (isset($phpFilesByJsFile[$jsFile])) {\n            $func['phpFilesCount'] = count($phpFilesByJsFile[$jsFile]);\n            $func['phpFiles'] = $phpFilesByJsFile[$jsFile];\n        }\n    }\n}\nunset($func);\n\n// Build registry data structure\n$totalFuncs = 0;\n$fileArray = [];\n\nforeach ($registry as $file => $functions) {\n    $totalFuncs += count($functions);\n    $fileArray[] = [\n        'name' => $file,\n        'count' => count($functions),\n        'functions' => $functions\n    ];\n}\n\n// Find unused functions\n$unused = [];\nforeach ($fileArray as $fileEntry) {\n    foreach ($fileEntry['functions'] as $func) {\n        if ($func['usageCount'] === 0) {\n            $unused[] = [\n                'name' => $func['name'],\n                'file' => $fileEntry['name'],\n                'line' => $func['line']\n            ];\n        }\n    }\n}\n\n// Sort files by name\nusort($fileArray, function($a, $b) {\n    return strcmp($a['name'], $b['name']);\n});\n\n// Build final registry\n$registryData = [\n    'metadata' => [\n        'generated' => date('Y-m-d H:i:s'),\n        'totalFunctions' => $totalFuncs,\n        'totalFiles' => count($fileArray),\n        'duplicates' => 0,\n    ],\n    'files' => $fileArray,\n    'unused' => $unused,\n];\n\n// Save JSON\n$jsonFile = $docs_path . '/js_function_registry.json';\n@mkdir(dirname($jsonFile), 0755, true);\n\n$json = json_encode($registryData, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);\nif (file_put_contents($jsonFile, $json)) {\n    echo \"\\n\u2705 JavaScript Registry generated successfully!\\n\";\n    echo \"   File: \" . str_replace(__DIR__ . '/../', '', $jsonFile) . \"\\n\";\n    echo \"   Total Functions: \" . $totalFuncs . \"\\n\";\n    echo \"   Files Scanned: \" . count($fileArray) . \"\\n\";\n    echo \"   Unused Functions: \" . count($unused) . \"\\n\";\n} else {\n    echo \"\\n\u274c Error writing JSON file\\n\";\n    exit(1);\n}",
                    "parameters": [],
                    "returnType": "void",
                    "returnDescription": "",
                    "internalCalls": [
                        "determineJsTags",
                        "parseJsDoc",
                        "extractJsFunctionCalls",
                        "determineJsCategory"
                    ],
                    "category": "utility",
                    "tags": [
                        "mutation",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/generate_js_registry_json.php",
                            "line": 281,
                            "context": "$tags = determineJsTags($jsDocComment, $functionCode, $funcName);"
                        }
                    ]
                }
            ]
        },
        {
            "name": "tools/sequences_display.php",
            "count": 1,
            "functions": [
                {
                    "name": "extractSequencesFromFasta",
                    "line": 142,
                    "comment": "/**\n* Extract sequences from a FASTA file for specific feature IDs\n*\n* @param string $fasta_file Path to FASTA file\n* @param array $feature_ids Array of feature IDs to extract\n* @return array Associative array with feature_id => sequence content\n*/",
                    "code": "function extractSequencesFromFasta($fasta_file, $feature_ids, $seq_type, &$errors) {\n    $sequences = [];\n    \n    // Validate inputs\n    if (empty($fasta_file)) {\n        $errors[] = \"FASTA file path is empty for $seq_type sequences\";\n        return $sequences;\n    }\n    \n    if (empty($feature_ids)) {\n        $errors[] = \"No feature IDs provided to extract\";\n        return $sequences;\n    }\n    \n    // Check if file exists\n    if (!file_exists($fasta_file)) {\n        $errors[] = \"FASTA file not found for $seq_type: \" . basename($fasta_file);\n        return $sequences;\n    }\n    \n    // Build list of IDs to search, including variants for parent/child relationships\n    $search_ids = [];\n    foreach ($feature_ids as $id) {\n        $search_ids[] = $id;\n        // Also try with .1 suffix if not already present (for parent->child relationships)\n        if (substr($id, -2) !== '.1') {\n            $search_ids[] = $id . '.1';\n        }\n    }\n    \n    // Use blastdbcmd to extract sequences - it accepts comma-separated IDs\n    $ids_string = implode(',', $search_ids);\n    $cmd = \"blastdbcmd -db \" . escapeshellarg($fasta_file) . \" -entry \" . escapeshellarg($ids_string) . \" 2>/dev/null\";\n    $output = [];\n    $return_var = 0;\n    @exec($cmd, $output, $return_var);\n    \n    // Check if blastdbcmd executed\n    if ($return_var > 1) {\n        // Return code 1 is expected when some IDs don't exist, but >1 is an error\n        $errors[] = \"Error extracting $seq_type sequences (exit code: $return_var). Ensure blastdbcmd is installed and FASTA files are formatted correctly.\";\n        return $sequences;\n    }\n    \n    // Check if we got any output\n    // If empty, it just means these IDs don't exist in this file type (e.g., gene IDs won't be in genome.fa)\n    // Return empty sequences gracefully - not an error\n    if (empty($output)) {\n        return $sequences;\n    }\n    \n    // Parse FASTA output into individual sequences by feature ID\n    $current_id = null;\n    $current_seq = [];\n    \n    foreach ($output as $line) {\n        if (strpos($line, '>') === 0) {\n            // Header line\n            if (!is_null($current_id)) {\n                // Store previous sequence with full FASTA format (including >)\n                $sequences[$current_id] = implode(\"\\n\", array_merge([\">\" . $current_id], $current_seq));\n            }\n            // Extract ID from header (remove leading '>')\n            $current_id = substr($line, 1);\n            $current_seq = [];\n        } else {\n            // Sequence line\n            $current_seq[] = $line;\n        }\n    }\n    \n    // Store last sequence with full FASTA format\n    if (!is_null($current_id)) {\n        $sequences[$current_id] = implode(\"\\n\", array_merge([\">\" . $current_id], $current_seq));\n    }\n    \n    return $sequences;\n}",
                    "parameters": [
                        {
                            "name": "fasta_file",
                            "type": "string",
                            "description": "Path to FASTA file"
                        },
                        {
                            "name": "feature_ids",
                            "type": "array",
                            "description": "Array of feature IDs to extract"
                        }
                    ],
                    "returnType": "array",
                    "returnDescription": "Associative array with feature_id => sequence content",
                    "internalCalls": [
                        "extractSequencesFromFasta"
                    ],
                    "category": "data-processing",
                    "tags": [
                        "readonly",
                        "error-handling",
                        "database-dependent",
                        "file-io",
                        "loops",
                        "recursive"
                    ],
                    "usageCount": 1,
                    "usages": [
                        {
                            "file": "/data/moop/tools/sequences_display.php",
                            "line": 142,
                            "context": "$sequences = extractSequencesFromFasta($fasta_file, $feature_ids, $seq_type, $extraction_errors);"
                        }
                    ]
                }
            ]
        }
    ],
    "unused": [
        {
            "name": "filterDatabasesByProgram",
            "file": "lib/blast_functions.php",
            "line": 72
        },
        {
            "name": "generateBlastGraphicalView",
            "file": "lib/blast_results_visualizer.php",
            "line": 354
        },
        {
            "name": "generateBlastStatisticsSummary",
            "file": "lib/blast_results_visualizer.php",
            "line": 652
        },
        {
            "name": "getColorStyle",
            "file": "lib/blast_results_visualizer.php",
            "line": 1267
        },
        {
            "name": "generateQueryScale",
            "file": "lib/blast_results_visualizer.php",
            "line": 1102
        },
        {
            "name": "getFeaturesByType",
            "file": "lib/database_queries.php",
            "line": 157
        },
        {
            "name": "searchFeaturesByUniquename",
            "file": "lib/database_queries.php",
            "line": 187
        },
        {
            "name": "getAnnotationsByFeature",
            "file": "lib/database_queries.php",
            "line": 219
        },
        {
            "name": "getOrganismInfo",
            "file": "lib/database_queries.php",
            "line": 240
        },
        {
            "name": "searchFeaturesAndAnnotationsLike",
            "file": "lib/database_queries.php",
            "line": 468
        },
        {
            "name": "buildFilteredSourcesList",
            "file": "lib/extract_search_helpers.php",
            "line": 286
        },
        {
            "name": "assignGroupColors",
            "file": "lib/extract_search_helpers.php",
            "line": 336
        },
        {
            "name": "resolveSourceSelection",
            "file": "lib/functions_access.php",
            "line": 49
        },
        {
            "name": "buildLikeConditions",
            "file": "lib/functions_database.php",
            "line": 256
        },
        {
            "name": "consolidateSynonym",
            "file": "lib/functions_json.php",
            "line": 248
        },
        {
            "name": "getAnnotationDisplayLabel",
            "file": "lib/functions_json.php",
            "line": 299
        },
        {
            "name": "test_input",
            "file": "lib/functions_validation.php",
            "line": 23
        },
        {
            "name": "validate_search_term",
            "file": "lib/functions_validation.php",
            "line": 68
        },
        {
            "name": "is_quoted_search",
            "file": "lib/functions_validation.php",
            "line": 97
        },
        {
            "name": "getAllTools",
            "file": "lib/tool_config.php",
            "line": 62
        }
    ]
}